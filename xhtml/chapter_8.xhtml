<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>8 Virtual Machine II: Control</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch8"><span aria-label="147" id="pg_147" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">8</samp>       <samp class="SANS_Helvetica_LT_Std_Bold_B_11">Virtual Machine II: Control</samp></h1>
</header>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP1">If everything seems under control, you’re just not going fast enough.</p>
<p class="EPA1">—Mario Andretti (b. 1940), race car champion</p>
</blockquote>
<p class="noindent">Chapter 7 introduced the notion of a <i>virtual machine</i> (VM), and project 7 began implementing our abstract virtual machine and VM language over the Hack platform. The implementation entailed developing a program that translates VM commands into Hack assembly code. Specifically, in the previous chapter we learned how to use and implement the VM’s arithmetic-logical commands and push/pop commands; in this chapter we’ll learn how to use and implement the VM’s branching commands and function commands. As the chapter progresses, we’ll extend the basic translator developed in project 7, ending with a full-scale VM translator over the Hack platform. This translator will serve as the back-end module of the compiler that we will build in chapters 10 and 11.</p>
<p>In any Gre at Gems in Applied Computer Science contest, stack processing will be a strong finalist. The previous chapter showed how arithmetic and Boolean expressions can be represented and evaluated by elementary operations on a stack. This chapter goes on to show how this remarkably simple data structure can also support remarkably complex tasks like nested function calling, parameter passing, recursion, and the various memory allocation and recycling tasks required to support program execution during run-time. Most programmers tend to take these services for granted, expecting the compiler and the operating system to deliver them, one way or another. We are now in a position to open up this black box and see how these fundamental programming mechanisms are actually realized.</p>
<p class="STNI1"><b>Run-time system</b>: Every computer system must specify a run-time model. This model answers essential questions without which programs cannot run: how to start a program’s execution, what the computer should do when a program terminates, how to pass arguments from one function to another, how to allocate memory resources to running functions, how to free memory resources when they are no longer needed, and so on.</p>
<p>In Nand to Tetris, these issues are addressed by the <i>VM language</i> specification, along with the <i>standard mapping on the Hack platform</i> specification. If a VM translator is developed <span aria-label="148" id="pg_148" role="doc-pagebreak"/>according to these guidelines, it will end up realizing an executable run-time system. In particular, the VM translator will not only translate the VM commands (<samp class="SANS_Consolas_Regular_11">push</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>, and so on) into assembly instructions—it will also generate assembly code that realizes an envelope in which the program runs. All the questions mentioned above—how to start a program, how to manage the function call-and-return behavior, and so on—will be answered by generating enabling assembly code that wraps the code proper. Let’s see an example.</p>
<section epub:type="division">
<h2 class="head a-head"><b>8.1    High-Level Magic</b></h2>
<p class="noindent">High-level languages allow writing programs in high-level terms. For example, an expression like <img alt="" class="inline" height="23" src="../images/Ch08_IEQ_001.png" width="152"/> can be written as <img alt="" class="inline" height="14" src="../images/8-C1.png" width="254"/> which is almost as descriptive as the real thing. Note the difference between primitive operations like <span class="symb-code">+</span> and <span class="symb-code">−</span> and functions like <samp class="SANS_Consolas_Regular_11">sqrt</samp> and <samp class="SANS_Consolas_Regular_11">power</samp>. The former are built into the basic syntax of the high-level language. The latter are extensions of the basic language.</p>
<p>The unlimited capacity to extend the language at will is one of the most important features of high-level programming languages. Of course, at some point, someone must implement functions like <samp class="SANS_Consolas_Regular_11">sqrt</samp> and <samp class="SANS_Consolas_Regular_11">power</samp>. However, the story of implementing these abstractions is completely separate from the story of using them. Therefore, application programmers can assume that each one of these functions will get executed—somehow—and that following its execution, control will return—somehow—to the next operation in one’s code. Branching commands endow the language with additional expressive power, allowing writing conditional code like <samp class="SANS_Consolas_Regular_11">if</samp> <samp class="SANS_Consolas_Regular_11">!</samp> <img alt="" class="inline" height="14" src="../images/8-C2.png" width="531"/> Once again, we see that high-level code enables the expression of high-level logic—in this case the algorithm for solving quadratic equations—almost directly.</p>
<p>Indeed, modern programming languages are programmer-friendly, offering useful and powerful abstractions. It is a sobering thought, though, that no matter how high we allow our high-level language to be, at the end of the day it must be realized on some hardware platform that can only execute primitive machine instructions. Thus, among other things, compiler and VM architects must find low-level solutions for realizing branching and function call-and-return commands.</p>
<p><i>Functions</i>—the bread and butter of modular programming—are standalone programming units that are allowed to call each other for their effect. For example, <samp class="SANS_Consolas_Regular_11">solve</samp> can call <samp class="SANS_Consolas_Regular_11">sqrt</samp>, and <samp class="SANS_Consolas_Regular_11">sqrt</samp>, in turn, can call <samp class="SANS_Consolas_Regular_11">power</samp>. This calling sequence can be as deep as we please, as well as recursive. Typically, the calling function (the <i>caller</i>) passes arguments to the called function (the <i>callee</i>) and suspends its execution until the latter completes <i>its</i> execution. The callee uses the passed arguments to execute or compute something and then returns a value (which may be <samp class="SANS_Consolas_Regular_11">void</samp>) to the caller. The caller then snaps back into action, resuming its execution.</p>
<p>In general then, whenever one function (the <i>caller</i>) calls a function (the <i>callee</i><samp class="SANS_Consolas_Regular_11">)</samp>, someone must take care of the following overhead:</p>
<ul class="bullet">
<li class="BL"><span aria-label="149" id="pg_149" role="doc-pagebreak"/>Save the <i>return address</i>, which is the address within the caller’s code to which execution must return after the callee completes its execution;</li>
<li class="BL1">Save the memory resources of the caller;</li>
<li class="BL1">Allocate the memory resources required by the callee;</li>
<li class="BL1">Make the arguments passed by the caller available to the callee’s code;</li>
<li class="BLL1">Start executing the callee’s code.</li>
</ul>
<p class="TNI1">When the callee terminates and returns a value, someone must take care of the following overhead:</p>
<ul class="List-1">
<li class="BLF">Make the callee’s <i>return value</i> available to the caller’s code;</li>
<li class="BL1">Recycle the memory resources used by the callee;</li>
<li class="BL1">Reinstate the previously saved memory resources of the caller;</li>
<li class="BL1">Retrieve the previously saved <i>return address</i>;</li>
<li class="BLL1">Resume executing the caller’s code, from the return address onward.</li>
</ul>
<p class="TNI1">Blissfully, high-level programmers don’t have to ever think about all these nitty-gritty chores: the assembly code generated by the compiler handles them, stealthily and efficiently. And, in a two-tier compilation model, this housekeeping responsibility falls on the compiler’s back end, which is the VM translator that we are now developing. Thus, in this chapter, we will uncover, among other things, the run-time framework that enables what is probably the most important abstraction in the art of programming: <i>function call-and-return</i>. But first, let’s start with the easier challenge of handling branching commands.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>8.2    Branching</b></h2>
<p class="noindent">The default flow of computer programs is sequential, executing one command after the other. For various reasons like embarking on a new iteration in a loop, this sequential flow can be redirected by branching commands. In low-level programming, branching is accomplished by <i>goto destination</i> commands. The destination specification can take several forms, the most primitive being the physical memory address of the instruction that should be executed next. A slightly more abstract specification is established by specifying a symbolic label (bound to a physical memory address). This variation requires that the language be equipped with a labeling directive, designed to assign symbolic labels to selected locations in the code. In our VM language, this is done using a labeling command whose syntax is <samp class="SANS_Consolas_Regular_11">label</samp> <i>symbol</i>.</p>
<p>With that in mind, the VM language supports two forms of branching. <i>Unconditional branching</i> is effected using a <samp class="SANS_Consolas_Regular_11">goto</samp> <i>symbol</i> command, which means: jump to execute the command just after the <samp class="SANS_Consolas_Regular_11">label</samp> <i>symbol</i> command in the code. <i>Conditional branching</i> is <span aria-label="150" id="pg_150" role="doc-pagebreak"/>effected using the <samp class="SANS_Consolas_Regular_11">if-goto</samp> <i>symbol</i> command, whose semantics is: Pop the topmost value off the stack; if it’s not <samp class="SANS_Consolas_Regular_11">false</samp>, jump to execute the command just after the <samp class="SANS_Consolas_Regular_11">label</samp> <i>symbol</i> command; otherwise, execute the next command in the code. This contract implies that before specifying a conditional goto command, the VM code writer (for example, a compiler) must first specify a condition. In our VM language, this is done by pushing a Boolean expression onto the stack. For example, the compiler that we’ll develop in chapters 10–11 will translate <samp class="SANS_Consolas_Regular_11">if</samp> <img alt="" class="inline" height="14" src="../images/8-C3.png" width="57"/> <samp class="SANS_Consolas_Regular_11">goto</samp> <samp class="SANS_Consolas_Regular_11">LOOP</samp> into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">n,</samp> <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">100,</samp> <samp class="SANS_Consolas_Regular_11">lt,</samp> <samp class="SANS_Consolas_Regular_11">if-goto</samp> <samp class="SANS_Consolas_Regular_11">LOOP</samp>.</p>
<p class="STNI1"><b>Example</b>: Consider a function that receives two arguments, <i>x</i> and <i>y</i>, and returns the product <i>x</i> ∙ <i>y</i>. This can be done by adding <i>x</i> repetitively to a local variable, say <samp class="SANS_Consolas_Regular_11">sum</samp>, <i>y</i> times, and then returning <samp class="SANS_Consolas_Regular_11">sum</samp>’s value. A function that implements this na<span class="dcrit">ï</span>ve multiplication algorithm is listed in <a href="chapter_8.xhtml#fig8-1" id="rfig8-1">figure 8.1</a>. This example illustrates how a typical looping logic can be expressed using the VM branching commands <samp class="SANS_Consolas_Regular_11">goto</samp>, <samp class="SANS_Consolas_Regular_11">if-goto</samp>, and <samp class="SANS_Consolas_Regular_11">label</samp>.</p>
<figure class="IMG"><img alt="" id="fig8-1" src="../images/figure_8.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig8-1">Figure 8.1</a></b>    Branching commands action. (The VM code on the right uses symbolic variable names instead of virtual memory segments, to make it more readable.)</p></figcaption>
</figure>
<p>Notice how the Boolean condition <samp class="SANS_Consolas_Regular_11">!<img alt="" class="inline" height="14" src="../images/8-C4.png" width="46"/></samp> implemented as <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">i</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, <samp class="SANS_Consolas_Regular_11">lt</samp>, <samp class="SANS_Consolas_Regular_11">ng</samp>, is pushed onto the stack just before the <samp class="SANS_Consolas_Regular_11">if-goto</samp> <samp class="SANS_Consolas_Regular_11">WHILE_END</samp> command. In chapter 7 we saw that VM commands can be used to express and evaluate any Boolean expression. As we see in <a href="chapter_8.xhtml#fig8-1">figure 8.1</a>, high-level control structures like <samp class="SANS_Consolas_Regular_11">if</samp> and <samp class="SANS_Consolas_Regular_11">while</samp> can be easily realized using nothing more than <samp class="SANS_Consolas_Regular_11">goto</samp> and <samp class="SANS_Consolas_Regular_11">if-goto</samp> commands. In general, any flow of control <span aria-label="151" id="pg_151" role="doc-pagebreak"/>structure found in high-level programming languages can be realized using our (rather minimal set of) VM logical and branching commands.</p>
<p class="STNI1"><b>Implementation</b>: Most low-level machine languages, including Hack, feature means for declaring symbolic labels and for effecting conditional and unconditional “goto label” actions. Therefore, if we base the VM implementation on a program that translates VM commands into assembly instructions, implementing the VM branching commands is a relatively simple matter.</p>
<p class="STNI1"><b>Operating system</b>: We end this section with two side comments. First, VM programs are not written by humans. Rather, they are written by compilers. <a href="chapter_8.xhtml#fig8-1">Figure 8.1</a> illustrates source code on the left and VM code on the right. In chapters 10–11 we’ll develop a <i>compiler</i> that translates the former into the latter. Second, note that the <samp class="SANS_Consolas_Regular_11">mult</samp> implementation shown in <a href="chapter_8.xhtml#fig8-1">figure 8-1</a> is inefficient. Later in the book we’ll present optimized multiplication and division algorithms that operate at the bit level. These algorithms will be used for realizing the <samp class="SANS_Consolas_Regular_11">Math.multiply</samp> and <samp class="SANS_Consolas_Regular_11">Math.divide</samp> functions, which are part of the operating system that we will build in chapter 12.</p>
<p>Our OS will be written in the Jack language, and translated by a Jack compiler into the VM language. The result will be a library of eight files named <samp class="SANS_Consolas_Regular_11">Math.vm</samp>, <samp class="SANS_Consolas_Regular_11">Memory.vm</samp>, <samp class="SANS_Consolas_Regular_11">String.vm</samp>, <samp class="SANS_Consolas_Regular_11">Array.vm</samp>, <samp class="SANS_Consolas_Regular_11">Output.vm</samp>, <samp class="SANS_Consolas_Regular_11">Screen.vm</samp>, <samp class="SANS_Consolas_Regular_11">Keyboard.vm,</samp> <samp class="SANS_Consolas_Regular_11">and</samp> <samp class="SANS_Consolas_Regular_11">Sys.vm</samp> (the OS API is given in appendix 6). Each OS file features a collection of useful functions that any VM function is welcome to call for their effect. For example, whenever a VM function needs multiplication or division services, it can call the <samp class="SANS_Consolas_Regular_11">Math.multiply</samp> or <samp class="SANS_Consolas_Regular_11">Math.divide</samp> function.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>8.3    Functions</b></h2>
<p class="noindent">Every programming language is characterized by a fixed set of built-in operations. In addition, high-level and some low-level languages offer the great freedom of extending this fixed repertoire with an open-ended collection of programmer-defined operations. Depending on the language, these canned operations are typically called <i>subroutines</i>, <i>procedures</i>, <i>methods</i>, or <i>functions</i>. In our VM language, all these programming units are referred to as <i>functions</i>.</p>
<p>In well-designed languages, built-in commands and programmer-defined functions have the same look and feel. For example, to compute <img alt="" class="inline" height="12" src="../images/8-1.png" width="33"/> on our stack machine, we <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">x</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, and <samp class="SANS_Consolas_Regular_11">add</samp>. In doing so, we expect the <samp class="SANS_Consolas_Regular_11">add</samp> implementation to pop the two top values off the stack, add them up, and push the result onto the stack. Suppose now that either we, or someone else, has written a <i>power</i> function designed to compute <img alt="" class="inline" height="10" src="../images/8-2.png" width="14"/>. To use this function, we follow exactly the same routine: we <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">x,</samp> <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, and <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">power</samp>. This consistent calling protocol allows composing primitive commands and function calls <span aria-label="152" id="pg_152" role="doc-pagebreak"/>seamlessly. For example, expressions like <img alt="" class="inline" height="16" src="../images/8-3.png" width="50"/> can be evaluated using <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">x</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">3</samp>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">power</samp>.</p>
<p>We see that the only difference between applying a primitive operation and invoking a function is the keyword <samp class="SANS_Consolas_Regular_11">call</samp> preceding the latter. Everything else is exactly the same: both operations require the caller to set the stage by pushing arguments onto the stack, both operations are expected to consume their arguments, and both operations are expected to push return values onto the stack. This calling protocol has an elegant consistency which, we hope, is not lost on the reader.</p>
<p class="STNI1"><b>Example</b>: <a href="chapter_8.xhtml#fig8-2" id="rfig8-2">Figure 8.2</a> shows a VM program that computes the function <img alt="" class="inline" height="23" src="../images/Ch08_IEQ_002.png" width="61"/>, also known as <i>hypot</i>. The program consists of three functions, with the following run-time behavior: <samp class="SANS_Consolas_Regular_11">main</samp> calls <samp class="SANS_Consolas_Regular_11">hypot</samp>, and then <samp class="SANS_Consolas_Regular_11">hypot</samp> calls <samp class="SANS_Consolas_Regular_11">mult</samp>, twice. There is also a call to a <samp class="SANS_Consolas_Regular_11">sqrt</samp> function, which we don’t track, to reduce clutter.</p>
<figure class="IMG"><img alt="" height="550" id="fig8-2" src="../images/figure_8.2.png"/>
<figcaption><p class="CAP"><b><a href="#rfig8-2">Figure 8.2</a></b>    Run-time snapshots of selected stack and segment states during the execution of a three-function program. The line numbers are not part of the code and are given for reference only.</p></figcaption>
</figure>
<p>The bottom part of <a href="chapter_8.xhtml#fig8-2">figure 8.2</a> shows that during run-time, each function sees a private world, consisting of its own working stack and memory segments. These separate worlds are connected through two “wormholes”: when a function says <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">mult</samp>, the arguments that it pushed onto its stack prior to the call are somehow passed to the <samp class="SANS_Consolas_Regular_11">argument</samp> segment of the callee. Likewise, when a function says <samp class="SANS_Consolas_Regular_11">return</samp>, the last value that it pushed onto its stack just before returning is somehow copied onto the stack of the caller, replacing the previously pushed arguments. These hand-shaking actions are carried out by the VM implementation, as we now turn to describe.</p>
<p class="STNI1"><b>Implementation</b>: A computer program consists of typically several and possibly many functions. Yet at any given point during run-time, only a few of these functions are actually doing something. We use the term <i>calling chain</i> to refer, conceptually, to all the functions that are currently involved in the program’s execution. When a VM program starts running, the calling chain consists of one function only, say, <samp class="SANS_Consolas_Regular_11">main</samp>. At some point, <samp class="SANS_Consolas_Regular_11">main</samp> may call another function, say, <samp class="SANS_Consolas_Regular_11">foo</samp>, and that function may call yet another function, say, <samp class="SANS_Consolas_Regular_11">bar</samp>. At this point the calling chain is <img alt="" class="inline" height="11" src="../images/8-C5.png" width="119"/> Each function in the calling chain waits for the function that it called to return. Thus, the only function that is truly active in the calling chain is the last one, which we call the <i>current function</i>, meaning the currently executing function.</p>
<p>In order to carry out their work, functions normally use <i>local</i> and <i>argument</i> variables. These variables are temporary: the memory segments that represent them must be allocated when the function starts executing and can be recycled when the function returns. This memory management task is complicated by the requirement that function calling is allowed to be arbitrarily nested, as well as recursive. During run-time, each function call must be executed independently of all the other calls and maintain its own stack, local variables, and argument variables. How can we implement this unlimited nesting mechanism and the memory management tasks associated with it?<span aria-label="153" id="pg_153" role="doc-pagebreak"/></p>
<p><span aria-label="154" id="pg_154" role="doc-pagebreak"/>The property that makes this housekeeping task tractable is the linear nature of the call-and-return logic. Although the function calling chain may be arbitrarily deep as well as recursive, at any given point in time only one function executes at the chain’s end, while all the other functions up the calling chain are waiting for it to return. This <i>Last-In-First-Out</i> processing model lends itself perfectly to the stack data structure, which is also LIFO. Let’s takes a closer look.</p>
<p>Assume that the current function is <samp class="SANS_Consolas_Regular_11">foo</samp>. Suppose that <samp class="SANS_Consolas_Regular_11">foo</samp> has already pushed some values onto its working stack and has modified some entries in its memory segments. Suppose that at some point <samp class="SANS_Consolas_Regular_11">foo</samp> wants to call another function, <samp class="SANS_Consolas_Regular_11">bar</samp>, for its effect. At this point we have to put <samp class="SANS_Consolas_Regular_11">foo</samp>’s execution on hold until <samp class="SANS_Consolas_Regular_11">bar</samp> will terminate <i>its</i> execution. Now, putting <samp class="SANS_Consolas_Regular_11">foo</samp>’s working stack on hold is not a problem: because the stack grows only in one direction, the working stack of <samp class="SANS_Consolas_Regular_11">bar</samp> will never override previously pushed values. Therefore, saving the working stack of the caller is easy—we get it “for free” thanks to the linear and unidirectional stack structure. But how can we save <samp class="SANS_Consolas_Regular_11">foo</samp>’s memory segments? Recall that in chapter 7 we used the pointers <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, and <samp class="SANS_Consolas_Regular_11">THAT</samp> to refer to the base RAM addresses of the <samp class="SANS_Consolas_Regular_11">local</samp>, <samp class="SANS_Consolas_Regular_11">argument</samp>, <samp class="SANS_Consolas_Regular_11">this</samp>, and <samp class="SANS_Consolas_Regular_11">that</samp> segments of the current function. If we wish to put these segments on hold, we can push their pointers onto the stack and pop them later, when we’ll want to bring <samp class="SANS_Consolas_Regular_11">foo</samp> back to life. In what follows, we use the term <i>frame</i> to refer, collectively, to the set of pointer values needed for saving and reinstating the function’s state.</p>
<p>We see that once we move from a single function setting to a multifunction setting, the humble stack begins to attain a rather formidable role in our story. Specifically, we now use the same data structure to hold both the working stacks as well as the frames of all the functions up the calling chain. To give it the respect that it deserves, from now on we’ll refer to this hard-working data structure as the <i>global stack</i>. See <a href="chapter_8.xhtml#fig8-3" id="rfig8-3">figure 8.3</a> for the details.</p>
<figure class="IMG"><img alt="" id="fig8-3" src="../images/figure_8.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig8-3">Figure 8.3</a></b>    The global stack, shown when the callee is running. Before the callee terminates, it pushes a return value onto the stack (not shown). When the VM implementation handles the <samp class="SANS_Consolas_Regular_11">return</samp> command, it copies the return value onto <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, and sets <samp class="SANS_Consolas_Regular_11">SP</samp> to point to the address just following it. This effectively frees the global stack area below the new value of <samp class="SANS_Consolas_Regular_11">SP</samp>. Thus, when the caller resumes its execution, it sees the return value at the top of its working stack.</p></figcaption>
</figure>
<p>As shown in <a href="chapter_8.xhtml#fig8-3">figure 8.3</a>, when handling the <samp class="SANS_Consolas_Regular_11">call</samp> <i>functionName</i> command, the VM implementation pushes the caller’s frame onto the stack. At the end of this housekeeping, we are ready to jump to executing the callee’s code. This mega jump is not hard to implement. As we’ll see later, when handling a <samp class="SANS_Consolas_Regular_11">function</samp> <i>functionName</i> command, we use the function’s name to create, and inject into the generated assembly code stream, a unique symbolic label that marks where the function starts. Thus, when handling a “<samp class="SANS_Consolas_Regular_11">function</samp> <i>functionName</i>” command, we can generate assembly code that effects a “<samp class="SANS_Consolas_Regular_11">goto</samp> <i>functionName</i>” operation. When executed, this command will effectively transfer control to the callee.</p>
<p>Returning from the callee to the caller when the former terminates is trickier, since the VM <samp class="SANS_Consolas_Regular_11">return</samp> command specifies no return address. Indeed, the caller’s anonymity is inherent in the notion of a function call: functions like <samp class="SANS_Consolas_Regular_11">mult</samp> or <samp class="SANS_Consolas_Regular_11">sqrt</samp> are designed to serve any caller, implying that a return address cannot be specified a priori. Instead, a <samp class="SANS_Consolas_Regular_11">return</samp> command is interpreted as follows: redirect the program’s execution to the memory location holding the command just following the <samp class="SANS_Consolas_Regular_11">call</samp> command that invoked the current function.</p>
<p>The VM implementation can realize this contract by (i) saving the return address just before control is transferred to executing the caller and (ii) retrieving the return address and jumping to it just after the callee returns. But where shall we save the return address? Once again, the resourceful stack comes to the rescue. To remind you, the VM translator advances <span aria-label="155" id="pg_155" role="doc-pagebreak"/>from one VM command to the next, generating assembly code as it goes along. When we encounter a <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">foo</samp> command in the VM code, we know exactly which command should be executed when <samp class="SANS_Consolas_Regular_11">foo</samp> terminates: it’s the assembly command just after the assembly commands that realize the <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">foo</samp> command. Thus, we can have the VM translator plant a label right there, in the generated assembly code stream, and push this label onto the stack. When we later encounter a <samp class="SANS_Consolas_Regular_11">return</samp> command in the VM code, we can pop the previously saved return address off the stack—let’s call it <i>returnAddress</i>—and effect the operation <samp class="SANS_Consolas_Regular_11">goto</samp> <i>returnAddress</i> in assembly. This is the low-level trick that enables the run-time magic of redirecting control back to the right place in the caller’s code.</p>
<p class="STNI1"><b>The VM implementation in action</b>: We now turn to give a step-by-step illustration of how the VM implementation supports the function call-and-return action. We will do it in the context of executing a <samp class="SANS_Consolas_Regular_11">factorial</samp> function, designed to compute <i>n</i>! recursively. <a href="chapter_8.xhtml#fig8-4" id="rfig8-4">Figure 8.4</a> gives the program’s code, along with selected snapshots of the global stack <span aria-label="156" id="pg_156" role="doc-pagebreak"/>during the execution of <samp class="SANS_Consolas_Regular_11">factorial(3)</samp>. A complete run-time simulation of this computation should also include the call-and-return action of the <samp class="SANS_Consolas_Regular_11">mult</samp> function, which, in this particular run-time example, is called twice: once before <samp class="SANS_Consolas_Regular_11">factorial(2)</samp> returns, and once before <samp class="SANS_Consolas_Regular_11">factorial(3)</samp> returns.</p>
<span aria-label="157" id="pg_157" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" height="550" id="fig8-4" src="../images/figure_8.4.png"/>
<figcaption><p class="CAP"><b><a href="#rfig8-4">Figure 8.4</a></b>    Several snapshots of the <i>global stack</i>, taken during the execution of the <samp class="SANS_Consolas_Regular_11">main</samp> function, which calls <samp class="SANS_Consolas_Regular_11">factorial</samp> to compute 3!. The running function sees only its working stack, which is the unshaded area at the tip of the global stack; the other unshaded areas in the global stack are the working stacks of functions up the calling chain, waiting for the currently running function to return. Note that the shaded areas are not “drawn to scale,” since each frame consists of five words, as shown in <a href="chapter_8.xhtml#fig8-3">figure 8.3</a>.</p></figcaption>
</figure>
<p>Focusing on the leftmost and rightmost parts of the bottom of <a href="chapter_8.xhtml#fig8-4">figure 8.4</a>, here is what transpired from <samp class="SANS_Consolas_Regular_11">main</samp>’s perspective: “To set the stage, I pushed the constant 3 onto the stack, and then called <samp class="SANS_Consolas_Regular_11">factorial</samp> for its effect (see the leftmost stack snapshot). At this point I was put to sleep; at some later point in time I was woken up to find out that the stack now contains 6 (see the final and rightmost stack snapshot); I have no idea how this magic happened, and I don’t really care; all I know is that I set out to compute 3!, and I got exactly what I asked for.” In other words, the caller is completely oblivious of the elaborate mini-drama that was unleashed by its <samp class="SANS_Consolas_Regular_11">call</samp> command.</p>
<p>As seen in <a href="chapter_8.xhtml#fig8-4">figure 8.4</a>, the back stage on which this drama plays out is the global stack, and the choreographer who runs the show is the VM implementation: Each <samp class="SANS_Consolas_Regular_11">call</samp> operation is implemented by saving the frame of the caller on the stack and jumping to execute the callee. Each <samp class="SANS_Consolas_Regular_11">return</samp> operation is implemented by (i) using the most recently stored frame for getting the return address within the caller’s code and reinstating its memory segments, (ii) copying the topmost stack value (the return value) onto the stack location associated with <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, and (iii) jumping to execute the caller’s code from the return address onward. All these operations must be realized by generated assembly code.</p>
<p>Some readers may wonder why we have to get into all these details. There are at least three reasons why. First, we need them in order to implement the VM translator. Second, the implementation of the function call-and-return protocol is a beautiful example of low-level software engineering, so we can simply enjoy seeing it in action. Third, an intimate understanding of the virtual machine internals helps us become better and more informed high-level programmers. For example, tinkering with the stack provides an in-depth understanding of the benefits and pitfalls associated with recursion. Note that during run-time, each recursive call causes the VM implementation to add to the stack a memory block consisting of arguments, function frames, local variables, and a working stack for the callee. Therefore, unchecked use of recursion may well lead to the infamous <i>stack overflow</i> run-time debacle. This, as well as efficiency considerations, leads compiler writers to try to reexpress recursive code as sequential code, where possible. But that’s a different story that will be taken up in chapter 11.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>8.4    VM Specification, Part II</b></h2>
<p class="noindent">So far in this chapter, we have presented general VM commands without committing to exact syntax and programming conventions. We now turn to specify formally the VM <i>branching</i> commands, the VM <i>function</i> commands, and the structure of VM <i>programs</i>. This completes the specification of the VM language that we began describing in VM Specification, Part I, in chapter 7.</p>
<p><span aria-label="158" id="pg_158" role="doc-pagebreak"/>It’s important to reiterate that, normally, VM programs are not written by humans. Rather, they are generated by compilers. Therefore, the specifications described here are aimed at compiler developers. That is, if you write a compiler that is supposed to translate programs from some high-level language into VM code, the code that your compiler generates is expected to conform to the conventions described here.</p>
<section epub:type="division">
<h3 class="head b-head"><b>Branching Commands</b></h3>
<ul class="List-1">
<li class="BL1"><samp class="SANS_Consolas_Regular_11">label</samp> <i>label</i>: Labels the current location in the function’s code. Only labeled locations can be jumped to. The scope of the label is the function in which it is defined. The <i>label</i> is a string composed of any sequence of letters, digits, underscore (<samp class="SANS_Consolas_Regular_11">_</samp>), dot (<samp class="SANS_Consolas_Regular_11">.</samp>), and colon (<samp class="SANS_Consolas_Regular_11">:</samp>) that does not begin with a digit. The <samp class="SANS_Consolas_Regular_11">label</samp> command can be located anywhere in the function, before or after the <samp class="SANS_Consolas_Regular_11">goto</samp> commands that refer to it.</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">goto</samp> <i>label</i>: Effects an unconditional goto operation, causing execution to continue from the location marked by the label. The <samp class="SANS_Consolas_Regular_11">goto</samp> command and the labeled jump destination must be located in the same function.</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">if-goto</samp> <i>label</i>: Effects a conditional goto operation. The stack’s topmost value is popped; if the value is not zero, execution continues from the location marked by the label; otherwise, execution continues from the next command in the program. The <samp class="SANS_Consolas_Regular_11">if-goto</samp> command and the labeled jump destination must be located in the same function.</li>
</ul>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>Function Commands</b></h3>
<ul class="List-1">
<li class="BL1"><samp class="SANS_Consolas_Regular_11">function</samp> <i>functionName nVars</i>: Marks the beginning of a function named <i>functionName</i>. The command informs that the function has <i>nVars</i> local variables.</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">call</samp> <i>functionName nArgs</i>: Calls the named function. The command informs that <i>nArgs</i> arguments have been pushed onto the stack before the call.</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">return</samp>: Transfers execution to the command just following the <samp class="SANS_Consolas_Regular_11">call</samp> command in the code of the function that called the current function.</li>
</ul>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>VM Program</b></h3>
<p class="noindent">VM programs are generated from high-level programs written in languages like Jack. As we’ll see in the next chapter, a high-level Jack program is loosely defined as a collection of one or more <samp class="SANS_Consolas_Regular_11">.jack</samp> class files stored in the same folder. When applied to that folder, the Jack compiler translates each class file <i>FileName</i><samp class="SANS_Consolas_Regular_11">.jack</samp> into a corresponding file named <i>FileName</i><samp class="SANS_Consolas_Regular_11">.vm</samp>, containing VM commands.</p>
<p>Following compilation, each <i>constructor</i>, <i>function</i> (<i>static method</i>), and <i>method</i> named <samp class="SANS_Consolas_Regular_11">bar</samp> in a Jack file <i>FileName</i><samp class="SANS_Consolas_Regular_11">.jack</samp> is translated into a corresponding VM function, uniquely identified by the VM function name <i>FileName</i><samp class="SANS_Consolas_Regular_11">.bar</samp>. The scope of VM function names is <span aria-label="159" id="pg_159" role="doc-pagebreak"/>global: all the VM functions in all the <samp class="SANS_Consolas_Regular_11">.vm</samp> files in the program folder see each other and may call each other using the unique and full function name <i>FileName</i><samp class="SANS_Consolas_Regular_11">.</samp><i>functionName</i>.</p>
<p class="STNI1"><b>Program entry point</b>: One file in any Jack program must be named <samp class="SANS_Consolas_Regular_11">Main.jack</samp>, and one function in this file must be named <samp class="SANS_Consolas_Regular_11">main</samp>. Thus, following compilation, one file in any VM program is expected to be named <samp class="SANS_Consolas_Regular_11">Main.vm</samp>, and one VM function in this file is expected to be named <samp class="SANS_Consolas_Regular_11">Main.main</samp>, which is the application’s entry point. This run-time convention is implemented as follows. When we start running a VM program, the first function that always executes is an argument-less VM function named <samp class="SANS_Consolas_Regular_11">Sys.init</samp>, which is part of the operating system. This OS function is programmed to call the entry point function in the user’s program. In the case of Jack programs, <samp class="SANS_Consolas_Regular_11">Sys.init</samp> is programmed to call <samp class="SANS_Consolas_Regular_11">Main.main</samp>.</p>
<p class="STNI1"><b>Program execution</b>: There are several ways to execute VM programs, one of which is using the supplied <i>VM emulator</i> introduced in chapter 7. When you load a program folder containing one or more <samp class="SANS_Consolas_Regular_11">.vm</samp> files into the VM emulator, the emulator loads all the VM functions in all these files, one after the other (the order of the loaded VM functions is insignificant). The resulting code base is a sequence of all the VM functions in all the <samp class="SANS_Consolas_Regular_11">.vm</samp> files in the program folder. The notion of VM files ceases to exist, although it is implicit in the names of the loaded VM functions (<i>FileName</i><samp class="SANS_Consolas_Regular_11">.</samp><i>functionName</i>).</p>
<p>The Nand to Tetris VM emulator, which is a Java program, features a built-in implementation of the Jack OS, also written in Java. When the emulator detects a call to an OS function, for example, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Math.sqrt</samp>, it proceeds as follows. If it finds a corresponding <samp class="SANS_Consolas_Regular_11">function</samp> <samp class="SANS_Consolas_Regular_11">Math.sqrt</samp> command in the loaded VM code, the emulator executes the function’s VM code. Otherwise, the emulator reverts to using its built-in implementation of the <samp class="SANS_Consolas_Regular_11">Math.sqrt</samp> method. This implies that as long as you use the supplied VM emulator for executing VM programs, there is no need to include OS files in your code. The VM emulator will service all the OS calls found in your code, using its built-in OS implementation.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>8.5    Implementation</b></h2>
<p class="noindent">The previous section completed the specification of our VM language and framework. In this section we focus on implementation issues, leading up to the construction of a full-scale, VM-to-Hack translator. Section 8.5.1 proposes how to implement the function call-and-return protocol. Section 8.5.2 completes the standard mapping of the VM implementation over the Hack platform. Section 8.5.3 gives a proposed design and API for completing the VM translator that we began building in project 7.</p>
<section epub:type="division">
<h3 class="head b-head"><b>8.5.1    Function Call and Return</b></h3>
<p class="noindent">The events of calling a function and returning from a function call can be viewed from two perspectives: that of the <i>calling function</i>, also referred to as <i>caller</i>, and that of the <span aria-label="160" id="pg_160" role="doc-pagebreak"/><i>called function</i>, also referred to as <i>callee</i>. Both the caller and the callee have certain expectations, and certain responsibilities, regarding the handling of the <samp class="SANS_Consolas_Regular_11">call</samp>, <samp class="SANS_Consolas_Regular_11">function</samp>, and <samp class="SANS_Consolas_Regular_11">return</samp> commands. Fulfilling the expectations of one is the responsibility of the other. In addition, the VM implementation plays an important role in executing this contract. In what follows, the responsibilities of the VM implementation are marked by [†]:</p>
<figure class="table">
<table class="No-Table-Style">
<thead>
<tr>
<th class="TCH"><p class="TCH">The caller’s view:</p></th>
<th class="TCH"/>
<th class="TCH"><p class="TCH">The callee’s view:</p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TBBL">•  Before calling a function, I must push onto the stack as many arguments (<i>nArgs</i>) as the callee expects to get.</p>
<p class="TBBL">•  Next, I invoke the callee using the command <samp class="SANS_Consolas_Regular_11">call</samp> <i>fileName</i><samp class="SANS_Consolas_Regular_11">.</samp><i>functionName nArgs.</i></p>
<p class="TBBL">•  After the callee returns, the argument values that I pushed before the call have disappeared from the stack, and a <i>return value</i> (that always exists) appears at the top of the stack. Except for this change, my working stack is exactly the same as it was before the call [†].</p>
<p class="TBBL">•  After the callee returns, all my memory segments are exactly the same as they were before the call [†], except that the contents of my <samp class="SANS_Consolas_Regular_11">static</samp> segment may have changed, and the <samp class="SANS_Consolas_Regular_11">temp</samp> segment is undefined.</p></td>
<td class="TBF"/>
<td class="TBF"><p class="TBBL">•  Before I start executing, my <samp class="SANS_Consolas_Regular_11">argument</samp> segment has been initialized with the argument values passed by the caller, and my <samp class="SANS_Consolas_Regular_11">local</samp> variables segment has been allocated and initialized to zeros. My <samp class="SANS_Consolas_Regular_11">static</samp> segment has been set to the static segment of the VM file to which I belong, and my working stack is empty. The memory segments <samp class="SANS_Consolas_Regular_11">this</samp>, <samp class="SANS_Consolas_Regular_11">that</samp>, <samp class="SANS_Consolas_Regular_11">pointer</samp>, and <samp class="SANS_Consolas_Regular_11">temp</samp> are undefined upon entry [†].</p>
<p class="TBBL">•  Before returning, I must push a return value onto the stack.</p></td>
</tr>
</tbody>
</table>
</figure>
<p>The VM implementation supports this contract by maintaining, and manipulating, the global stack structure described in <a href="chapter_8.xhtml#fig8-3">figure 8.3</a>. In particular, every <samp class="SANS_Consolas_Regular_11">function</samp>, <samp class="SANS_Consolas_Regular_11">call</samp>, and <samp class="SANS_Consolas_Regular_11">return</samp> command in the VM code is handled by generating assembly code that manipulates the global stack as follows: A <samp class="SANS_Consolas_Regular_11">call</samp> command generates code that saves the frame of the caller on the stack and jumps to execute the callee. A <samp class="SANS_Consolas_Regular_11">function</samp> command generates code that initializes the local variables of the callee. Finally, a <samp class="SANS_Consolas_Regular_11">return</samp> command generates code that copies the return value to the top of the caller’s working stack, reinstates the segment pointers of the caller, and jumps to execute the latter from the return address onward. See <a href="chapter_8.xhtml#fig8-5" id="rfig8-5">figure 8.5</a> for the details.</p>
<figure class="IMG"><img alt="" id="fig8-5" src="../images/figure_8.5.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig8-5">Figure 8.5</a></b>    Implementation of the function commands of the VM language. All the actions described on the right are realized by generated Hack assembly instructions.</p></figcaption>
</figure>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>8.5.2    Standard VM Mapping on the Hack Platform, Part II</b></h3>
<p class="noindent">Developers of the VM implementation on the Hack computer are advised to follow the conventions described here. These conventions complete the Standard VM Mapping on the Hack Platform, Part I, guidelines given in section 7.4.1.</p>
<p class="STNI1"><b>The stack</b>: On the Hack platform, RAM locations 0 to 15 are reserved for pointers and virtual registers, and RAM locations 16 to 255 are reserved for static variables. The stack <span aria-label="161" id="pg_161" role="doc-pagebreak"/>is mapped on address 256 onward. To realize this mapping, the VM translator should start by generating assembly code that sets <samp class="SANS_Consolas_Regular_11">SP</samp> to 256. From this point onward, when the VM translator encounters commands like <samp class="SANS_Consolas_Regular_11">pop</samp>, <samp class="SANS_Consolas_Regular_11">push</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>, and so on in the source VM code, it generates assembly code that affects these operations by manipulating the address that <samp class="SANS_Consolas_Regular_11">SP</samp> points at, and modifying <samp class="SANS_Consolas_Regular_11">SP</samp>, as needed. These actions were explained in chapter 7 and implemented in project 7.</p>
<p class="STNI1"><b>Special symbols</b>: When translating VM commands into Hack assembly, the VM translator deals with two types of symbols. First, it manages predefined assembly-level symbols like <samp class="SANS_Consolas_Regular_11">SP</samp>, <samp class="SANS_Consolas_Regular_11">LCL</samp>, and <samp class="SANS_Consolas_Regular_11">ARG</samp>. Second, it generates and uses symbolic labels for marking return addresses and function entry points. To illustrate, let us revisit the <samp class="SANS_Consolas_Regular_11">PointDemo</samp> program presented in the introduction to part II. This program consists of two Jack class files, <samp class="SANS_Consolas_Regular_11">Main.jack</samp> (<a href="part_2.xhtml#figII-1">figure II.1</a>) and <samp class="SANS_Consolas_Regular_11">Point.jack</samp> (<a href="part_2.xhtml#figII-2">figure II.2</a>), stored in a folder named <samp class="SANS_Consolas_Regular_11">PointDemo</samp>. When applied to the <samp class="SANS_Consolas_Regular_11">PointDemo</samp> folder, the Jack compiler produces two VM files, named <samp class="SANS_Consolas_Regular_11">Main.vm</samp> and <samp class="SANS_Consolas_Regular_11">Point.vm</samp>. The first file contains a single VM function, <samp class="SANS_Consolas_Regular_11">Main.main</samp>, and the second file contains the VM functions <samp class="SANS_Consolas_Regular_11">Point.new</samp>, <samp class="SANS_Consolas_Regular_11">Point.getx</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">Point.print</samp>.</p>
<p><span aria-label="162" id="pg_162" role="doc-pagebreak"/>When the VM translator is applied to this same folder, it produces a single assembly code file, named <samp class="SANS_Consolas_Regular_11">PointDemo.asm</samp>. At the assembly code level, the function abstractions no longer exist. Instead, for each <samp class="SANS_Consolas_Regular_11">function</samp> command, the VM translator generates an entry label in assembly; for each <samp class="SANS_Consolas_Regular_11">call</samp> command, the VM translator (i) generates an assembly <samp class="SANS_Consolas_Regular_11">goto</samp> instruction, (ii) creates a return address label and pushes it onto the stack, and (iii) injects the label into the generated code. For each <samp class="SANS_Consolas_Regular_11">return</samp> command, the VM translator pops the return address off the stack and generates a <samp class="SANS_Consolas_Regular_11">goto</samp> instruction. For example:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_8.1.png"/></figure>
<p class="TNI1"><a href="chapter_8.xhtml#fig8-6" id="rfig8-6">Figure 8.6</a> specifies all the symbols that the VM translator handles and generates.</p>
<figure class="IMG"><img alt="" id="fig8-6" src="../images/figure_8.6.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig8-6">Figure 8.6</a></b>    The naming conventions described above are designed to support the translation of multiple <samp class="SANS_Consolas_Regular_11">.vm</samp> files and functions into a single <samp class="SANS_Consolas_Regular_11">.asm</samp> file, ensuring that the generated assembly symbols will be unique within the file.</p></figcaption>
</figure>
<p class="STNI1"><b>Bootstrap code</b>: The standard VM mapping on the Hack platform stipulates that the stack be mapped on the host RAM from address 256 onward, and that the first VM function that should start executing is the OS function <samp class="SANS_Consolas_Regular_11">Sys.init</samp>. How can we effect these conventions on the Hack platform? Recall that when we built the Hack computer in chapter 5, we wired it in such a way that upon reset, it will fetch and execute the instruction located in ROM address 0. Thus, if we want the computer to execute a predetermined code segment when it boots up, we can put this code in the Hack computer’s instruction memory, starting at address 0. Here is the code:</p>
<p class="COMF"><samp class="SANS_Consolas_Regular_11">// Bootstrap (pseudo) code, should be expressed in machine language</samp></p>
<p class="COM"><samp class="SANS_Consolas_Regular_11">SP</samp> <span class="symb">=</span> <samp class="SANS_Consolas_Regular_11">256</samp></p>
<p class="COML"><samp class="SANS_Consolas_Regular_11">call Sys.init</samp></p>
<p class="TNI1">The <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function, which is part of the operating system, is then expected to call the main function of the application, and enter an infinite loop. This action will cause the translated VM program to start running. Note that the notions of <i>application</i> and <i>main function</i> vary from one high-level language to another. In the Jack language, the convention is that <samp class="SANS_Consolas_Regular_11">Sys.init</samp> should call the VM function <samp class="SANS_Consolas_Regular_11">Main.main</samp>. This is similar to the Java setting: when we instruct the JVM to execute a given Java class, say, <samp class="SANS_Consolas_Regular_11">Foo</samp>, it looks for, and executes, the <samp class="SANS_Consolas_Regular_11">Foo.main</samp> method. In general, we can effect language-specific startup routines by using different versions of the <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function.</p>
<p class="STNI1"><span aria-label="163" id="pg_163" role="doc-pagebreak"/><b>Usage</b>: The translator accepts a single command-line argument, as follows,</p>
<p class="COM2"><samp class="SANS_Consolas_Regular_11">prompt</samp><span class="symb">&gt;</span> <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> <i>source</i></p>
<p class="TNI1">where <i>source</i> is either a file name of the form <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp> (the extension is mandatory) or the name of a folder (in which case there is no extension) containing one or more <samp class="SANS_Consolas_Regular_11">.vm</samp> files. The file/folder name may contain a file path. If no path is specified, the translator operates on the current folder. The output of the VM translator is a single assembly file, named <i>source</i><samp class="SANS_Consolas_Regular_11">.asm</samp>. <span aria-label="164" id="pg_164" role="doc-pagebreak"/>If <i>source</i> is a folder name, the single <samp class="SANS_Consolas_Regular_11">.asm</samp> file contains the translation of all the functions in all the <samp class="SANS_Consolas_Regular_11">.vm</samp> files in the folder, one after the other. The output file is created in the same folder as the input file. If there is a file by this name in the folder, it will be overwritten.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>8.5.3    Design Suggestions for the VM Implementation</b></h3>
<p class="noindent">In project 7 we proposed building the basic VM translator using three modules: <samp class="SANS_Consolas_Regular_11">VMTranslator</samp>, <samp class="SANS_Consolas_Regular_11">Parser</samp>, and <samp class="SANS_Consolas_Regular_11">CodeWriter</samp>. We now describe how to extend this basic implementation into a full-scale VM translator. This extension can be accomplished by adding the functionality described below to the three modules already built in project 7. There is no need to develop additional modules.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The VMTranslator</b></h3>
<p class="noindent">If the translator’s input is a single file, say <samp class="SANS_Consolas_Regular_11">Prog.vm</samp>, the <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> constructs a <samp class="SANS_Consolas_Regular_11">Parser</samp> for parsing <samp class="SANS_Consolas_Regular_11">Prog.vm</samp> and a <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> that starts by creating an output file named <samp class="SANS_Consolas_Regular_11">Prog.asm</samp>. Next, the <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> enters a loop that uses the <samp class="SANS_Consolas_Regular_11">Parser</samp> services for iterating through the input file and parsing each line as a VM command, barring white space. For each parsed command, the <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> uses the <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> for generating Hack assembly code and emitting the generated code into the output file. All this was already done in project 7.</p>
<p>If the translator’s input is a folder, named, say, <samp class="SANS_Consolas_Regular_11">Prog</samp>, the <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> constructs a <samp class="SANS_Consolas_Regular_11">Parser</samp> for handling each <samp class="SANS_Consolas_Regular_11">.vm</samp> file in the folder, and a single <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> for generating Hack assembly code into the single output file <samp class="SANS_Consolas_Regular_11">Prog.asm</samp>. Each time the <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> starts translating a new <samp class="SANS_Consolas_Regular_11">.vm</samp> file in the folder, it must inform the <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> that a new file is now being processed. This is done by calling a <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> routine named <samp class="SANS_Consolas_Regular_11">setFileName</samp>, as we now turn to describe.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The Parser</b></h3>
<p class="noindent">This module is identical to the <samp class="SANS_Consolas_Regular_11">Parser</samp> developed in project 7.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The CodeWriter</b></h3>
<p class="noindent">The <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> developed in project 7 was designed to handle the VM <i>arithmetic-logical</i> and <i>push</i> / <i>pop</i> commands. Here is the API of a complete <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> that handles all the commands in the VM language:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_8.2.png"/>
</figure>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><span aria-label="165" id="pg_165" role="doc-pagebreak"/><b>8.6    Project</b></h2>
<p class="noindent">In a nutshell, we have to extend the basic translator developed in chapter 7 with the ability to handle multiple <samp class="SANS_Consolas_Regular_11">.vm</samp> files and the ability to translate VM <i>branching</i> commands and VM <i>function</i> commands into Hack assembly code. For each parsed VM command, the VM <span aria-label="166" id="pg_166" role="doc-pagebreak"/>translator has to generate assembly code that implements the command’s semantics on the host Hack platform. The translation of the three <i>branching</i> commands into assembly is not difficult. The translation of the three <i>function</i> commands is more challenging and entails implementing the pseudocode listed in <a href="chapter_8.xhtml#fig8-5">figure 8.5</a>, using the symbols described in <a href="chapter_8.xhtml#fig8-6">figure 8.6</a>. We repeat the suggestion given in the previous chapter: Start by writing the required assembly code on paper. Draw RAM and global stack images, keep track of the stack pointer and the relevant memory segment pointers, and make sure that your paper-based assembly code successfully implements all the low-level actions associated with handling the <samp class="SANS_Consolas_Regular_11">call</samp>, <samp class="SANS_Consolas_Regular_11">function</samp>, and <samp class="SANS_Consolas_Regular_11">return</samp> commands.</p>
<p class="STNI1"><b>Objective</b>: Extend the basic VM translator built in project 7 into a full-scale VM translator, designed to handle multi-file programs written in the VM language.</p>
<p>This version of the VM translator assumes that the source VM code is error-free. Error checking, reporting, and handling can be added to later versions of the VM translator but are not part of project 8.</p>
<p class="STNI1"><b>Contract</b>: Complete the construction of a VM-to-Hack translator, conforming to VM Specification, Part II (section 8.4) and to the Standard VM Mapping on the Hack Platform, Part II (section 8.5.2). Use your translator to translate the supplied VM test programs, yielding corresponding programs written in the Hack assembly language. When executed on the supplied CPU emulator along with the supplied test scripts, the assembly programs generated by your translator should deliver the results mandated by the supplied compare files.</p>
<p class="STNI1"><b>Resources</b>: You will need two tools: the programming language in which you will implement your VM translator and the <i>CPU emulator</i> supplied in the Nand to Tetris software suite. Use the CPU emulator to execute and test the assembly code generated by your translator. If the generated code runs correctly, we will assume that your VM translator performs as expected. This partial test of the translator will suffice for our purposes.</p>
<p>Another tool that comes in handy in this project is the supplied <i>VM emulator</i>. Use this program to execute the supplied test VM programs, and watch how the VM code effects the simulated states of the stack and the virtual memory segments. This can help understand the actions that the VM translator must eventually realize in assembly.</p>
<p>Since the full-scale VM translator is implemented by extending the VM translator built in project 7, you will also need the source code of the latter.</p>
<section epub:type="division">
<h3 class="head b-head"><b>Testing and Implementation Stages</b></h3>
<p class="noindent">We recommend completing the implementation of the VM translator in two stages. First, implement the <i>branching</i> commands, and then the <i>function</i> commands. This will allow you to unit-test your implementation incrementally, using the supplied test programs.</p>
<p class="STNI"><span aria-label="167" id="pg_167" role="doc-pagebreak"/><b>Testing the Handling of the VM Commands</b> <samp class="SANS_Consolas_Bold_B_11">label</samp><samp class="SANS_Consolas_Regular_11">,</samp> <samp class="SANS_Consolas_Bold_B_11">if</samp><samp class="SANS_Consolas_Regular_11">,</samp> <samp class="SANS_Consolas_Bold_B_11">if-goto</samp><samp class="SANS_Consolas_Regular_11">:</samp></p>
<ul class="List-1">
<li class="BL1"><samp class="SANS_Consolas_Regular_11">BasicLoop</samp>: Computes <img alt="" class="inline" height="14" src="../images/8-C6.png" width="167"/> and pushes the result onto the stack. Tests how the VM translator handles the <samp class="SANS_Consolas_Regular_11">label</samp> and <samp class="SANS_Consolas_Regular_11">if-goto</samp> commands.</li>
<li class="BLL"><samp class="SANS_Consolas_Regular_11">FibonacciSeries</samp>: Computes and stores in memory the first <i>n</i> elements of the Fibonacci series. A more rigorous test of handling the <samp class="SANS_Consolas_Regular_11">label</samp>, <samp class="SANS_Consolas_Regular_11">goto</samp>, and <samp class="SANS_Consolas_Regular_11">if-goto</samp> commands.</li>
</ul>
<p class="STNI"><b>Testing the Handling of the VM Commands</b> <samp class="SANS_Consolas_Bold_B_11">call,</samp> <samp class="SANS_Consolas_Bold_B_11">function,</samp> <samp class="SANS_Consolas_Bold_B_11">return:</samp></p>
<p class="TNI1">Unlike what we did in project 7, we now expect the VM translator to handle multi-file programs. We remind the reader that by convention, the first function that starts running in a VM program is <samp class="SANS_Consolas_Regular_11">Sys.init</samp>. Normally, <samp class="SANS_Consolas_Regular_11">Sys.init</samp> is programmed to call the program’s <samp class="SANS_Consolas_Regular_11">Main.main</samp> function. For the purpose of this project, though, we use the supplied <samp class="SANS_Consolas_Regular_11">Sys.init</samp> functions for setting the stage for the various tests that we wish to perform.</p>
<ul class="List-1">
<li class="BLF"><samp class="SANS_Consolas_Regular_11">SimpleFunction</samp>: Performs a simple calculation and returns the result. Tests how the VM translator handles the <samp class="SANS_Consolas_Regular_11">function</samp> and <samp class="SANS_Consolas_Regular_11">return</samp> commands. Since this test entails the handling of a single file consisting of a single function, no <samp class="SANS_Consolas_Regular_11">Sys.init</samp> test function is needed.</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">FibonacciElement</samp>: This test program consists of two files: <samp class="SANS_Consolas_Regular_11">Main.vm</samp> contains a single <samp class="SANS_Consolas_Regular_11">Fibonacci</samp> function that returns recursively the <i>n</i>-th element of the Fibonacci series; <samp class="SANS_Consolas_Regular_11">Sys.vm</samp> contains a single <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function that calls <samp class="SANS_Consolas_Regular_11">Main.fibonacci</samp> with <img alt="" class="inline" height="12" src="../images/8-4.png" width="33"/> and then enters an infinite loop (recall that the VM translator generates bootstrap code that calls <samp class="SANS_Consolas_Regular_11">Sys.init</samp>). The resulting setting provides a rigorous test of the VM translator’s handling of multiple <samp class="SANS_Consolas_Regular_11">.vm</samp> files, the VM function-call-and-return commands, the bootstrap code, and most of the other VM commands. Since the test program consists of two <samp class="SANS_Consolas_Regular_11">.vm</samp> files, the entire folder must be translated, producing a single <samp class="SANS_Consolas_Regular_11">FibonacciElement.asm</samp> file.</li>
<li class="BLL"><samp class="SANS_Consolas_Regular_11">StaticsTest:</samp> This test program consists of three files: <samp class="SANS_Consolas_Regular_11">Class1.vm</samp> and <samp class="SANS_Consolas_Regular_11">Class2.vm</samp> contain functions that set and get the values of several static variables; <samp class="SANS_Consolas_Regular_11">Sys.vm</samp> contains a single <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function that calls these functions<samp class="SANS_Consolas_Regular_11">.</samp> Since the program consists of several <samp class="SANS_Consolas_Regular_11">.vm</samp> files, the entire folder must be translated, producing a single <samp class="SANS_Consolas_Regular_11">StaticsTest.asm</samp> file.</li>
</ul>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>Implementation Tips</b></h3>
<p class="noindent">Since project 8 is based on extending the basic VM translator developed in project 7, we advise making a backup copy of the source code of the latter (if you haven’t done it already).</p>
<p>Start by figuring out the assembly code that is necessary to realize the logic of the VM commands <samp class="SANS_Consolas_Regular_11">label</samp>, <samp class="SANS_Consolas_Regular_11">goto</samp>, and <samp class="SANS_Consolas_Regular_11">if-goto</samp>. Next, proceed to implement the methods <samp class="SANS_Consolas_Regular_11">writeLabel</samp>, <samp class="SANS_Consolas_Regular_11">writeGoto</samp>, and <samp class="SANS_Consolas_Regular_11">writeIf</samp> of the <samp class="SANS_Consolas_Regular_11">CodeWriter</samp>. Test your evolving VM translator by having it translate the supplied <samp class="SANS_Consolas_Regular_11">BasicLoop.vm</samp> and <samp class="SANS_Consolas_Regular_11">FibonacciSeries.vm</samp> programs.</p>
<p><b>Bootstrapping code:</b> In order for any translated VM program to start running, it must include startup code that forces the VM implementation to start executing the program on the host platform. Further, for any VM code to operate properly, the VM implementation <span aria-label="168" id="pg_168" role="doc-pagebreak"/>must store the base addresses of the stack and the virtual segments in the correct locations in the host RAM. The first three test programs in this project (<samp class="SANS_Consolas_Regular_11">BasicLoop</samp>, <samp class="SANS_Consolas_Regular_11">FibonaciiSeries</samp>, <samp class="SANS_Consolas_Regular_11">SimpleFunction</samp>) assume that the startup code was not yet implemented, and include test scripts that effect the necessary initializations <i>manually</i>, meaning that at this development stage you don’t have to worry about it. The last two test programs (<samp class="SANS_Consolas_Regular_11">FibonaciiElement</samp> and <samp class="SANS_Consolas_Regular_11">StaticsTest</samp>) assume that the startup code is already part of the VM implementation.</p>
<p>With that in mind, the constructor of the <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> must be developed in two stages. The first version of your constructor must not generate any bootstrapping code (that is, ignore the constructor’s API guideline beginning with the text “Writes the assembly instructions <span class="ellipsis">…</span>”). Use this version of your translator for unit-testing the programs <samp class="SANS_Consolas_Regular_11">BasicLoop</samp>, <samp class="SANS_Consolas_Regular_11">FibonaciiSeries</samp>, and <samp class="SANS_Consolas_Regular_11">SimpleFunction</samp>. The second and final version of your <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> constructor must write the bootstrapping code, as specified in the constructor’s API. This version should be used for unit-testing <samp class="SANS_Consolas_Regular_11">FibonaciiElement</samp> and <samp class="SANS_Consolas_Regular_11">StaticsTest</samp>.</p>
<p>The supplied test programs were carefully planned to test the specific features of each stage in your VM implementation. We recommend implementing your translator in the proposed order, and testing it using the appropriate test programs at each stage. Implementing a later stage before an early one may cause the test programs to fail.</p>
<p class="STNI1"><b>A web-based version of project 8</b> is available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>8.7    Perspective</b></h2>
<p class="noindent">The notions of <i>branching</i> and <i>function calling</i> are fundamental to all high-level languages. This means that somewhere down the translation path from a high-level language to binary code, someone must take care of handling the intricate housekeeping chores related to their implementation. In Java, C#, Python, and Jack, this burden falls on the virtual machine level. And if the VM architecture is <i>stack-based</i>, it lends itself nicely to the job, as we have seen throughout this chapter.</p>
<p>To appreciate the expressive power of our stack-based VM model, take a second look at the programs presented in this chapter. For example, <a href="chapter_8.xhtml#fig8-1">figures 8.1</a> and <a href="chapter_8.xhtml#fig8-4">8.4</a> present high-level programs and their VM translations. If you do some line counting, you will note that each line of high-level code generates an average of about four lines of compiled VM code. As it turns out, this 1:4 translation ratio is quite consistent when compiling Jack programs into VM code. Even without knowing much about the art of compilation, one can appreciate the brevity and readability of the VM code generated by the compiler. For example, as we will see when we build the compiler, a high-level statement like <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/8-C7.png" width="120"/> is translated into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">x</samp>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Math.sqrt</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">y</samp>. The two-tier compiler can get away with so little work since it counts on the VM implementation for handling the rest of the translation. If we had to translate high-level statements like <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/8-C8.png" width="120"/> directly into Hack code, <span aria-label="169" id="pg_169" role="doc-pagebreak"/>without having the benefit of an intermediate VM layer, the resulting code would be far less elegant, and more cryptic.</p>
<p>That said, it would also be more efficient. Let us not forget that the VM code must be realized in machine language—that’s what projects 7 and 8 are all about. Typically, the final machine code resulting from a two-tier translation process is longer and less efficient than that generated from direct translation. So, which is more desirable: a two-tier Java program that eventually generates one thousand machine instructions or an equivalent one-tier C<span class="symb">++</span> program that generates seven hundred instructions? The pragmatic answer is that each programming language has its pros and cons, and each application has different operational requirements.</p>
<p>One of the great virtues of the two-tier model is that the intermediate VM code (e.g., Java’s bytecode) can be <i>managed</i>, for example, by programs that test whether it contains malicious code, programs that monitor the code for business process modeling, and so on. In general, for most applications, the benefits of managed code justify the performance degradation caused by the VM level. Yet for high-performance programs like operating systems and embedded applications, the need to generate tight and efficient code typically mandates using C/C<span class="symb">++</span>, compiled directly to machine language.</p>
<p>For compiler writers, an obvious advantage of using an explicit interim VM language is that it simplifies the tasks of writing and maintaining compilers. For example, the VM implementation developed in this chapter frees the compiler from the significant tasks of handling the low-level implementation of the function call-and-return protocol. In general, the intermediate VM layer decouples the daunting challenge of building a high-level-to-low-level compiler into two far simpler challenges: building a high-level-to-VM compiler and building a VM-to-low-level translator. Since the latter translator, also called the compiler’s <i>back end</i>, was already developed in projects 7 and 8, we can be content that about half of the overall compilation challenge has already been accomplished. The other half—developing the compiler’s <i>front end</i>—will be taken up in chapters 10 and 11.</p>
<p>We end this chapter with a general observation about the virtue of separating abstraction from implementation—an ongoing theme in Nand to Tetris and a crucial systems-building principle that goes far beyond the context of program compilation. Recall that VM functions can access their memory segments using commands like <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, and so on while having no idea <i>how</i> these values are represented, saved, and reinstated during run-time. The VM implementation takes care of all the gory details. This complete separation of abstraction and implementation implies that developers of compilers that generate VM code don’t have to worry about how the code they generate will end up running; they have enough problems of their own, as you will soon realize.</p>
<p>So cheer up! You are halfway through writing a two-tier compiler for a high-level, object-based, Java-like programming language. The next chapter is devoted to describing this language. This will set the stage for chapters 10 and 11, in which we’ll complete the compiler’s development. We begin seeing Tetris bricks falling at the end of the tunnel.</p>
</section>
</section>
</div>
</body>
</html>