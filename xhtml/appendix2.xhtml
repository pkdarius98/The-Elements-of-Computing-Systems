<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>2 Hardware Description Language</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body epub:type="backmatter">
<div class="body">
<p class="sp"> </p>
<section epub:type="appendix" role="doc-appendix">
<header>
<h1 class="BMH"><span aria-label="283" id="pg_283" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">Appendix 2: Hardware Description Language</samp></h1>
</header>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP1">Intelligence is the faculty of making artificial objects, especially tools to make tools.</p>
<p class="EPA2">—Henry Bergson (1859–1941)</p>
</blockquote>
<p class="noindent">This appendix has two main parts. Sections A2.1–A2.5 describe the HDL language used in the book and in the projects. Section A2.6, named HDL Survival Guide, provides a set of essential tips for completing the hardware projects successfully.</p>
<p>A Hardware Description Language (HDL) is a formalism for defining <i>chips</i>: objects whose <i>interfaces</i> consist of input and output <i>pins</i> that carry binary signals, and whose <i>implementations</i> are connected arrangements of other, lower-level chips. This appendix describes the HDL that we use in Nand to Tetris. Chapter 1 (in particular, section 1.3) provides essential background that is a prerequisite to this appendix.</p>
<section epub:type="division">
<h2 class="head a-head"><b>A2.1    HDL Basics</b></h2>
<p class="noindent">The HDL used in Nand to Tetris is a simple language, and the best way to learn it is to play with HDL programs using the supplied hardware simulator. We recommend starting to experiment as soon as you can, beginning with the following example.</p>
<p class="STNI1"><b>Example</b>: Suppose we have to check whether three 1-bit variables <i>a</i>, <i>b</i>, <i>c</i> have the same value. One way to check this three-way equality is to evaluate the Boolean function <img alt="" class="inline" height="14" src="../images/App02_IEQ_001.png" width="127"/>. Noting that the binary operator <i>not-equal</i> can be realized using a Xor gate, we can implement this function using the HDL program shown in <a href="appendix2.xhtml#figA2-1" id="rfigA2-1">figure A2.1</a>.</p>
<figure class="IMG"><img alt="" id="figA2-1" src="../images/figure_A2.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA2-1">Figure A2.1</a></b>    HDL program example.</p></figcaption>
</figure>
<p>The <samp class="SANS_Consolas_Regular_11">Eq3.hdl</samp> implementation uses four <i>chip-parts</i>: two <samp class="SANS_Consolas_Regular_11">Xor</samp> gates, one <samp class="SANS_Consolas_Regular_11">Or</samp> gate, and one <samp class="SANS_Consolas_Regular_11">Not</samp> gate. To realize the logic expressed by <img alt="" class="inline" height="14" src="../images/App02_IEQ_002.png" width="127"/>, the HDL programmer connects the chip-parts by creating, and naming, three <i>internal pins</i>: <samp class="SANS_Consolas_Regular_11">neq1</samp>, <samp class="SANS_Consolas_Regular_11">neq2</samp>, and <samp class="SANS_Consolas_Regular_11">outOr</samp>.</p>
<p><span aria-label="284" id="pg_284" role="doc-pagebreak"/>Unlike internal pins, which can be created and named at will, the HDL programmer has no control over the names of the input and output pins. These are normally supplied by the chips’ architects and documented in given APIs. For example, in Nand to Tetris, we provide <i>stub files</i> for all the chips that you have to implement. Each stub file contains the chip interface, with a missing implementation. The contract is as follows: You are allowed to do whatever you want <i>under</i> the <samp class="SANS_Consolas_Regular_11">PARTS</samp> statement; you are not allowed to change anything <i>above</i> the <samp class="SANS_Consolas_Regular_11">PARTS</samp> statement.</p>
<p>In the <samp class="SANS_Consolas_Regular_11">Eq3</samp> example, it so happens that the first two inputs of the <samp class="SANS_Consolas_Regular_11">Eq3</samp> chip and the two inputs of the <samp class="SANS_Consolas_Regular_11">Xor</samp> and <samp class="SANS_Consolas_Regular_11">Or</samp> chip-parts have the same names (<samp class="SANS_Consolas_Regular_11">a</samp> and <samp class="SANS_Consolas_Regular_11">b</samp>). Likewise, the output of the <samp class="SANS_Consolas_Regular_11">Eq3</samp> chip and that of the <samp class="SANS_Consolas_Regular_11">Not</samp> chip-part happen to have the same name (<samp class="SANS_Consolas_Regular_11">out</samp>). This leads to bindings like <img alt="" class="inline" height="13" src="../images/A2-C1.png" width="58"/> and <img alt="" class="inline" height="10" src="../images/A2-C2.png" width="60"/> Such bindings may look peculiar, but they occur frequently in HDL programs, and one gets used to them. Later in the appendix we’ll give a simple rule that clarifies the meaning of these bindings.</p>
<p>Importantly, the programmer need not worry about how chip-parts are implemented. The chip-parts are used like black box abstractions, allowing the programmer to focus only on how to arrange them judiciously in order to realize the chip function. Thanks to this modularity, HDL programs can be kept short, readable, and amenable to unit testing.</p>
<p>HDL-based chips like <samp class="SANS_Consolas_Regular_11">Eq3.hdl</samp> can be tested by a computer program called <i>hardware simulator</i>. When we instruct the simulator to evaluate a given chip, the simulator evaluates all the chip-parts specified in its <samp class="SANS_Consolas_Regular_11">PARTS</samp> section. This, in turn, requires evaluating <i>their</i> lower-level chip-parts, and so on. This recursive descent can result in a huge hierarchy of downward-expanding chip-parts, all the way down to the terminal Nand gates from which all chips are made. This expensive drill-down can be averted using <i>built-in chips</i>, as we’ll explain shortly.</p>
<p class="STNI1"><b>HDL is a declarative language</b>: HDL programs can be viewed as textual specifications of chip diagrams. For each chip <i>chipName</i> that appears in the diagram, the programmer writes a <i>chipName</i> <samp class="SANS_Consolas_Regular_11">(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">)</samp> statement in the HDL program’s <samp class="SANS_Consolas_Regular_11">PARTS</samp> section. Since the lan<span aria-label="285" id="pg_285" role="doc-pagebreak"/>guage is designed to describe <i>connections</i> rather than <i>processes</i>, the order of the <samp class="SANS_Consolas_Regular_11">PARTS</samp> statements is insignificant: as long as the chip-parts are connected correctly, the chip will function as stated. The fact that HDL statements can be reordered without affecting the chip’s behavior may look odd to readers who are used to conventional programming. Remember: HDL is not a programming language; it’s a specification language.</p>
<p class="STNI1"><b>White space, comments, case conventions</b>: HDL is case-sensitive: <samp class="SANS_Consolas_Regular_11">foo</samp> and <samp class="SANS_Consolas_Regular_11">Foo</samp> represent two different things. HDL keywords are written in uppercase letters. Space characters, newline characters, and comments are ignored. The following comment formats are supported:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.1.png"/></figure>
<p class="noindent"><b>Pins</b>: HDL programs feature three types of <i>pins</i>: input pins, output pins, and internal pins. The latter pins serve to connect outputs of chip-parts to inputs of other chip-parts. Pins are assumed by default to be single-bit, carrying <samp class="SANS_Consolas_Regular_11">0</samp> or <samp class="SANS_Consolas_Regular_11">1</samp> values. Multi-bit <i>bus</i> pins can also be declared and used, as described later in this appendix.</p>
<p class="STNI1"><b>Names</b> of chips and pins may be any sequence of letters and digits not starting with a digit (some hardware simulators disallow using hyphens). By convention, chip and pin names start with a capital letter and a lowercase letter, respectively. For readability, names can include uppercase letters, for example, <samp class="SANS_Consolas_Regular_11">xorResult</samp>. HDL programs are stored in <samp class="SANS_Consolas_Regular_11">.hdl</samp> files. The name of the chip declared in the HDL statement <samp class="SANS_Consolas_Regular_11">CHIP</samp> <i>Xxx</i> must be identical to the prefix of the file name <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.hdl</samp>.</p>
<p class="STNI1"><b>Program structure</b>: An HDL program consists of an <i>interface</i> and an <i>implementation</i>. The interface consists of the chip’s API documentation, chip name, and names of its input and output pins. The implementation consists of the statements below the <samp class="SANS_Consolas_Regular_11">PARTS</samp> keyword. The overall program structure is as follows:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.2.png"/></figure>
<p class="noindent"><b>Parts</b>: The chip implementation is an unordered sequence of chip-part statements, as follows:<span aria-label="286" id="pg_286" role="doc-pagebreak"/></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.3.png"/></figure>
<p class="TNI1">Each <i>connection</i> is specified using the binding <img alt="" class="inline" height="15" src="../images/A2-1.png" width="80"/> where <i>pin</i>1 and <i>pin</i>2 are input, output, or internal pin names. These connections can be visualized as “wires” that the HDL programmer creates and names, as needed. For each “wire” connecting <i>chipPart</i>1 and <i>chipPart</i>2 there is an internal pin that appears twice in the HDL program: once as a <i>sink</i> in some <i>chipPart</i>1<samp class="SANS_Consolas_Regular_11">(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">)</samp> statement, and once as a <i>source</i> in some other <i>chipPart</i>2 <samp class="SANS_Consolas_Regular_11">(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">)</samp> statement. For example, consider the following statements:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.4.png"/></figure>
<p class="TNI1">Pins have fan-in 1 and unlimited fan-out. This means that a pin can be fed from a single source only, yet it can feed (through multiple connections) one or more pins in one or more chip-parts. In the above example, the internal pin <samp class="SANS_Consolas_Regular_11">v</samp> simultaneously feeds three inputs. This is the HDL equivalent of <i>forks</i> in chip diagrams.</p>
<p class="STNI1"><b>The meaning of a</b> <span class="symb-b">=</span> <b>a</b>: Many chips in the Hack platform use the same pin names. As shown in <a href="appendix2.xhtml#figA2-1">figure A2.1</a>, this leads to statements like <samp class="SANS_Consolas_Regular_11">Xor</samp> <img alt="" class="inline" height="14" src="../images/A2-C3.png" width="141"/> The first two connections feed the <samp class="SANS_Consolas_Regular_11">a</samp> and <samp class="SANS_Consolas_Regular_11">b</samp> inputs of the implemented chip (<samp class="SANS_Consolas_Regular_11">Eq3</samp>) into the <samp class="SANS_Consolas_Regular_11">a</samp> and <samp class="SANS_Consolas_Regular_11">b</samp> inputs of the <samp class="SANS_Consolas_Regular_11">Xor</samp> chip-part. The third connection feeds the <samp class="SANS_Consolas_Regular_11">out</samp> output of the <samp class="SANS_Consolas_Regular_11">Xor</samp> chip-part to the internal pin <samp class="SANS_Consolas_Regular_11">neq1</samp>. Here is a simple rule that helps sort things out: In every chip-part statement, the left side of each <span class="code_eq-symb">=</span> binding always denotes an input or output pin <i>of the chip-part</i>, and the right side always denotes an input, output, or internal pin <i>of the implemented chip</i>.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>A2.2    Multi-Bit Buses</b></h2>
<p class="noindent">Each input, output, or internal pin in an HDL program may be either a single-bit value, which is the default, or a multi-bit value, referred to as a <i>bus</i>.</p>
<p class="STNI1"><b>Bit numbering and bus syntax</b>: Bits are numbered from right to left, starting with 0. For example, <samp class="SANS_Consolas_Regular_11">sel</samp><span class="code_eq-symb">=</span><samp class="SANS_Consolas_Regular_11">110</samp>, implies that <samp class="SANS_Consolas_Regular_11">sel[2]</samp><span class="code_eq-symb">=</span><samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">sel[1]</samp><span class="code_eq-symb">=</span><samp class="SANS_Consolas_Regular_11">1</samp>, and <samp class="SANS_Consolas_Regular_11">sel[0]</samp><span class="code_eq-symb">=</span><samp class="SANS_Consolas_Regular_11">0</samp>.</p>
<p class="STNI1"><b>Input and output bus pins</b>: The bit widths of these pins are specified when they are declared in the chip’s <samp class="SANS_Consolas_Regular_11">IN</samp> and <samp class="SANS_Consolas_Regular_11">OUT</samp> statements. The syntax is <samp class="SANS_Consolas_Regular_11">x[</samp><i>n</i><samp class="SANS_Consolas_Regular_11">]</samp>, where <samp class="SANS_Consolas_Regular_11">x</samp> and <i>n</i> declare the pin’s name and bit width, respectively.</p>
<p class="STNI1"><span aria-label="287" id="pg_287" role="doc-pagebreak"/><b>Internal bus pins</b>: The bit widths of internal pins are deduced implicitly from the bindings in which they are declared, as follows,</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.5.png"/></figure>
<p class="TNI1">where <samp class="SANS_Consolas_Regular_11">x</samp> is an input or output pin of the chip-part. The first binding defines <samp class="SANS_Consolas_Regular_11">u</samp> to be a single-bit internal pin and sets its value to <samp class="SANS_Consolas_Regular_11">x[</samp><i>i</i><samp class="SANS_Consolas_Regular_11">]</samp>. The second binding defines <samp class="SANS_Consolas_Regular_11">v</samp> to be an internal bus-pin of width <img alt="" class="inline" height="15" src="../images/A2-2.png" width="50"/> bits and sets its value to the bits indexed <i>i</i> to <i>j</i> (inclusive) of bus-pin <samp class="SANS_Consolas_Regular_11">x</samp>.</p>
<p>Unlike input and output pins, internal pins (like <samp class="SANS_Consolas_Regular_11">u</samp> and <samp class="SANS_Consolas_Regular_11">v</samp>) may not be subscripted. For example, <samp class="SANS_Consolas_Regular_11">u[</samp><i>i</i><samp class="SANS_Consolas_Regular_11">]</samp> is not allowed.</p>
<p class="STNI1"><b>True/false buses</b>: The constants <samp class="SANS_Consolas_Regular_11">true</samp> (<samp class="SANS_Consolas_Regular_11">1</samp>) and <samp class="SANS_Consolas_Regular_11">false</samp> (<samp class="SANS_Consolas_Regular_11">0</samp>) may also be used to define buses. For example, suppose that <samp class="SANS_Consolas_Regular_11">x</samp> is an 8-bit bus-pin, and consider this statement:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.6.png"/></figure>
<p class="TNI1">This statement sets <samp class="SANS_Consolas_Regular_11">x</samp> to the value <samp class="SANS_Consolas_Regular_11">11000111</samp>. Note that unaffected bits are set by default to <samp class="SANS_Consolas_Regular_11">false</samp> (<samp class="SANS_Consolas_Regular_11">0</samp>). <a href="appendix2.xhtml#figA2-2" id="rfigA2-2">Figure A2.2</a> gives another example.</p>
<figure class="IMG"><img alt="" id="figA2-2" src="../images/figure_A2.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA2-2">Figure A2.2</a></b>    Buses in action (example).</p></figcaption>
</figure>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>A2.3    Built-In Chips</b></h2>
<p class="noindent">Chips can have either a <i>native</i> implementation, written in HDL, or a <i>built-in</i> implementation, supplied by an executable module written in a high-level programming language. Since <span aria-label="288" id="pg_288" role="doc-pagebreak"/>the Nand to Tetris hardware simulator was written in Java, it was convenient to realize the built-in chips as Java classes. Thus, before building, say, a <samp class="SANS_Consolas_Regular_11">Mux</samp> chip in HDL, the user can load a built-in <samp class="SANS_Consolas_Regular_11">Mux</samp> chip into the hardware simulator and experiment with it. The behavior of the built-in <samp class="SANS_Consolas_Regular_11">Mux</samp> chip is supplied by a Java class file named <samp class="SANS_Consolas_Regular_11">Mux.class</samp>, which is part of the simulator’s software.</p>
<p>The Hack computer is made from about thirty generic chips, listed in appendix 4. Two of these chips, <samp class="SANS_Consolas_Regular_11">Nand</samp> and <samp class="SANS_Consolas_Regular_11">DFF</samp>, are considered <i>given</i>, or <i>primitive</i>, akin to axioms in logic. The hardware simulator realizes given chips by invoking their built-in implementations. Therefore, in Nand to Tetris, <samp class="SANS_Consolas_Regular_11">Nand</samp> and <samp class="SANS_Consolas_Regular_11">DFF</samp> can be used without building them in HDL.</p>
<p>Projects 1, 2, 3, and 5 evolve around building HDL implementations of the remaining chips listed in appendix 4. All these chips, except for the <samp class="SANS_Consolas_Regular_11">CPU</samp> and <samp class="SANS_Consolas_Regular_11">Computer</samp> chips, also have built-in implementations. This was done in order to facilitate behavioral simulation, as explained in chapter 1.</p>
<p>The built-in chips—a library of about thirty <i>chipName</i><samp class="SANS_Consolas_Regular_11">.class</samp> files—are supplied in the <samp class="SANS_Consolas_Regular_11">nand2tetris/tools/builtInChips</samp> folder in your computer. Built-in chips have HDL interfaces identical to those of regular HDL chips. Therefore, each <samp class="SANS_Consolas_Regular_11">.class</samp> file is accompanied by a corresponding <samp class="SANS_Consolas_Regular_11">.hdl</samp> file that provides the built-in chip interface. <a href="appendix2.xhtml#figA2-3" id="rfigA2-3">Figure A2.3</a> shows a typical HDL definition of a built-in chip.</p>
<figure class="IMG"><img alt="" id="figA2-3" src="../images/figure_A2.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA2-3">Figure A2.3</a></b>    Built-in chip definition example.</p></figcaption>
</figure>
<p>It’s important to remember that the supplied hardware simulator is a general-purpose tool, whereas the Hack computer built in Nand to Tetris is a specific hardware platform. The hardware simulator can be used for building gates, chips, and platforms that have nothing to do with Hack. Therefore, when discussing the notion of built-in chips, it helps to broaden our perspective and describe their general utility for supporting any possible hardware construction project. In general, then, built-in chips provide the following services:</p>
<p class="STNI1"><b>Foundation</b>: Built-in chips can provide supplied implementations of chips that are considered <i>given</i>, or <i>primitive</i>. For example, in the Hack computer, <samp class="SANS_Consolas_Regular_11">Nand</samp> and <samp class="SANS_Consolas_Regular_11">DFF</samp> are given.</p>
<p class="STNI1"><b>Efficiency</b>: Some chips, like RAM units, consist of numerous lower-level chips. When we use such chips as chip-parts, the hardware simulator has to evaluate them. This is done by evaluating, recursively, all the lower-level chips from which they are made. This results in <span aria-label="289" id="pg_289" role="doc-pagebreak"/>slow and inefficient simulation. The use of built-in chip-parts instead of regular, HDL-based chips speeds up the simulation considerably.</p>
<p class="STNI1"><b>Unit testing</b>: HDL programs use chip-parts abstractly, without paying attention to their implementation. Therefore, when building a new chip, it is always recommended to use built-in chip-parts. This practice improves efficiency and minimizes errors.</p>
<p class="STNI1"><b>Visualization</b>: If the designer wants to allow users to “see” how chips work, and perhaps change the internal state of the simulated chip interactively, he or she can supply a built-in chip implementation that features a graphical user interface. This GUI will be displayed whenever the built-in chip is loaded into the simulator or invoked as a chip-part. Except for these visual side effects, GUI-empowered chips behave, and can be used, just like any other chip. Section A2.5 provides more details about GUI-empowered chips.</p>
<p class="STNI1"><b>Extension</b>: If you wish to implement a new input/output device or create a new hardware platform altogether (other than Hack), you can support these constructions with built-in chips. For more information about developing additional or new functionality, see chapter 13.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>A2.4    Sequential Chips</b></h2>
<p class="noindent">Chips can be either <i>combinational</i> or <i>sequential</i>. Combinational chips are time independent: they respond to changes in their inputs instantaneously. Sequential chips are time dependent, also called <i>clocked</i>: when a user or a test script changes the inputs of a sequential chip, the chip outputs may change only at the beginning of the next <i>time unit</i>, also called a <i>cycle</i>. The hardware simulator effects the progression of time using a simulated clock.</p>
<p class="STNI1"><b>The clock</b>: The simulator’s two-phase clock emits an infinite sequence of values denoted <img alt="" class="inline" height="13" src="../images/A2-C4.png" width="157"/> and so on. The progression of this discrete time series is controlled by two simulator commands called <samp class="SANS_Consolas_Regular_11">tick</samp> and <samp class="SANS_Consolas_Regular_11">tock</samp>. A <samp class="SANS_Consolas_Regular_11">tick</samp> moves the clock value from <i>t</i> to <img alt="" class="inline" height="10" src="../images/A2-4.png" width="15"/>, and a <samp class="SANS_Consolas_Regular_11">tock</samp> from <img alt="" class="inline" height="10" src="../images/A2-4.png" width="15"/> to <img alt="" class="inline" height="14" src="../images/A2-3.png" width="32"/> bringing upon the next time unit. The <i>real time</i> that elapsed during this period is irrelevant for simulation purposes, since the simulated time is controlled by the user, or by a test script, as follows.</p>
<p>First, whenever a sequential chip is loaded into the simulator, the GUI enables a clock-shaped button (dimmed when simulating combinational chips). One click on this button (a <samp class="SANS_Consolas_Regular_11">tick</samp>) ends the first phase of the clock cycle, and a subsequent click (a <samp class="SANS_Consolas_Regular_11">tock</samp>) ends the second phase of the cycle, bringing on the first phase of the next cycle, and so on.</p>
<p>Alternatively, one can run the clock from a test script. For example, the sequence of scripting commands <samp class="SANS_Consolas_Regular_11">repeat</samp> <i>n</i> <samp class="SANS_Consolas_Regular_11">{tick,</samp> <samp class="SANS_Consolas_Regular_11">tock,</samp> <samp class="SANS_Consolas_Regular_11">output}</samp> instructs the simulator to advance <span aria-label="290" id="pg_290" role="doc-pagebreak"/>the clock <i>n</i> time units and to print some values in the process. Appendix 3 documents the <i>Test Description Language</i> (TDL) that features these commands.</p>
<p>The two-phased time units generated by the clock regulate the operations of all the sequential chip-parts in the implemented chip. During the first phase of the time unit (<samp class="SANS_Consolas_Regular_11">tick</samp>), the inputs of each sequential chip-part affect the chip’s internal state, according to the chip logic. During the second phase of the time unit (<samp class="SANS_Consolas_Regular_11">tock</samp>), the chip outputs are set to the new values. Hence, if we look at a sequential chip “from the outside,” we see that its output pins stabilize to new values only at <samp class="SANS_Consolas_Regular_11">tock</samp>—at the point of transition between two consecutive time units.</p>
<p>We reiterate that combinational chips are completely oblivious to the clock. In Nand to Tetris, all the logic gates and chips built in chapters 1–2, up to and including the ALU, are combinational. All the registers and memory units built in chapter 3 are sequential. By default, chips are combinational; a chip can become <i>sequential</i> explicitly or implicitly, as follows.</p>
<p class="STNI1"><b>Sequential, built-in chips</b>: A <i>built-in chip</i> can declare its dependence on the clock explicitly, using the statement,</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.7.png"/></figure>
<p class="TNI1">where each <i>pin</i> is one of the chip’s input or output pins. The inclusion of an input pin <i>x</i> in the <samp class="SANS_Consolas_Regular_11">CLOCKED</samp> list stipulates that changes to <i>x</i> should affect the chip’s outputs only at the beginning of the next time unit. The inclusion of an output pin <i>x</i> in the <samp class="SANS_Consolas_Regular_11">CLOCKED</samp> list stipulates that changes in any of the chip’s inputs should affect <i>x</i> only at the beginning of the next time unit. <a href="appendix2.xhtml#figA2-4" id="rfigA2-4">Figure A2.4</a> presents the definition of the most basic, built-in, sequential chip in the Hack platform—the <samp class="SANS_Consolas_Regular_11">DFF</samp>.</p>
<figure class="IMG"><img alt="" id="figA2-4" src="../images/figure_A2.4.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA2-4">Figure A2.4</a></b>    <samp class="SANS_Consolas_Regular_11">DFF</samp> definition.</p></figcaption>
</figure>
<p>It is possible that only some of the input or output pins of a chip are declared as clocked. In that case, changes in the non-clocked input pins affect the non-clocked output pins instantaneously. That’s how the <samp class="SANS_Consolas_Regular_11">address</samp> pins are implemented in <samp class="SANS_Consolas_Regular_11-SC">RAM</samp> units: the addressing logic is combinational and independent of the clock.</p>
<p><span aria-label="291" id="pg_291" role="doc-pagebreak"/>It is also possible to declare the <samp class="SANS_Consolas_Regular_11">CLOCKED</samp> keyword with an empty list of pins. This statement stipulates that the chip may change its internal state depending on the clock, but its input-output behavior will be combinational, independent of the clock.</p>
<p class="STNI1"><b>Sequential, composite chips</b>: The <samp class="SANS_Consolas_Regular_11">CLOCKED</samp> property can be defined explicitly only in built-in chips. How, then, does the simulator know that a given chip-part is sequential? If the chip is not built-in, then it is said to be clocked when one or more of its chip-parts is clocked. The clocked property is checked recursively, all the way down the chip hierarchy, where a built-in chip may be explicitly clocked. If such a chip is found, it renders every chip that depends on it (up the hierarchy) “clocked.” Therefore, in the Hack computer, all the chips that include one or more <samp class="SANS_Consolas_Regular_11">DFF</samp> chip-parts, either directly or indirectly, are clocked.</p>
<p>We see that if a chip is not built-in, there is no way to tell from its HDL code whether it is sequential or not. <i>Best-practice advice</i>: The chip architect should provide this information in the chip API documentation.</p>
<p class="STNI1"><b>Feedback loops</b>: If the input of a chip feeds from one of the chip’s outputs, either directly or through a (possibly long) path of dependencies, we say that the chip contains a <i>feedback loop</i>. For example, consider the following two chip-part statements:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.8.png"/></figure>
<p class="TNI1">In both examples, an internal pin (<samp class="SANS_Consolas_Regular_11">loop1</samp> or <samp class="SANS_Consolas_Regular_11">loop2</samp>) attempts to feed the chip’s input from its output, creating a feedback loop. The difference between the two examples is that <samp class="SANS_Consolas_Regular_11">Not</samp> is a combinational chip, whereas <samp class="SANS_Consolas_Regular_11">DFF</samp> is sequential. In the <samp class="SANS_Consolas_Regular_11">Not</samp> example, <samp class="SANS_Consolas_Regular_11">loop1</samp> creates an instantaneous and uncontrolled dependency between <samp class="SANS_Consolas_Regular_11">in</samp> and <samp class="SANS_Consolas_Regular_11">out</samp>, sometimes called a <i>data race</i>. In contrast, in the <samp class="SANS_Consolas_Regular_11">DFF</samp> case, the <samp class="SANS_Consolas_Regular_11">in</samp>-<samp class="SANS_Consolas_Regular_11">out</samp> dependency created by <samp class="SANS_Consolas_Regular_11">loop2</samp> is delayed by the clock, since the <samp class="SANS_Consolas_Regular_11">in</samp> input of the <samp class="SANS_Consolas_Regular_11">DFF</samp> is declared clocked. Therefore, <samp class="SANS_Consolas_Regular_11">out(</samp><i>t</i><samp class="SANS_Consolas_Regular_11">)</samp> is not a function of <samp class="SANS_Consolas_Regular_11">in(</samp><i>t</i><samp class="SANS_Consolas_Regular_11">)</samp> but rather of <samp class="SANS_Consolas_Regular_11">in(</samp><i>t</i> - 1<samp class="SANS_Consolas_Regular_11">)</samp>.</p>
<p>When the simulator evaluates a chip, it checks recursively whether its various connections entail feedback loops. For each loop, the simulator checks whether the loop goes through a clocked pin somewhere along the way. If so, the loop is allowed. Otherwise, the simulator stops processing and issues an error message. This is done to prevent uncontrolled data races.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>A2.5    Visualizing Chips</b></h2>
<p class="noindent">Built-in chips may be <i>GUI empowered</i>. These chips feature visual side effects designed to animate some of the chip operations. When the simulator evaluates a GUI-empowered chip-part, it displays a graphical image on the screen. Using this image, which may include interactive elements, the user can inspect the chip’s current state or change it. The permissible <span aria-label="292" id="pg_292" role="doc-pagebreak"/>GUI-empowered actions are determined, and made possible, by the developer of the built-in chip implementation.</p>
<p>The present version of the hardware simulator features the following GUI-empowered, built-in chips:</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">ALU</samp>: Displays the Hack ALU’s inputs, output, and the presently computed function.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Registers</samp> <b>(ARegister,</b> <samp class="SANS_Consolas_Bold_B_11">DRegister,</samp> <samp class="SANS_Consolas_Bold_B_11">PC)</samp>: Displays the register’s contents, which may be modified by the user.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">RAM</samp> <b>chips</b>: Displays a scrollable, array-like image that shows the contents of all the memory locations, which may be modified by the user. If the contents of a memory location change during the simulation, the respective entry in the GUI changes as well.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">ROM</samp> <b>chip (ROM32K)</b>: Same array-like image as that of RAM chips, plus an icon that enables loading a machine language program from an external text file. (The <samp class="SANS_Consolas_Regular_11">ROM32K</samp> chip serves as the instruction memory of the Hack computer.)</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Screen</samp> <b>chip</b>: Displays a 256-rows-by-512-columns window that simulates the physical screen. If, during a simulation, one or more bits in the RAM-resident <i>screen memory map</i> change, the respective pixels in the screen GUI change as well. This continuous refresh loop is embedded in the simulator implementation.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Keyboard</samp> <b>chip</b>: Displays a keyboard icon. Clicking this icon connects the real keyboard of your computer to the simulated chip. From this point on, every key pressed on the real keyboard is intercepted by the simulated chip, and its binary code appears in the RAM-resident <i>keyboard memory map</i>. If the user moves the mouse focus to another area in the simulator GUI, the control of the keyboard is restored to the real computer.</p>
<p><a href="appendix2.xhtml#figA2-5" id="rfigA2-5">Figure A2.5</a> presents a chip that uses three GUI empowered chip-parts. <a href="appendix2.xhtml#figA2-6" id="rfigA2-6">Figure A2.6</a> shows how the simulator handles this chip. The <samp class="SANS_Consolas_Regular_11">GUIDemo</samp> chip logic feeds its <samp class="SANS_Consolas_Regular_11">in</samp> input into two destinations: register number <samp class="SANS_Consolas_Regular_11">address</samp> in the <samp class="SANS_Consolas_Regular_11-SC">RAM16K</samp> chip-part, and register number <samp class="SANS_Consolas_Regular_11">address</samp> in the <samp class="SANS_Consolas_Regular_11">Screen</samp> chip-part. In addition, the chip logic feeds the <samp class="SANS_Consolas_Regular_11">out</samp> values of its three chip-parts to the “dead-end” internal pins <samp class="SANS_Consolas_Regular_11">a</samp>, <samp class="SANS_Consolas_Regular_11">b</samp>, and <samp class="SANS_Consolas_Regular_11">c</samp>. These meaningless connections are designed for one purpose only: illustrating how the simulator deals with built-in, GUI-empowered chip-parts.</p>
<figure class="IMG"><img alt="" id="figA2-5" src="../images/figure_A2.5.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA2-5">Figure A2.5</a></b>    A chip that activates GUI-empowered chip-parts.</p></figcaption>
</figure>
<figure class="IMG"><img alt="" id="figA2-6" src="../images/figure_A2.6.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA2-6">Figure A2.6</a></b>    GUI-empowered chips demo. Since the loaded HDL program uses GUI-empowered chip-parts (step 1), the simulator renders their respective GUI images (step 2). When the user changes the values of the chip input pins (step 3), the simulator reflects these changes in the respective GUIs (step 4).</p></figcaption>
</figure>
<p>Note how the changes effected by the user (step 3) impact the screen (step 4). The circled horizontal line shown on the screen is the visual side effect of storing <samp class="SANS_Consolas_Regular_11">–1</samp> in memory location 5012. Since the 16-bit two’s complement binary code of –1 is 1111111111111111, the computer draws 16 pixels starting at column 320 of row 156, which happen to be the screen coordinates associated with RAM address 5012. The mapping of memory <i>addresses</i> on (<i>row</i>, <i>column</i>) screen coordinates is specified in chapter 4 (section 4.2.5).<span aria-label="293" id="pg_293" role="doc-pagebreak"/></p>
</section>
<section epub:type="division">
<h2 class="head a-head"><span aria-label="294" id="pg_294" role="doc-pagebreak"/><b>A2.6    HDL Survival Guide</b></h2>
<p class="noindent">This section provides practical tips about how to develop chips in HDL using the supplied hardware simulator. The tips are listed in no particular order. We recommend reading this section once, beginning to end, and then consulting it as needed.</p>
<p class="STNI1"><b>Chip</b>: Your <samp class="SANS_Consolas_Regular_11">nand2tetris/projects</samp> folder includes thirteen subfolders, named <samp class="SANS_Consolas_Regular_11">01</samp>, <samp class="SANS_Consolas_Regular_11">02</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">13</samp> (corresponding to the relevant chapter numbers). The hardware project folders are <samp class="SANS_Consolas_Regular_11">01</samp>, <samp class="SANS_Consolas_Regular_11">02</samp>, <samp class="SANS_Consolas_Regular_11">03</samp>, and <samp class="SANS_Consolas_Regular_11">05</samp>. Each hardware project folder contains a set of supplied HDL <i>stub files</i>, one for each chip that you have to build. The supplied HDL files contain no implementations; building these implementations is what the project is all about. If you do not build these chips in the order in which they are described in the book, you may run into difficulties. For example, suppose that you start project 1 by building the Xor chip. If your <samp class="SANS_Consolas_Regular_11">Xor.hdl</samp> implementation includes, say, And and Or chip-parts, and you have not yet implemented <samp class="SANS_Consolas_Regular_11">And.hdl</samp> and <samp class="SANS_Consolas_Regular_11">Or.hdl</samp>, your <samp class="SANS_Consolas_Regular_11">Xor.hdl</samp> program will not work even if its implementation is perfectly correct.</p>
<p>Note, however, that if the project folder included no <samp class="SANS_Consolas_Regular_11">And.hdl</samp> and <samp class="SANS_Consolas_Regular_11">Or.hdl</samp> files, your <samp class="SANS_Consolas_Regular_11">Xor.hdl</samp> program will work properly. The hardware simulator, which is a Java program, features built-in implementations of all the chips necessary to build the Hack computer (with the exception of the <samp class="SANS_Consolas_Regular_11">CPU</samp> and <samp class="SANS_Consolas_Regular_11">Computer</samp> chips). When the simulator evaluates a chip-part, say And, it looks for an <samp class="SANS_Consolas_Regular_11">And.hdl</samp> file in the current folder. At this point there are three possibilities:</p>
<ul class="List-1">
<li class="BLF">No HDL file is found. In this case, the built-in implementation of the chip kicks in, covering for the missing HDL implementation.</li>
<li class="BL1">A stub HDL file is found. The simulator tries to execute it. Failing to find an implementation, the execution fails.</li>
<li class="BLL">An HDL file is found, with an HDL implementation. The simulator executes it, reporting errors, if any, to the best of its ability.</li>
</ul>
<p class="STNI1"><i>Best-practice advice</i>: You can do one of two things. Try to implement the chips in the order presented in the book and in the project descriptions. Since the chips are discussed bottom-up, from basic chips to more complex ones, you will encounter no chip order implementation troubles—provided, of course, that you complete each chip implementation correctly before moving on to implement the next one.</p>
<p>A recommended alternative is to create a subfolder named, say, <samp class="SANS_Consolas_Regular_11">stubs</samp>, and move all the supplied <samp class="SANS_Consolas_Regular_11">.hdl</samp> stub files into it. You can then move each stub file that you want to work on into your working folder, one by one. When you are done implementing a chip successfully, move it into, say, a <samp class="SANS_Consolas_Regular_11">completed</samp> subfolder. This practice forces the simulator to always use built-in chips, since the working folder includes only the <samp class="SANS_Consolas_Regular_11">.hdl</samp> file that you are working on (as well as the supplied <samp class="SANS_Consolas_Regular_11">.tst</samp> and <samp class="SANS_Consolas_Regular_11">.cmp</samp> files).</p>
<p class="STNI1"><span aria-label="295" id="pg_295" role="doc-pagebreak"/><b>HDL files and test scripts</b>: The <samp class="SANS_Consolas_Regular_11">.hdl</samp> file that you are working on and its associated <samp class="SANS_Consolas_Regular_11">.tst</samp> test script file must be located in the same folder. Each supplied test script starts with a <samp class="SANS_Consolas_Regular_11">load</samp> command that loads the <samp class="SANS_Consolas_Regular_11">.hdl</samp> file that it is supposed to test. The simulator always looks for this file in the current folder.</p>
<p>In principle, the simulator’s <samp class="SANS_Consolas_Regular_11">File</samp> menu allows the user to load, interactively, both an <samp class="SANS_Consolas_Regular_11">.hdl</samp> file and a <samp class="SANS_Consolas_Regular_11">.tst</samp> script file. This can create potential problems. For example, you can load the <samp class="SANS_Consolas_Regular_11">.hdl</samp> file that you are working on into the simulator, and then load a test script from another folder. When you execute the test script, it may well load a different version of the HDL program into the simulator (possibly, a stub file). When in doubt, inspect the pane named <samp class="SANS_Consolas_Regular_11">HDL</samp> in the simulator GUI to check which HDL code is presently loaded. <i>Best-practice advice</i>: Use the simulator’s <samp class="SANS_Consolas_Regular_11">File</samp> menu to load either an <samp class="SANS_Consolas_Regular_11">.hdl</samp> file or a <samp class="SANS_Consolas_Regular_11">.tst</samp> file, but not both.</p>
<p class="STNI1"><b>Testing chips in isolation</b>: At some point you may become convinced that your chip is correct, even though it is still failing the test. Indeed, it is possible that the chip is perfectly implemented, but one of its chip-parts is not. Also, a chip that passed its test successfully may fail when used as a chip-part by another chip. One of the biggest inherent limitations of hardware design is that test scripts—especially those that test complex chips—cannot guarantee that the tested chip will operate perfectly in all circumstances.</p>
<p>The good news is that you can always diagnose which chip-part is causing the problem. Create a test subfolder and copy into it only the three <samp class="SANS_Consolas_Regular_11">.hdl</samp>, <samp class="SANS_Consolas_Regular_11">.tst</samp>, and <samp class="SANS_Consolas_Regular_11">.out</samp> files related to the chip that you are presently building. If your chip implementation passes its test in this subfolder as is (letting the simulator use the default built-in chip-parts), there must be a problem with one of your chip-part implementations, that is, with one of the chips that you built earlier in this project. Copy the other chips into this test folder, one by one, and repeat the test until you find the problematic chip.</p>
<p class="STNI1"><b>HDL syntax errors</b>: The hardware simulator displays errors on the bottom status bar. On computers with small screens, these messages are sometimes off the bottom of the screen, not visible. If you load an HDL program and nothing shows up in the <samp class="SANS_Consolas_Regular_11">HDL</samp> pane, but no error message is seen, this may be the problem. Your computer should have a way to move the window, using the keyboard. For example, on Windows use <samp class="SANS_Consolas_Regular_11">Alt</samp><span class="symb-code">+</span><samp class="SANS_Consolas_Regular_11">Space</samp>, <samp class="SANS_Consolas_Regular_11">M</samp>, and the arrow keys.</p>
<p class="STNI1"><b>Unconnected pins</b>: The hardware simulator does not consider unconnected pins to be errors. By default, it sets any unconnected input or output pin to <samp class="SANS_Consolas_Regular_11">false</samp> (binary value <samp class="SANS_Consolas_Regular_11">0</samp>). This can cause mysterious errors in your chip implementations.</p>
<p>If an output pin of your chip is always <samp class="SANS_Consolas_Regular_11">0</samp>, make sure that it is properly connected to another pin in your program. In particular, double-check the names of the internal pins (“wires”) that feed this pin, either directly or indirectly. Typographic errors are particularly hazardous here, since the simulator doesn’t throw errors on disconnected wires. For example, consider the statement <samp class="SANS_Consolas_Regular_11">Foo(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">,</samp> <samp class="SANS_Consolas_Regular_11">sum</samp><span class="code_eq-symb">=</span><samp class="SANS_Consolas_Regular_11">sun)</samp>, where the <samp class="SANS_Consolas_Regular_11">sum</samp> output of <samp class="SANS_Consolas_Regular_11">Foo</samp> is supposed to <span aria-label="296" id="pg_296" role="doc-pagebreak"/>pipe its value to an internal pin. Indeed, the simulator will happily create an internal pin named <samp class="SANS_Consolas_Regular_11">sun</samp>. Now, if <samp class="SANS_Consolas_Regular_11">sum</samp>’s value was supposed to feed the output pin of the implemented chip, or the input pin of another chip-part, this pin will in fact be <samp class="SANS_Consolas_Regular_11">0</samp>, <i>always</i>, since nothing will be piped from <samp class="SANS_Consolas_Regular_11">Foo</samp> onward.</p>
<p>To recap, if an output pin is always <samp class="SANS_Consolas_Regular_11">0</samp>, or if one of the chip-parts does not appear to be working correctly, check the spelling of all the relevant pin names, and verify that all the input pins of the chip-part are connected.</p>
<p class="STNI1"><b>Customized testing</b>: For every <i>chip</i><samp class="SANS_Consolas_Regular_11">.hdl</samp> file that you have to complete your project folder also includes a supplied test script, named <i>chip</i><samp class="SANS_Consolas_Regular_11">.tst</samp>, and a compare file, named <i>chip</i><samp class="SANS_Consolas_Regular_11">.cmp</samp>. Once your chip starts generating outputs, your folder will also include an output file named <i>chip</i><samp class="SANS_Consolas_Regular_11">.out</samp>. If your chip fails the test script, don’t forget to consult the <samp class="SANS_Consolas_Regular_11">.out</samp> file. Inspect the listed output values, and seek clues to the failure. If for some reason you can’t see the output file in the simulator GUI, you can always inspect it using a text editor.</p>
<p>If you want, you can run tests of your own. Copy the supplied test script to, say, <i>MyTestChip</i><samp class="SANS_Consolas_Regular_11">.tst</samp>, and modify the script commands to gain more insight into your chip’s behavior. Start by changing the name of the output file in the <samp class="SANS_Consolas_Regular_11">output-file</samp> line and deleting the <samp class="SANS_Consolas_Regular_11">compare-to</samp> line. This will cause the test to always run to completion (by default, the simulation stops when an output line disagrees with the corresponding line in the compare file). Consider modifying the <samp class="SANS_Consolas_Regular_11">output-list</samp> line to show the outputs of your internal pins.</p>
<p>Appendix 3 documents the Test Description Language (TDL) that features all these commands.</p>
<p class="STNI1"><b>Sub-busing (indexing) internal pins</b>: This is not permitted. The only bus-pins that can be indexed are the input and output pins of the implemented chip or the input and output pins of its chip-parts. However, there is a workaround for sub-busing internal bus-pins. To motivate the work-around, here is an example that doesn’t work:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.9.png"/></figure>
<p class="TNI1">Possible fix, using the work-around:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.10.png"/></figure>
<p class="noindent"><b>Multiple outputs</b>: Sometimes you need to split the multi-bit value of a bus-pin into two buses. This can be done by using multiple <samp class="SANS_Consolas_Regular_11">out</samp><span class="code_eq-symb">=</span> bindings.</p>
<p class="STNI1"><span aria-label="297" id="pg_297" role="doc-pagebreak"/>For example:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.11.png"/></figure>
<p class="TNI1">Sometimes you may want to output a value and also use it for further computations. This can be done as follows:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A2.12.png"/></figure>
<p class="noindent"><b>Chip-parts “auto complete” (sort of)</b>: The signatures of all the chips mentioned in this book are listed in appendix 4, which also has a web-based version (at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>). To use a chip-part in a chip implementation, copy-paste the chip signature from the online document into your HDL program, then fill in the missing bindings. This practice saves time and minimizes typing errors.</p>
</section>
</section>
</div>
</body>
</html>