<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>11 Compiler II: Code Generation</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch11" epub:type="chapter" role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch11"><span aria-label="211" id="pg_211" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">11</samp>     <samp class="SANS_Helvetica_LT_Std_Bold_B_11">Compiler II: Code Generation</samp></h1>
</header>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP1">When I am working on a problem, I never think about beauty. But when I have finished, if the solution is not beautiful, I know it is wrong.</p>
<p class="EPA1">—R. Buckminster Fuller (1895–1993)</p>
</blockquote>
<p class="noindent">Most programmers take compilers for granted. But if you stop to think about it, the ability to translate a high-level program into binary code is almost like magic. In Nand to Tetris we devote four chapters (7–11) for demystifying this magic. Our hands-on methodology is based on developing a compiler for Jack—a simple, modern object-based language. As with Java and C#, the overall Jack compiler is based on two tiers: a virtual machine (VM) <i>back end</i> that translates VM commands into machine language and a <i>front end</i> compiler that translates Jack programs into VM code. Building a compiler is a challenging undertaking, so we divide it further into two conceptual modules: a <i>syntax analyzer</i>, developed in chapter 10, and a <i>code generator</i>—the subject of this chapter.</p>
<p>The syntax analyzer was built in order to develop, and demonstrate, a capability for parsing high-level programs into their underlying syntactical elements. In this chapter we’ll morph the analyzer into a full-scale compiler: a program that converts the parsed elements into VM commands designed to execute on the abstract virtual machine described in chapters 7–8. This approach follows the modular analysis-synthesis paradigm that informs the construction of well-designed compilers. It also captures the very essence of translating text from one language to another: first, one uses the source language’s <i>syntax</i> for analyzing the source text and figuring out its underlying <i>semantics</i>, that is, what the text seeks to say; next, one reexpresses the parsed semantics using the syntax of the target language. In the context of this chapter, the source and the target are Jack and the VM language, respectively.</p>
<p>Modern high-level programming languages are rich and powerful. They allow defining and using elaborate abstractions like functions and objects, expressing algorithms using elegant statements, and building data structures of unlimited complexity. In contrast, the hardware platforms on which these programs ultimately run are spartan and minimal. Typically, they offer little more than a set of registers for storage and a set of primitive instructions for processing. Thus, the translation of programs from high level to low level <span aria-label="212" id="pg_212" role="doc-pagebreak"/>is a challenging feat. If the target platform is a virtual machine and not the barebone hardware, life is somewhat easier since abstract VM commands are not as primitive as concrete machine instructions. Still, the gap between the expressiveness of a high-level language and that of a VM language is wide and challenging.</p>
<p>The chapter begins with a general discussion of <i>code generation</i>, divided into six sections. First, we describe how compilers use <i>symbol tables</i> for mapping symbolic variables onto virtual memory segments. Next, we present algorithms for compiling <i>expressions</i> and <i>strings</i> of characters. We then present techniques for compiling <i>statements</i> like <samp class="SANS_Consolas_Regular_11">let</samp>, <samp class="SANS_Consolas_Regular_11">if</samp>, <samp class="SANS_Consolas_Regular_11">while</samp>, <samp class="SANS_Consolas_Regular_11">do</samp>, and <samp class="SANS_Consolas_Regular_11">return</samp>. Taken together, the ability to compile <i>variables</i>, <i>expressions</i>, and <i>statements</i> forms a foundation for building compilers for simple, procedural, C-like languages. This sets the stage for the remainder of section 11.1, in which we discuss the compilation of <i>objects</i> and <i>arrays</i>.</p>
<p>Section 11.2 (Specification) provides guidelines for mapping Jack programs on the VM platform and language, and section 11.3 (Implementation) proposes a software architecture and an API for completing the compiler’s development. As usual, the chapter ends with a Project section, providing step-by-step guidelines and test programs for completing the compiler’s construction, and a Perspective section that comments on various things that were left out from the chapter.</p>
<p>So what’s in it for you? Although many professionals are eager to understand how compilers work, few end up getting their hands dirty and building a compiler from the ground up. That’s because the cost of this experience—at least in academia—is typically a daunting, full-semester elective course. Nand to Tetris packs the key elements of this experience into four chapters and projects, culminating in the present chapter. In the process, we discuss and illustrate the key algorithms, data structures, and programming tricks underlying the construction of typical compilers. Seeing these clever ideas and techniques in action leads one to marvel, once again, at how human ingenuity can dress up a primitive switching machine to look like something approaching magic.</p>
<section epub:type="division">
<h2 class="head a-head"><b>11.1    Code Generation</b></h2>
<p class="noindent">High-level programmers work with abstract building blocks like <i>variables</i>, <i>expressions</i>, <i>statements</i>, <i>subroutines</i>, <i>objects</i> and <i>arrays</i>. Programmers use these abstract building blocks for describing what they want the program to do. The job of the compiler is to translate this semantics into a language that a target computer understands.</p>
<p>In our case, the target computer is the virtual machine described in chapters 7–8. Thus, we have to figure out how to systematically translate <i>expressions</i>, <i>statements</i>, <i>subroutines</i>, and the handling of <i>variables</i>, <i>objects</i>, and <i>arrays</i> into sequences of stack-based VM commands that execute the desired semantics on the target virtual machine. We don’t have to worry about the subsequent translation of VM programs into machine language, since we already took care of this royal headache in projects 7–8. Thank goodness for two-tier compilation, and for modular design.</p>
<p><span aria-label="213" id="pg_213" role="doc-pagebreak"/>Throughout the chapter, we present compilation examples of various parts of the <samp class="SANS_Consolas_Regular_11">Point</samp> class presented previously in the book. We repeat the class declaration in <a href="chapter_11.xhtml#fig11-1" id="rfig11-1">figure 11.1</a>, which illustrates most of the features of the Jack language. We advise taking a quick look at this Jack code now to refresh your memory about the <samp class="SANS_Consolas_Regular_11">Point</samp> class functionality. You will then be ready to delve into the illuminating journey of systematically reducing this high-level functionality—and any other similar object-based program—into VM code.</p>
<figure class="IMG"><img alt="" id="fig11-1" src="../images/figure_11.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-1">Figure 11.1</a></b>    The <samp class="SANS_Consolas_Regular_11">Point</samp> class. This class features all the possible variable kinds (<samp class="SANS_Consolas_Regular_11">field</samp>, <samp class="SANS_Consolas_Regular_11">static</samp>, <samp class="SANS_Consolas_Regular_11">local</samp>, and <samp class="SANS_Consolas_Regular_11">argument</samp>) and subroutine kinds (<samp class="SANS_Consolas_Regular_11">constructor</samp>, <samp class="SANS_Consolas_Regular_11">method</samp>, and <samp class="SANS_Consolas_Regular_11">function</samp>), as well as subroutines that return primitive types, object types, and void subroutines. It also illustrates function calls, constructor calls, and method calls on the current object (<samp class="SANS_Consolas_Regular_11">this</samp>) and on other objects.</p></figcaption>
</figure>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.1    Handling Variables</b></h3>
<p class="noindent">One of the basic tasks of compilers is mapping the variables declared in the source high-level program onto the host RAM of the target platform. For example, consider Java: <samp class="SANS_Consolas_Regular_11">int</samp> variables are designed to represent 32-bit values; <samp class="SANS_Consolas_Regular_11">long</samp> variables, 64-bit values; and so on. If the host RAM happens to be 32-bit wide, the compiler will map <samp class="SANS_Consolas_Regular_11">int</samp> and <samp class="SANS_Consolas_Regular_11">long</samp> variables on one memory word and on two consecutive memory words, respectively. In Nand to Tetris there are no mapping complications: all the primitive types in Jack (<samp class="SANS_Consolas_Regular_11">int</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, and <samp class="SANS_Consolas_Regular_11">boolean</samp>) are 16-bit wide, and so are the addresses and words of the Hack RAM. Thus, every Jack variable, including pointer variables holding 16-bit address values, can be mapped on exactly one word in memory.</p>
<p><span aria-label="214" id="pg_214" role="doc-pagebreak"/>The second challenge faced by compilers is that variables of different <i>kinds</i> have different life cycles. Class-level static variables are shared globally by all the subroutines in the class. Therefore, a single copy of each static variable should be kept alive during the complete duration of the program’s execution. Instance-level field variables are treated differently: each object (instance of the class) must have a private set of its field variables, and, when the object is no longer needed, this memory must be freed. Subroutine-level local and argument variables are created each time a subroutine starts running and must be freed when the subroutine terminates.</p>
<p>That’s the bad news. The good news is that we’ve already handled all these difficulties. In our two-tier compiler architecture, memory allocation and deallocation are delegated to the VM level. All we have to do now is map Jack <i>static</i> variables on <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <span class="ellipsis">…</span>; <i>field</i> variables on <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <span class="ellipsis">…</span>; <i>local</i> variables on <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <span class="ellipsis">…</span>; and <i>argument</i> variables on <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <span class="ellipsis">…</span>. The subsequent mapping of the virtual memory segments on the host RAM, as well as the intricate management of their run-time life cycles, are completely taken care of by the VM implementation.</p>
<p>Recall that this implementation was not achieved easily: we had to work hard to generate assembly code that dynamically maps the virtual memory segments on the host RAM as a side effect of realizing the function call-and-return protocol. Now we can reap the benefits of this effort: the only thing required from the compiler is mapping the high-level variables onto the virtual memory segments. All the subsequent gory details associated with managing these segments on the RAM will be handled by the VM implementation. That’s why we sometimes refer to the latter as the compiler’s <i>back end</i>.</p>
<p>To recap, in a two-tier compilation model, the handling of variables can be reduced to mapping high-level variables on virtual memory segments and using this mapping, as needed, throughout code generation. These tasks can be readily managed using a classical abstraction known as a <i>symbol table</i>.</p>
<p class="STNI1"><b>Symbol table</b>: Whenever the compiler encounters variables in a high-level statement, for example, <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/11-C1.png" width="74"/> it needs to know what the variables stand for. Is <samp class="SANS_Consolas_Regular_11">x</samp> a static variable, a field of an object, a local variable, or an argument of a subroutine? Does it represent an <samp class="SANS_Consolas_Regular_11">integer</samp>, a <samp class="SANS_Consolas_Regular_11">boolean</samp>, a <samp class="SANS_Consolas_Regular_11">char</samp>, or some class type? All these questions must be answered—for code generation—each time the variable <samp class="SANS_Consolas_Regular_11">x</samp> comes up in the source code. Of course, the variable <samp class="SANS_Consolas_Regular_11">y</samp> should be treated exactly the same way.</p>
<p>The variable properties can be managed conveniently using a <i>symbol table</i>. When a static, field, local, or argument variable is declared in the source code, the compiler allocates it to the next available entry in the corresponding <samp class="SANS_Consolas_Regular_11">static</samp>, <samp class="SANS_Consolas_Regular_11">this</samp>, <samp class="SANS_Consolas_Regular_11">local</samp>, or <samp class="SANS_Consolas_Regular_11">argument</samp> VM segment and records the mapping in the symbol table. Whenever a variable is encountered elsewhere in the code, the compiler looks up its name in the symbol table, retrieves its properties, and uses them, as needed, for code generation.</p>
<p><span aria-label="215" id="pg_215" role="doc-pagebreak"/>An important feature of high-level languages is <i>separate namespaces</i>: the same identifier can represent different things in different regions of the program. To enable separate namespaces, each identifier is implicitly associated with a <i>scope</i>, which is the region of the program in which it is recognized. In Jack, the scope of static and field variables is the class in which they are declared, and the scope of local and argument variables is the subroutine in which they are declared. Jack compilers can realize the scope abstractions by managing two separate symbol tables, as seen in <a href="chapter_11.xhtml#fig11-2" id="rfig11-2">figure 11.2</a>.</p>
<figure class="IMG"><img alt="" id="fig11-2" src="../images/figure_11.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-2">Figure 11.2</a></b>    Symbol table examples. The <samp class="SANS_Consolas_Regular_11">this</samp> row in the subroutine-level table is discussed later in the chapter.</p></figcaption>
</figure>
<p>The scopes are nested, with inner scopes hiding outer ones. For example, when the Jack compiler encounters the expression <img alt="" class="inline" height="12" src="../images/11-C2.png" width="44"/> it first checks whether <samp class="SANS_Consolas_Regular_11">x</samp> is a subroutine-level variable (local or argument). Failing that, the compiler checks whether <samp class="SANS_Consolas_Regular_11">x</samp> is a static variable or a field. Some languages feature nested scoping of unlimited depth, allowing variables to be local in any block of code in which they are declared. To support unlimited nesting, the compiler can use a linked list of symbol tables, each reflecting a single scope nested within the next one in the list. When the compiler fails to find the variable in the table associated with the current scope, it looks it up in the next table in the list, from inner scopes outward. If the variable is not found in the list, the compiler can throw an “undeclared variable” error.</p>
<p>In the Jack language there are only two scoping levels: the subroutine that is presently being compiled, and the class in which the subroutine is declared. Therefore, the compiler can get away with managing two symbol tables only.</p>
<p class="STNI1"><b>Handling variable declarations</b>: When the Jack compiler starts compiling a class declaration, it creates a class-level symbol table and a subroutine-level symbol table. When the compiler parses a static or a field variable declaration, it adds a new row to the class-level symbol table. The row records the variable’s <i>name</i>, <i>type</i> (<samp class="SANS_Consolas_Regular_11">integer</samp>, <samp class="SANS_Consolas_Regular_11">boolean</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, or class name), <i>kind</i> (<samp class="SANS_Consolas_Regular_11">static</samp> or <samp class="SANS_Consolas_Regular_11">field</samp>), and <i>index</i> within the kind.</p>
<p><span aria-label="216" id="pg_216" role="doc-pagebreak"/>When the Jack compiler starts compiling a subroutine (constructor, method, or function) declaration, it resets the subroutine-level symbol table. If the subroutine is a method, the compiler adds the row <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">this</samp>, <i>className</i>, <samp class="SANS_Consolas_Regular_11">arg</samp>, <samp class="SANS_Consolas_Regular_11">0</samp><span class="symb-code">&gt;</span> to the subroutine-level symbol table (this initialization detail is explained in section 11.1.5.2 and can be ignored till then). When the compiler parses a local or an argument variable declaration, it adds a new row to the subroutine-level symbol table, recording the variable’s name, type (<samp class="SANS_Consolas_Regular_11">integer</samp>, <samp class="SANS_Consolas_Regular_11">boolean</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, or class name), kind (<samp class="SANS_Consolas_Regular_11">var</samp> or <samp class="SANS_Consolas_Regular_11">arg</samp>), and index within the kind. The index of each kind (<samp class="SANS_Consolas_Regular_11">var</samp> or <samp class="SANS_Consolas_Regular_11">arg</samp>) starts at 0 and is incremented by 1 after each time a new variable of that kind is added to the table.</p>
<p class="STNI1"><b>Handling variables in statements</b>: When the compiler encounters a variable in a statement, it looks up the variable name in the subroutine-level symbol table. If the variable is not found, the compiler looks it up in the class-level symbol table. Once the variable has been found, the compiler can complete the statement’s translation. For example, consider the symbol tables shown in <a href="chapter_11.xhtml#fig11-2">figure 11.2</a>, and suppose we are compiling the high-level statement <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/11-C3.png" width="68"/> The compiler will translate this statement into the VM commands <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">1</samp>. Here we assume that the compiler knows how to handle expressions and <samp class="SANS_Consolas_Regular_11">let</samp> statements, subjects which are taken up in the next two sections.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.2    Compiling Expressions</b></h3>
<p class="noindent">Let’s start by considering the compilation of simple expressions like <img alt="" class="inline" height="13" src="../images/11-C4.png" width="58"/> By “simple expression” we mean a sequence of <i>term operator term operator term</i> <span class="ellipsis">…</span>, where each <i>term</i> is either a variable or a constant, and each <i>operator</i> is either <span class="symb-code">+</span>, <span class="symb">−</span>, <samp class="SANS_Consolas_Regular_11">*</samp>, or <samp class="SANS_Consolas_Regular_11">/</samp>.</p>
<p>In Jack, as in most high-level languages, expressions are written using <i>infix</i> notation: To add <samp class="SANS_Consolas_Regular_11">x</samp> and <samp class="SANS_Consolas_Regular_11">y</samp>, one writes <img alt="" class="inline" height="11" src="../images/11-C6.png" width="36"/>. In contrast, our compilation’s target language is <i>postfix</i>: The same addition semantics is expressed in the stack-oriented VM code as <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">x</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>. In chapter 10 we introduced an algorithm that emits the parsed source code in infix using XML tags. Although the parsing logic of this algorithm can remain the same, the output part of the algorithm must now be modified for generating postfix commands. <a href="chapter_11.xhtml#fig11-3" id="rfig11-3">Figure 11.3</a> illustrates this dichotomy.</p>
<figure class="IMG"><img alt="" id="fig11-3" src="../images/figure_11.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-3">Figure 11.3</a></b>    Infix and postfix renditions of the same semantics.</p></figcaption>
</figure>
<p>To recap, we need an algorithm that knows how to parse an infix expression and generate from it as output postfix code that realizes the same semantics on a stack machine. <a href="chapter_11.xhtml#fig11-4" id="rfig11-4">Figure 11.4</a> presents one such algorithm. The algorithm processes the input expression from left to right, generating VM code as it goes along. Conveniently, this algorithm also handles unary operators and function calls.</p>
<figure class="IMG"><img alt="" id="fig11-4" src="../images/figure_11.4.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-4">Figure 11.4</a></b>    A VM code generation algorithm for expressions, and a compilation example. The algorithm assumes that the input expression is valid. The final implementation of this algorithm should replace the emitted symbolic variables with their corresponding symbol table mappings.</p></figcaption>
</figure>
<p>If we execute the stack-based VM code generated by the <samp class="SANS_Consolas_Regular_11">codeWrite</samp> algorithm (right side of <a href="chapter_11.xhtml#fig11-4">figure 11.4</a>), the execution will end up consuming all the expression’s terms and putting the expression’s value at the stack’s top. That’s exactly what’s expected from the compiled code of an expression.<span aria-label="217" id="pg_217" role="doc-pagebreak"/></p>
<p><span aria-label="218" id="pg_218" role="doc-pagebreak"/>So far we have dealt with relatively simple expressions. <a href="chapter_11.xhtml#fig11-5" id="rfig11-5">Figure 11.5</a> gives the complete grammatical definition of Jack expressions, along with several examples of actual expressions consistent with this definition.</p>
<figure class="IMG"><img alt="" id="fig11-5" src="../images/figure_11.5.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-5">Figure 11.5</a></b>    Expressions in the Jack language.</p></figcaption>
</figure>
<p>The compilation of Jack expressions will be handled by a routine named <samp class="SANS_Consolas_Regular_11">compileExpression</samp>. The developer of this routine should start with the algorithm presented in <a href="chapter_11.xhtml#fig11-4">figure 11.4</a> and extend it to handle the various possibilities specified in <a href="chapter_11.xhtml#fig11-5">figure 11.5</a>. We will have more to say about this implementation later in the chapter.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.3    Compiling Strings</b></h3>
<p class="noindent">Strings—sequences of characters—are widely used in computer programs. Object-oriented languages typically handle strings as instances of a class named <samp class="SANS_Consolas_Regular_11">String</samp> (Jack’s <samp class="SANS_Consolas_Regular_11">String</samp> class, which is part of the Jack OS, is documented in appendix 6). Each time a string constant comes up in a high-level statement or expression, the compiler generates code that calls the <samp class="SANS_Consolas_Regular_11">String</samp> constructor, which creates and returns a new <samp class="SANS_Consolas_Regular_11">String</samp> object. Next, the compiler initializes the new object with the string characters. This is done by generating a sequence of calls to the <samp class="SANS_Consolas_Regular_11">String</samp> method <samp class="SANS_Consolas_Regular_11">appendChar</samp>, one for each character listed in the high-level string constant.</p>
<p><span aria-label="219" id="pg_219" role="doc-pagebreak"/>This implementation of string constants can be wasteful, leading to potential memory leaks. To illustrate, consider the statement <samp class="SANS_Consolas_Regular_11">Output.printString(</samp><samp class="SANS_Consolas_Regular_11">"Loading <span class="ellipsis">…</span> please wait"</samp><samp class="SANS_Consolas_Regular_11">)</samp>. Presumably, all the high-level programmer wants is to display a message; she certainly doesn’t care if the compiler creates a new object, and she may be surprised to know that the object will persist in memory until the program terminates. But that’s exactly what actually happens: a new <samp class="SANS_Consolas_Regular_11">String</samp> object will be created, and this object will keep lurking in the background, doing nothing.</p>
<p>Java, C#, and Python use a run-time <i>garbage collection</i> process that reclaims the memory used by objects that are no longer in play (technically, objects that have no variable referring to them). In general, modern languages use a variety of optimizations and specialized string classes for promoting the efficient use of string objects. The Jack OS features only one <samp class="SANS_Consolas_Regular_11">String</samp> class and no string-related optimizations.</p>
<p class="STNI1"><b>Operating system services</b>: In the handling of strings, we mentioned for the first time that the compiler can use OS services as needed. Indeed, developers of Jack compilers can assume that every constructor, method, and function listed in the OS API (appendix 6) is available <i>as a compiled VM function</i>. Technically speaking, any one of these VM functions can be called by the code generated by the compiler. This configuration will be fully realized in chapter 12, in which we will implement the OS in Jack and compile it into VM code.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.4    Compiling Statements</b></h3>
<p class="noindent">The Jack programming language features five statements: <samp class="SANS_Consolas_Regular_11">let</samp>, <samp class="SANS_Consolas_Regular_11">do</samp>, <samp class="SANS_Consolas_Regular_11">return</samp>, <samp class="SANS_Consolas_Regular_11">if</samp>, and <samp class="SANS_Consolas_Regular_11">while</samp>. We now turn to discuss how the Jack compiler generates VM code that handles the semantics of these statements.</p>
<p class="STNI1"><b>Compiling</b> <samp class="SANS_Consolas_Bold_B_11">return</samp> <b>statements</b>: Now that we know how to compile expressions, the compilation of <samp class="SANS_Consolas_Regular_11">return</samp> <i>expression</i> is simple. First, we call the <samp class="SANS_Consolas_Regular_11">compileExpression</samp> routine, which generates VM code designed to evaluate and put the expression’s value on the stack. Next, we generate the VM command <samp class="SANS_Consolas_Regular_11">return</samp>.</p>
<p class="STNI1"><b>Compiling</b> <samp class="SANS_Consolas_Bold_B_11">let</samp> <b>statements</b>: Here we discuss the handling of statements of the form <samp class="SANS_Consolas_Regular_11">let</samp> <i>varName</i> <span class="code_eq-symb">=</span> <i>expression</i>. Since parsing is a left-to-right process, we begin by remembering the <i>varName</i>. Next, we call <samp class="SANS_Consolas_Regular_11">compileExpression</samp>, which puts the expression’s value on the stack. Finally, we generate the VM command <samp class="SANS_Consolas_Regular_11">pop</samp> <i>varName</i>, where <i>varName</i> is actually the symbol table mapping of <i>varName</i> (for example, <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">3</samp>, <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, and so on).</p>
<p>We’ll discuss the compilation of statements of the form <samp class="SANS_Consolas_Regular_11">let</samp> <i>varName</i><samp class="SANS_Consolas_Regular_11">[</samp><i>expression</i>1<samp class="SANS_Consolas_Regular_11">]</samp> <span class="code_eq-symb">=</span> <i>expression</i>2 later in the chapter, in a section dedicated to handling arrays.</p>
<p class="STNI1"><span aria-label="220" id="pg_220" role="doc-pagebreak"/><b>Compiling</b> <samp class="SANS_Consolas_Bold_B_11">do</samp> <b>statements</b>: Here we discuss the compilation of <i>function calls</i> of the form <samp class="SANS_Consolas_Regular_11">do</samp> <i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>functionName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><small>1</small><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><small>2</small><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span> <samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i>n<samp class="SANS_Consolas_Regular_11">)</samp>. The <samp class="SANS_Consolas_Regular_11">do</samp> abstraction is designed to call a subroutine for its effect, ignoring the return value. In chapter 10 we recommended compiling such statements as if their syntax were <samp class="SANS_Consolas_Regular_11">do</samp> <i>expression</i>. We repeat this recommendation here: to compile a <samp class="SANS_Consolas_Regular_11">do</samp> <i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>functionName</i> <samp class="SANS_Consolas_Regular_11">(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">)</samp> statement, we call <samp class="SANS_Consolas_Regular_11">compileExpression</samp> and then get rid of the topmost stack element (the expression’s value) by generating a command like <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">temp</samp> <samp class="SANS_Consolas_Regular_11">0</samp>.</p>
<p>We’ll discuss the compilation of <i>method calls</i> of the form <samp class="SANS_Consolas_Regular_11">do</samp> <i>varName.methodName</i> <samp class="SANS_Consolas_Regular_11">(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">)</samp> and <samp class="SANS_Consolas_Regular_11">do</samp> <i>methodName</i> <samp class="SANS_Consolas_Regular_11">(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">)</samp> later in the chapter, in a section dedicated to compiling method calls.</p>
<p class="STNI1"><b>Compiling</b> <samp class="SANS_Consolas_Bold_B_11">if</samp> <b>and</b> <samp class="SANS_Consolas_Bold_B_11">while</samp> <b>statements</b>: High-level programming languages feature a variety of <i>control flow statements</i> like <samp class="SANS_Consolas_Regular_11">if</samp>, <samp class="SANS_Consolas_Regular_11">while</samp>, <samp class="SANS_Consolas_Regular_11">for</samp>, and <samp class="SANS_Consolas_Regular_11">switch</samp>, of which Jack features <samp class="SANS_Consolas_Regular_11">if</samp> and <samp class="SANS_Consolas_Regular_11">while</samp>. In contrast, low-level assembly and VM languages control the flow of execution using two branching primitives: <i>conditional goto</i>, and <i>unconditional goto</i>. Therefore, one of the challenges faced by compiler developers is expressing the semantics of high-level control flow statements using nothing more than goto primitives. <a href="chapter_11.xhtml#fig11-6" id="rfig11-6">Figure 11.6</a> shows how this gap can be bridged systematically.</p>
<figure class="IMG"><img alt="" id="fig11-6" src="../images/figure_11.6.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-6">Figure 11.6</a></b>    Compiling <samp class="SANS_Consolas_Regular_11">if</samp> and <samp class="SANS_Consolas_Regular_11">while</samp> statements. The <samp class="SANS_Consolas_Regular_11">L1</samp> and <samp class="SANS_Consolas_Regular_11">L2</samp> labels are generated by the compiler.</p></figcaption>
</figure>
<p>When the compiler detects an <samp class="SANS_Consolas_Regular_11">if</samp> keyword, it knows that it has to parse a pattern of the form <samp class="SANS_Consolas_Regular_11">if</samp> <samp class="SANS_Consolas_Regular_11">(</samp><i>expression</i><samp class="SANS_Consolas_Regular_11">)</samp> <samp class="SANS_Consolas_Regular_11">{</samp><i>statements</i><samp class="SANS_Consolas_Regular_11">}</samp> <samp class="SANS_Consolas_Regular_11">else</samp> <samp class="SANS_Consolas_Regular_11">{</samp><i>statements</i><samp class="SANS_Consolas_Regular_11">}</samp>. Hence, the compiler starts by calling <span aria-label="221" id="pg_221" role="doc-pagebreak"/><samp class="SANS_Consolas_Regular_11">compileExpression</samp>, which generates VM commands designed to compute and push the expression’s value onto the stack. The compiler then generates the VM command <samp class="SANS_Consolas_Regular_11">not</samp>, designed to negate the expression’s value. Next, the compiler creates a label, say <samp class="SANS_Consolas_Regular_11">L1</samp>, and uses it for generating the VM command <samp class="SANS_Consolas_Regular_11">if-goto</samp> <samp class="SANS_Consolas_Regular_11">L1</samp>. Next, the compiler calls <samp class="SANS_Consolas_Regular_11">compileStatements</samp>. This routine is designed to compile a sequence of the form <i>statement</i><samp class="SANS_Consolas_Regular_11">;</samp> <i>statement</i><samp class="SANS_Consolas_Regular_11">;</samp> <span class="ellipsis">…</span> <i>statement</i><samp class="SANS_Consolas_Regular_11">;</samp>, where each <i>statement</i> is either a <samp class="SANS_Consolas_Regular_11">let</samp>, a <samp class="SANS_Consolas_Regular_11">do</samp>, a <samp class="SANS_Consolas_Regular_11">return</samp>, an <samp class="SANS_Consolas_Regular_11">if</samp>, or a <samp class="SANS_Consolas_Regular_11">while</samp>. The resulting VM code is referred to conceptually in <a href="chapter_11.xhtml#fig11-6">figure 11.6</a> as “compiled (<i>statements</i>).” The rest of the compilation strategy is self-explanatory.</p>
<p>A high-level program normally contains multiple instances of <samp class="SANS_Consolas_Regular_11">if</samp> and <samp class="SANS_Consolas_Regular_11">while</samp>. To handle this complexity, the compiler can generate labels that are globally unique, for example, labels whose suffix is the value of a running counter. Also, control flow statements are often nested—for example, an <samp class="SANS_Consolas_Regular_11">if</samp> within a <samp class="SANS_Consolas_Regular_11">while</samp> within another <samp class="SANS_Consolas_Regular_11">while</samp>, and so on. Such nestings are taken care of implicitly since the <samp class="SANS_Consolas_Regular_11">compileStatements</samp> routine is inherently recursive.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.5    Handling Objects</b></h3>
<p class="noindent">So far in this chapter, we described techniques for compiling <i>variables</i>, <i>expressions</i>, <i>strings</i>, and <i>statements</i>. This forms most of the know-how necessary for building a compiler for a procedural, C-like language. In Nand to Tetris, though, we aim higher: building a compiler for an object-based, Java-like language. With that in mind, we now turn to discuss the handling of <i>objects</i>.</p>
<p>Object-oriented languages feature means for declaring and manipulating aggregate abstractions known as <i>objects</i>. Each object is implemented physically as a memory block which can be referenced by a static, field, local, or argument variable. The reference variable, also known as an <i>object variable</i>, or <i>pointer</i>, contains the memory block’s base address. The operating system realizes this model by managing a logical area in the RAM named <i>heap</i>. The <i>heap</i> is used as a memory pool from which memory blocks are carved, as needed, for representing new objects. When an object is no longer needed, its memory block can be freed and recycled back to the heap. The compiler stages these memory management actions by calling OS functions, as we’ll see later.</p>
<p>At any given point during a program’s execution, the heap can contain numerous objects. Suppose we want to apply a method, say <samp class="SANS_Consolas_Regular_11">foo</samp>, to one of these objects, say <samp class="SANS_Consolas_Regular_11">p</samp>. In an object-oriented language, this is done through the method call idiom <samp class="SANS_Consolas_Regular_11">p.foo()</samp>. Shifting our attention from the caller to the callee, we note that <samp class="SANS_Consolas_Regular_11">foo</samp>—like any other method—is designed to operate on a placeholder known as the <i>current object</i>, or <samp class="SANS_Consolas_Regular_11">this</samp>. In particular, when VM commands in <samp class="SANS_Consolas_Regular_11">foo</samp>’s code make references to <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, and so on, they should effect the fields of <samp class="SANS_Consolas_Regular_11">p</samp>, the object on which <samp class="SANS_Consolas_Regular_11">foo</samp> was called. Which begs the question: How do we align the <samp class="SANS_Consolas_Regular_11">this</samp> segment with <samp class="SANS_Consolas_Regular_11">p</samp>?</p>
<p>The virtual machine built in chapters 7–8 has a mechanism for realizing this alignment: the two-valued <samp class="SANS_Consolas_Regular_11">pointer</samp> segment, mapped directly onto RAM locations 3–4, also known as <samp class="SANS_Consolas_Regular_11">THIS</samp> and <samp class="SANS_Consolas_Regular_11">THAT</samp>. According to the VM specification, the pointer <samp class="SANS_Consolas_Regular_11">THIS</samp> (referred to as <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>) <span aria-label="222" id="pg_222" role="doc-pagebreak"/>is designed to hold the base address of the memory segment <samp class="SANS_Consolas_Regular_11">this</samp>. Thus, to align the <samp class="SANS_Consolas_Regular_11">this</samp> segment with the object <samp class="SANS_Consolas_Regular_11">p</samp>, we can push <samp class="SANS_Consolas_Regular_11">p</samp>’s value (which is an address) onto the stack and then pop it into <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. Versions of this initialization technique are used conspicuously in the compilation of <i>constructors</i> and <i>methods</i>, as we now turn to describe.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.5.1 Compiling Constructors</b></h3>
<p class="noindent">In object-oriented languages, objects are created by subroutines known as <i>constructors</i>. In this section we describe how to compile a constructor call (e.g., Java’s <samp class="SANS_Consolas_Regular_11">new</samp> operator) from the <i>caller</i>’s perspective and how to compile the code of the constructor itself—the <i>callee</i>.</p>
<p class="STNI1"><b>Compiling constructor calls</b>: Object construction is normally a two-stage affair. First, one declares a variable of some class type, for example, <samp class="SANS_Consolas_Regular_11">var</samp> <samp class="SANS_Consolas_Regular_11">Point</samp> <samp class="SANS_Consolas_Regular_11">p</samp>. At a later stage, one can instantiate the object by calling a class constructor, for example, <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">p</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Point.new(2,3)</samp>. Or, depending on the language used, one can declare <i>and</i> construct objects using a single high-level statement. Behind the scenes, though, this action is always broken into two separate stages: declaration followed by construction.</p>
<p>Let’s take a close look at the statement <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">p</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Point.new(2,3)</samp>. This abstraction can be described as “have the <samp class="SANS_Consolas_Regular_11">Point.new</samp> constructor allocate a two-word memory block for representing a new <samp class="SANS_Consolas_Regular_11">Point</samp> instance, initialize the two words of this block to 2 and 3, and have <samp class="SANS_Consolas_Regular_11">p</samp> refer to the base address of this block.” Implicit in this semantics are two assumptions: First, the constructor knows how to allocate a memory block of the required size. Second, when the constructor—being a subroutine—terminates its execution, it returns to the caller the base address of the allocated memory block. <a href="chapter_11.xhtml#fig11-7" id="rfig11-7">Figure 11.7</a> shows how this abstraction can be realized.</p>
<figure class="IMG"><img alt="" id="fig11-7" src="../images/figure_11.7.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-7">Figure 11.7</a></b>    Object construction from the caller’s perspective. In this example, the caller declares two object variables and then calls a class constructor for constructing the two objects. The constructor works its magic, allocating memory blocks for representing the two objects. The calling code then makes the two object variables refer to these memory blocks.</p></figcaption>
</figure>
<p>Three observations about <a href="chapter_11.xhtml#fig11-7">figure 11.7</a> are in order. First, note that there is nothing special about compiling statements like <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">p</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Point.new(2,3)</samp> and <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">p</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Point.new(5,7)</samp>. We already discussed how to compile <samp class="SANS_Consolas_Regular_11">let</samp> statements and subroutine calls. The only thing that makes these calls special is the hocus-pocus assumption that—somehow—two objects will be constructed. The implementation of this magic is entirely delegated to the compilation of the <i>callee</i>—the constructor. As a result of this magic, the constructor creates the two objects seen in the RAM diagram in <a href="chapter_11.xhtml#fig11-7">figure 11.7</a>. This leads to the second observation: The physical addresses 6012 and 9543 are irrelevant; the high-level code as well as the compiled VM code have no idea where the objects are stored in memory; the references to these objects are strictly symbolic, via <samp class="SANS_Consolas_Regular_11">p1</samp> and <samp class="SANS_Consolas_Regular_11">p2</samp> in the high-level code and <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">0</samp> and <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">1</samp> in the compiled code. (As a side comment, this makes the program relocatable and safer.) Third, and stating the obvious, nothing of substance actually happens until the generated VM code is executed. In particular, during <i>compile-time</i>, the symbol table is updated, low-level code is generated, and that’s it. The objects will be constructed and bound to the variables only during <i>run-time</i>, that is, if and when the compiled code will be executed.</p>
<p class="STNI1"><span aria-label="223" id="pg_223" role="doc-pagebreak"/><b>Compiling constructors</b>: So far, we have treated constructors as black box abstractions: we assume that they create objects, <i>somehow</i>. <a href="chapter_11.xhtml#fig11-8" id="rfig11-8">Figure 11.8</a> unravels this magic. Before inspecting the figure, note that a constructor is, first and foremost, a <i>subroutine</i>. It can have arguments, local variables, and a body of statements; thus the compiler treats it as such. What makes the compilation of a constructor special is that in addition to treating it as a regular subroutine, the compiler must also generate code that (i) creates a new object and (ii) makes the new object the <i>current object</i> (also known as <samp class="SANS_Consolas_Regular_11">this</samp>), that is, the object on which the constructor’s code is to operate.</p>
<figure class="IMG"><img alt="" id="fig11-8" src="../images/figure_11.8.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-8">Figure 11.8</a></b>    Object construction: the constructor’s perspective.</p></figcaption>
</figure>
<p>The creation of a new object requires finding a free RAM block sufficiently large to accommodate the new object’s data and marking the block as used. These tasks are delegated to the host operating system. According to the OS API listed in appendix 6, the OS function <samp class="SANS_Consolas_Regular_11">Memory.alloc</samp> <samp class="SANS_Consolas_Regular_11">(</samp><i>size</i><samp class="SANS_Consolas_Regular_11">)</samp> knows how to find an available RAM block of a given <i>size</i> (number of 16-bit words) and return the block’s base address.</p>
<p><span aria-label="224" id="pg_224" role="doc-pagebreak"/><samp class="SANS_Consolas_Regular_11">Memory.alloc</samp> and its sister function <samp class="SANS_Consolas_Regular_11">Memory.deAlloc</samp> use clever algorithms for allocating and freeing RAM resources efficiently. These algorithms will be presented and implemented in chapter 12, when we’ll build the operating system. For now, suffice it to say that compilers generate low-level code that uses <samp class="SANS_Consolas_Regular_11">alloc</samp> (in constructors) and <samp class="SANS_Consolas_Regular_11">deAlloc</samp> (in destructors), abstractly.</p>
<p>Before calling <samp class="SANS_Consolas_Regular_11">Memory.alloc</samp>, the compiler determines the size of the required memory block. This can be readily computed from the class-level symbol table. For example, the symbol table of the <samp class="SANS_Consolas_Regular_11">Point</samp> class specifies that each <samp class="SANS_Consolas_Regular_11">Point</samp> object is characterized by two <samp class="SANS_Consolas_Regular_11">int</samp> values (the point’s <i>x</i> and <i>y</i> coordinates). Thus, the compiler generates the commands <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <samp class="SANS_Consolas_Regular_11">2</samp> and <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Memory.alloc</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, effecting the function call <samp class="SANS_Consolas_Regular_11">Memory.alloc(2)</samp>. The OS function <samp class="SANS_Consolas_Regular_11">alloc</samp> goes to work, finds an available RAM block of size 2, and pushes its base address onto the stack—the VM equivalent of returning a value. The next generated VM statement—<samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>—sets <samp class="SANS_Consolas_Regular_11">THIS</samp> to the base address returned by <samp class="SANS_Consolas_Regular_11">alloc</samp>. From this point onward, the constructor’s <samp class="SANS_Consolas_Regular_11">this</samp> segment will be aligned with the RAM block that was allocated for representing the newly constructed object.</p>
<p>Once the <samp class="SANS_Consolas_Regular_11">this</samp> segment is properly aligned, we can proceed to generate code easily. For example, when the <samp class="SANS_Consolas_Regular_11">compileLet</samp> routine is called to handle the statement <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="10" src="../images/11-C7.png" width="44"/> it searches the symbol tables, resolving <samp class="SANS_Consolas_Regular_11">x</samp> to <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">0</samp> and <samp class="SANS_Consolas_Regular_11">ax</samp> to <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. Thus, <samp class="SANS_Consolas_Regular_11">compileLet</samp> generates the commands <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, followed by <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. The latter command rests on the assumption that the <samp class="SANS_Consolas_Regular_11">this</samp> segment is properly aligned with the base address of the new object, as indeed was done when we had set <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp> (actually, <samp class="SANS_Consolas_Regular_11">THIS</samp>) to the base address returned by <samp class="SANS_Consolas_Regular_11">alloc</samp>. This one-time initialization ensures that all the subsequent <samp class="SANS_Consolas_Regular_11">push</samp> / <samp class="SANS_Consolas_Regular_11">pop</samp> <span aria-label="225" id="pg_225" role="doc-pagebreak"/><samp class="SANS_Consolas_Regular_11">this</samp> <i>i</i> commands will end up hitting the right targets in the RAM (more accurately, in the <i>heap</i>). We hope that the intricate beauty of this contract is not lost on the reader.</p>
<p>According to the Jack language specification, every constructor must end with a <samp class="SANS_Consolas_Regular_11">return</samp> <samp class="SANS_Consolas_Regular_11">this</samp> statement. This convention forces the compiler to end the constructor’s compiled version with <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp> and <samp class="SANS_Consolas_Regular_11">return</samp>. These commands push onto the stack the value of <samp class="SANS_Consolas_Regular_11">THIS</samp>, the base address of the constructed object. In some languages, like Java, constructors don’t have to end with an explicit <samp class="SANS_Consolas_Regular_11">return</samp> <samp class="SANS_Consolas_Regular_11">this</samp> statement. Nonetheless, the compiled code of Java constructors performs exactly the same action at the VM level, since that’s what constructors are expected to do: create an object and return its handle to the caller.</p>
<p>Recall that the elaborate low-level drama just described was unleashed by the caller-side statement <samp class="SANS_Consolas_Regular_11">let</samp> <i>varName</i> <span class="code_eq-symb">=</span> <i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>constructorName</i> <samp class="SANS_Consolas_Regular_11">(</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">)</samp>. We now see that, by design, when the constructor terminates, <i>varName</i> ends up storing the base address of the new object. When we say “by design,” we mean by the syntax of the high-level object construction idiom and by the hard work that the compiler, the operating system, the VM translator, and the assembler have to do in order to realize this abstraction. The net result is that high-level programmers are spared from all the gory details of object construction and are able to create objects easily and transparently.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.5.2 Compiling Methods</b></h3>
<p class="noindent">As we did with constructors, we’ll describe how to compile method calls and then how to compile the methods themselves.</p>
<p class="STNI1"><b>Compiling method calls</b>: Suppose we wish to compute the Euclidean distance between two points in a plane, <samp class="SANS_Consolas_Regular_11">p1</samp> and <samp class="SANS_Consolas_Regular_11">p2</samp>. In C-style procedural programming, this could have been implemented using a function call like <samp class="SANS_Consolas_Regular_11">distance(p1,p2)</samp>, where <samp class="SANS_Consolas_Regular_11">p1</samp> and <samp class="SANS_Consolas_Regular_11">p2</samp> represent composite data types. In object-oriented programming, though, <samp class="SANS_Consolas_Regular_11">p1</samp> and <samp class="SANS_Consolas_Regular_11">p2</samp> will be implemented as instances of some <samp class="SANS_Consolas_Regular_11">Point</samp> class, and the same computation will be done using a method call like <samp class="SANS_Consolas_Regular_11">p1.distance(p2)</samp>. Unlike functions, <i>methods</i> are subroutines that always operate on a given object, and it’s the caller’s responsibility to specify this object. (The fact that the <samp class="SANS_Consolas_Regular_11">distance</samp> method takes another <samp class="SANS_Consolas_Regular_11">Point</samp> object as an argument is a coincidence. In general, while a method is always designed to operate on an object, the method can have 0, 1, or more arguments, of any type).</p>
<p>Observe that <samp class="SANS_Consolas_Regular_11">distance</samp> can be described as a <i>procedure</i> for computing the distance from a given point to another, and <samp class="SANS_Consolas_Regular_11">p1</samp> can be described as the <i>data</i> on which the procedure operates. Also, note that both idioms <samp class="SANS_Consolas_Regular_11">distance(p1,p2)</samp> and <samp class="SANS_Consolas_Regular_11">p1.distance(p2)</samp> are designed to compute and return the same value. Yet while the C-style syntax puts the focus on <samp class="SANS_Consolas_Regular_11">distance</samp>, in the object-oriented syntax, the object comes first, literally speaking. That’s why C-like languages are sometimes called <i>procedural</i>, and object-oriented languages are said to be <i>data-driven</i>. Among other things, the object-oriented programming style is based on the assumption that objects know how to take care of themselves. For example, a <samp class="SANS_Consolas_Regular_11">Point</samp> <span aria-label="226" id="pg_226" role="doc-pagebreak"/>object knows how to compute the distance between it and another <samp class="SANS_Consolas_Regular_11">Point</samp> object. Said otherwise, the <samp class="SANS_Consolas_Regular_11">distance</samp> operation is <i>encapsulated</i> within the definition of being a <samp class="SANS_Consolas_Regular_11">Point</samp>.</p>
<p>The agent responsible for bringing all these fancy abstractions down to earth is, as usual, the hard-working compiler. Because the target VM language has no concept of objects or methods, the compiler handles object-oriented method calls like <samp class="SANS_Consolas_Regular_11">p1.distance</samp> <samp class="SANS_Consolas_Regular_11">(p2)</samp> as if they were procedural calls like <samp class="SANS_Consolas_Regular_11">distance</samp> <samp class="SANS_Consolas_Regular_11">(p1,p2)</samp>. Specifically, it translates <samp class="SANS_Consolas_Regular_11">p1.distance</samp> <samp class="SANS_Consolas_Regular_11">(p2)</samp> into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">p1</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">p2</samp>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">distance</samp>. Let us generalize: Jack features two kinds of method calls:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_11.1.png"/></figure>
<p class="TNI1">To compile the method call <i>varName</i><samp class="SANS_Consolas_Regular_11">.</samp><i>methodName</i><samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp<sub>n</sub></i><samp class="SANS_Consolas_Regular_11">)</samp>, we start by generating the command <samp class="SANS_Consolas_Regular_11">push</samp> <i>varName</i>, where <i>varName</i> is the symbol table mapping of <i>varName</i>. If the method call mentions no <i>varName</i>, we push the symbol table mapping of <samp class="SANS_Consolas_Regular_11">this</samp>. Next, we call <samp class="SANS_Consolas_Regular_11">compileExpressionList</samp>. This routine calls <samp class="SANS_Consolas_Regular_11">compileExpression</samp> <i>n</i> times, once for each expression in the parentheses. Finally, we generate the command <samp class="SANS_Consolas_Regular_11">call</samp> <i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>methodName <img alt="" class="inline" height="14" src="../images/11-1.png" width="35"/></i> informing that <img alt="" class="inline" height="12" src="../images/11-2.png" width="30"/> arguments were pushed onto the stack. The special case of calling an argument-less method is translated into <samp class="SANS_Consolas_Regular_11">call</samp> <i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>methodName</i> <samp class="SANS_Consolas_Regular_11">1</samp>. Note that <i>className</i> is the symbol table <i>type</i> of the <i>varName</i> identifier. See <a href="chapter_11.xhtml#fig11-9" id="rfig11-9">figure 11.9</a> for an example.</p>
<figure class="IMG"><img alt="" id="fig11-9" src="../images/figure_11.9.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-9">Figure 11.9</a></b>    Compiling method calls: the caller’s perspective.</p></figcaption>
</figure>
<p class="STNI1"><b>Compiling methods</b>: So far we discussed the <samp class="SANS_Consolas_Regular_11">distance</samp> method abstractly, from the caller’s perspective. Consider how this method could be implemented, say, in Java:</p>
<figure class="IMG-L"><img alt="" class="img80" src="../images/figure_wo_caption_11.2.png"/></figure>
<p>Like any method, <samp class="SANS_Consolas_Regular_11">distance</samp> is designed to operate on the <i>current object</i>, represented in Java (and in Jack) by the built-in identifier <samp class="SANS_Consolas_Regular_11">this</samp>. As the above example illustrates, though, one can write an entire method without ever mentioning <samp class="SANS_Consolas_Regular_11">this</samp>. That’s because the friendly Java compiler handles statements like <img alt="" class="inline" height="11" src="../images/11-C8.png" width="107"/> as if they were <img alt="" class="inline" height="11" src="../images/11-C9.png" width="152"/> This convention makes high-level code more readable and easier to write.</p>
<p>We note in passing, though, that in the Jack language, the idiom <i>object</i><samp class="SANS_Consolas_Regular_11">.</samp><i>field</i> is not supported. Therefore, fields of objects other than the current object can be manipulated only <span aria-label="227" id="pg_227" role="doc-pagebreak"/>using accessor and mutator methods. For example, expressions like <samp class="SANS_Consolas_Regular_11">x</samp> <samp class="SANS_Consolas_Regular_11">–</samp> <samp class="SANS_Consolas_Regular_11">other.x</samp> are implemented in Jack as <samp class="SANS_Consolas_Regular_11">x</samp> <samp class="SANS_Consolas_Regular_11">–</samp> <samp class="SANS_Consolas_Regular_11">other.getx()</samp>, where <samp class="SANS_Consolas_Regular_11">getx</samp> is an accessor method in the <samp class="SANS_Consolas_Regular_11">Point</samp> class.</p>
<p>So how does the Jack compiler handle expressions like <samp class="SANS_Consolas_Regular_11">x</samp> <samp class="SANS_Consolas_Regular_11">–</samp> <samp class="SANS_Consolas_Regular_11">other.getx()</samp>? Like the Java compiler, it looks up <samp class="SANS_Consolas_Regular_11">x</samp> in the symbol tables and finds that it represents the first field in the current object. But <i>which</i> object in the pool of so many objects out there does the <i>current object</i> represent? Well, according to the method call contract, it must be the first argument that was passed by the method’s caller. Therefore, from the callee’s perspective, the current object must be the object whose base address is the value of <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. This, in a nutshell, is the low-level compilation trick that makes the ubiquitous abstraction “apply a method to an object” possible in languages like Java, Python, and, of course, Jack. See <a href="chapter_11.xhtml#fig11-10" id="rfig11-10">figure 11.10</a> for the details.</p>
<figure class="IMG"><img alt="" id="fig11-10" src="../images/figure_11.10.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-10">Figure 11.10</a></b>    Compiling methods: the callee’s perspective.</p></figcaption>
</figure>
<p>The example starts at the top left of <a href="chapter_11.xhtml#fig11-10">figure 11.10</a>, where the caller’s code makes the method call <samp class="SANS_Consolas_Regular_11">p1.distance(p2)</samp>. Turning our attention to the compiled version of the callee, note that the code proper starts with <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, followed by <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. These commands set the method’s <samp class="SANS_Consolas_Regular_11">THIS</samp> pointer to the value of <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, which, by virtue of the method calling contract, contains the base address of the object on which the method was called to operate. Thus, from this point onward, the method’s <samp class="SANS_Consolas_Regular_11">this</samp> segment is properly aligned with the base address of the target object, making every <samp class="SANS_Consolas_Regular_11">push</samp> / <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">this</samp> <i>i</i> command <span aria-label="228" id="pg_228" role="doc-pagebreak"/>properly aligned as well. For example, the expression <samp class="SANS_Consolas_Regular_11">x</samp>—<samp class="SANS_Consolas_Regular_11">other.getx</samp> <samp class="SANS_Consolas_Regular_11">()</samp> will be compiled into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Point.getx</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">sub</samp>. Since we started the compiled method code by setting <samp class="SANS_Consolas_Regular_11">THIS</samp> to the base address of the called object, we are guaranteed that <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">0</samp> (and any other reference <samp class="SANS_Consolas_Regular_11">this</samp> <i>i</i>) will hit the mark, targeting the right field of the right object.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.1.6    Compiling Arrays</b></h3>
<p class="noindent">Arrays are similar to objects. In Jack, arrays are implemented as instances of an <samp class="SANS_Consolas_Regular_11">Array</samp> class, which is part of the operating system. Thus, arrays and objects are declared, implemented, and stored exactly the same way; in fact, arrays <i>are</i> objects, with the difference that the array abstraction allows accessing array elements using an index, for example, <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">arr<img alt="" class="inline" height="14" src="../images/11-C10.png" width="56"/></samp> The agent that makes this useful abstraction concrete is the compiler, as we now turn to describe.</p>
<p>Using pointer notation, observe that <samp class="SANS_Consolas_Regular_11">arr[i]</samp> can be written as <img alt="" class="inline" height="14" src="../images/11-C11.png" width="73"/> that is, memory address <img alt="" class="inline" height="11" src="../images/11-C12.png" width="51"/> This insight holds the key for compiling statements like <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/11-C13.png" width="74"/> To compute the physical address of <samp class="SANS_Consolas_Regular_11">arr[i]</samp>, we execute <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">arr</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">i</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>, which results in pushing the target address onto the stack. Next, we execute <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">1</samp>. According to the VM specification, this action stores the target address in the method’s <samp class="SANS_Consolas_Regular_11">THAT</samp> pointer <span aria-label="229" id="pg_229" role="doc-pagebreak"/>(<samp class="SANS_Consolas_Regular_11-SC">RAM[4]</samp>), which has the effect of aligning the base address of the virtual segment <samp class="SANS_Consolas_Regular_11">that</samp> with the target address. Thus we can now execute <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">that</samp> <samp class="SANS_Consolas_Regular_11">0</samp> and <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">x</samp>, completing the low-level translation of <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/11-C14.png" width="71"/> See <a href="chapter_11.xhtml#fig11-11" id="rfig11-11">figure 11.11</a> for the details.</p>
<figure class="IMG"><img alt="" id="fig11-11" src="../images/figure_11.11.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-11">Figure 11.11</a></b>    Array access using VM commands.</p></figcaption>
</figure>
<p>This nice compilation strategy has only one problem: it doesn’t work. More accurately, it works with statements like <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/11-C15.png" width="49"/> but fails with statements in which the left-hand side of the assignment is indexed, as in <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/11-C16.png" width="78"/> See <a href="chapter_11.xhtml#fig11-12" id="rfig11-12">figure 11.12</a>.</p>
<figure class="IMG"><img alt="" id="fig11-12" src="../images/figure_11.12.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig11-12">Figure 11.12</a></b>    Basic compilation strategy for arrays, and an example of the bugs that it can generate. In this particular case, the value stored in <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">1</samp> is overridden, and the address of <samp class="SANS_Consolas_Regular_11">a[i]</samp> is lost.</p></figcaption>
</figure>
<p>The good news is that this flawed compilation strategy can be easily fixed to compile correctly any instance of <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">arr[</samp><i>expression</i>1<samp class="SANS_Consolas_Regular_11">]</samp> <span class="code_eq-symb">=</span> <i>expression</i>2. As before, we start by generating the command <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">arr</samp>, calling <samp class="SANS_Consolas_Regular_11">compileExpression</samp>, and generating the command <samp class="SANS_Consolas_Regular_11">add</samp>. This sequence puts the target address (<samp class="SANS_Consolas_Regular_11">arr</samp> <span class="symb">+</span> <i>expression</i>1) at the stack’s top. Next, we call <samp class="SANS_Consolas_Regular_11">compileExpression</samp>, which will end up putting at the stack’s top the value of <i>expression</i>2. At this point we save this value—we can do it using <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">temp</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. This operation has the nice side effect of making (<samp class="SANS_Consolas_Regular_11">arr</samp> <span class="symb">+</span> <i>expression</i>1) the top stack element. Thus we can now <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">temp</samp> <samp class="SANS_Consolas_Regular_11">0, and</samp> <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">that</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. This little fix, along with the recursive nature of the <samp class="SANS_Consolas_Regular_11">compileExpression</samp> routine, makes this compilation strategy capable of handling <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">arr[</samp><i>expression</i>1<samp class="SANS_Consolas_Regular_11">]</samp> <span class="code_eq-symb">=</span> <i>expression</i>2 statements of any recursive complexity, such as, say, <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="14" src="../images/11-C17.png" width="257"/></p>
<p>In closing, several things make the compilation of Jack arrays relatively simple. First, Jack arrays are not typed; rather, they are designed to store 16-bit values, with no restrictions. Second, all primitive data types in Jack are 16-bit wide, all addresses are 16-bit wide, and so is the RAM’s word width. In strongly typed programming languages, and in <span aria-label="230" id="pg_230" role="doc-pagebreak"/>languages where this one-to-one correspondence cannot be guaranteed, the compilation of arrays requires more work.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>11.2    Specification</b></h2>
<p class="noindent">The compilation challenges and solutions that we have described so far can be generalized to support the compilation of any object-based programming language. We now turn from the general to the specific: from here to the end of the chapter, we describe the <i>Jack compiler</i>. The Jack compiler is a program that gets a Jack program as input and generates executable VM code as output. The VM code realizes the program’s semantics on the virtual machine specified in chapters 7–8.</p>
<p class="STNI1"><b>Usage</b>: The compiler accepts a single command-line argument, as follows,</p>
<p class="COM2"><samp class="SANS_Consolas_Regular_11">prompt</samp><span class="symb">&gt;</span> <samp class="SANS_Consolas_Regular_11">JackCompiler</samp> <i>source</i></p>
<p class="TNI1">where <i>source</i> is either a file name of the form <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> (the extension is mandatory) or the name of a folder (in which case there is no extension) containing one or more <samp class="SANS_Consolas_Regular_11">.jack</samp> files. The file/folder name may contain a file path. If no path is specified, the compiler operates on the current folder. For each <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> file, the compiler creates an output file <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp> and writes the VM commands into it. The output file is created in the same folder as the input file. If there is a file by this name in the folder, it will be overwritten.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><span aria-label="231" id="pg_231" role="doc-pagebreak"/><b>11.3    Implementation</b></h2>
<p class="noindent">We now turn to provide guidelines, implementation tips, and a proposed API for extending the syntax analyzer built in chapter 10 into a full-scale Jack compiler.</p>
<section epub:type="division">
<h3 class="head b-head"><b>11.3.1    Standard Mapping over the Virtual Machine</b></h3>
<p class="noindent">Jack compilers can be developed for different target platforms. This section provides guidelines on how to map various constructs of the Jack language on one specific platform: the virtual machine specified in chapters 7–8.</p>
<p class="STNI1"><b>Naming Files and Functions</b></p>
<ul class="List-1">
<li class="BLF">A Jack class file <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> is compiled into a VM class file named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp></li>
<li class="BLL">A Jack subroutine <i>yyy</i> in file <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> is compiled into a VM function named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.</samp><i>yyy</i></li>
</ul>
<p class="STNI1"><b>Mapping Variables</b></p>
<ul class="List-1">
<li class="BLF">The first, second, third, <span class="ellipsis">…</span> <i>static</i> variable declared in a class declaration is mapped on the virtual segment entry <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <span class="ellipsis">…</span></li>
<li class="BL1">The first, second, third, <span class="ellipsis">…</span> <i>field</i> variable declared in a class declaration is mapped on <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <span class="ellipsis">…</span></li>
<li class="BL1">The first, second, third, <span class="ellipsis">…</span> <i>local</i> variable declared in the <samp class="SANS_Consolas_Regular_11">var</samp> statements of a subroutine is mapped on <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <span class="ellipsis">…</span></li>
<li class="BL1">The first, second, third, <span class="ellipsis">…</span> <i>argument</i> variable declared in the parameter list of a <i>function</i> or a <i>constructor</i> (but not a <i>method</i>) is mapped on <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <span class="ellipsis">…</span></li>
<li class="BLL">The first, second, third, <span class="ellipsis">…</span> <i>argument</i> variable declared in the parameter list of a <i>method</i> is mapped on <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">3</samp>, <span class="ellipsis">…</span></li>
</ul>
<p class="STNI1"><b>Mapping Object Fields</b></p>
<p class="STNI1">To align the virtual segment <samp class="SANS_Consolas_Regular_11">this</samp> with the object passed by the caller of a <i>method</i>, use the VM commands <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>.</p>
<p class="STNI1"><b>Mapping Array Elements</b></p>
<p class="STNI1">The high-level reference <samp class="SANS_Consolas_Regular_11">arr[</samp><i>expression</i><samp class="SANS_Consolas_Regular_11">]</samp> is compiled by setting <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">1</samp> to (<samp class="SANS_Consolas_Regular_11">arr</samp> <span class="symb">+</span> <i>expression</i>) and accessing <samp class="SANS_Consolas_Regular_11">that</samp> <samp class="SANS_Consolas_Regular_11">0</samp>.</p>
<p class="STNI1"><span aria-label="232" id="pg_232" role="doc-pagebreak"/><b>Mapping Constants</b></p>
<ul class="List-1">
<li class="BLF">References to the Jack constants <samp class="SANS_Consolas_Regular_11">null</samp> and <samp class="SANS_Consolas_Regular_11">false</samp> are compiled into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <samp class="SANS_Consolas_Regular_11">0</samp>.</li>
<li class="BL1">References to the Jack constant <samp class="SANS_Consolas_Regular_11">true</samp> are compiled into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">neg</samp>. This sequence pushes the value <span class="symb">−</span><samp class="SANS_Consolas_Regular_11">1</samp> onto the stack.</li>
<li class="BLL">References to the Jack constant <samp class="SANS_Consolas_Regular_11">this</samp> are compiled into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. This command pushes the base address of the current object onto the stack.</li>
</ul>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.3.2    Implementation Guidelines</b></h3>
<p class="noindent">Throughout this chapter we have seen many conceptual compilation examples. We now give a concise and formal summary of all these compilation techniques.</p>
<p class="STNI1"><b>Handling Identifiers</b></p>
<p class="STNI1">The identifiers used for naming variables can be handled using symbol tables. During the compilation of valid Jack code, any identifier not found in the symbol tables may be assumed to be either a subroutine name or a class name. Since the Jack syntax rules suffice for distinguishing between these two possibilities, and since the Jack compiler performs no “linking,” there is no need to keep these identifiers in a symbol table.</p>
<p class="STNI1"><b>Compiling Expressions</b></p>
<p class="STNI1">The <samp class="SANS_Consolas_Regular_11">compileExpression</samp> routine should process the input as the sequence <i>term op term op term</i> <span class="ellipsis">…</span>. To do so, <samp class="SANS_Consolas_Regular_11">compileExpression</samp> should implement the <samp class="SANS_Consolas_Regular_11">codeWrite</samp> algorithm (<a href="chapter_11.xhtml#fig11-4">figure 11.4</a>), extended to handle all the possible <i>terms</i> specified in the Jack grammar (<a href="chapter_11.xhtml#fig11-5">figure 11.5</a>). Indeed, an inspection of the grammar rules reveals that most of the action in compiling <i>expressions</i> occurs in the compilation of their underlying <i>terms</i>. This is especially true following our recommendation that the compilation of subroutine calls be handled directly by the compilation of <i>terms</i> (implementation notes following the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> API, section 10.3).</p>
<p>The <i>expression</i> grammar and thus the corresponding <samp class="SANS_Consolas_Regular_11">compileExpression</samp> routine are inherently recursive. For example, when <samp class="SANS_Consolas_Regular_11">compileExpression</samp> detects a left parenthesis, it should recursively call <samp class="SANS_Consolas_Regular_11">compileExpression</samp> to handle the inner expression. This recursive descent ensures that the inner expression will be evaluated first. Except for this priority rule, the Jack language supports <i>no operator priority</i>. Handling operator priority is of course possible, but in Nand to Tetris we consider it an optional compiler-specific extension, not a standard feature of the Jack language.</p>
<p>The expression <samp class="SANS_Consolas_Regular_11">x</samp> <samp class="SANS_Consolas_Regular_11">*</samp> <samp class="SANS_Consolas_Regular_11">y</samp> is compiled into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">x</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Math.multiply</samp> <samp class="SANS_Consolas_Regular_11">2</samp>. The expression <samp class="SANS_Consolas_Regular_11">x</samp> <samp class="SANS_Consolas_Regular_11">/</samp> <samp class="SANS_Consolas_Regular_11">y</samp> is compiled into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">x</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Math.divide</samp> <samp class="SANS_Consolas_Regular_11">2</samp>. The <samp class="SANS_Consolas_Regular_11">Math</samp> class is part of the OS, documented in appendix 6. This class will be developed in chapter 12.</p>
<p class="STNI1"><span aria-label="233" id="pg_233" role="doc-pagebreak"/><b>Compiling Strings</b></p>
<p class="STNI1">Each string constant <samp class="SANS_Consolas_Regular_11">"</samp><i>ccc</i> <span class="ellipsis">…</span> <i>c</i><samp class="SANS_Consolas_Regular_11">"</samp> is handled by (i) pushing the string length onto the stack and calling the <samp class="SANS_Consolas_Regular_11">String.new</samp> constructor, and (ii) pushing the character code of <i>c</i> on the stack and calling the <samp class="SANS_Consolas_Regular_11">String</samp> method <samp class="SANS_Consolas_Regular_11">appendChar</samp>, once for each character <i>c</i> in the string (the Jack character set is documented in appendix 5). As documented in the <samp class="SANS_Consolas_Regular_11">String</samp> class API in appendix 6, both the <samp class="SANS_Consolas_Regular_11">new</samp> constructor and the <samp class="SANS_Consolas_Regular_11">appendChar</samp> method return the string as the return value (i.e., they push the string object onto the stack). This simplifies compilation, avoiding the need to re-push the string each time <samp class="SANS_Consolas_Regular_11">appendChar</samp> is called.</p>
<p class="STNI1"><b>Compiling Function Calls and Constructor Calls</b></p>
<p class="STNI1">The compiled version of calling a function or calling a constructor that has <i>n</i> arguments must (i) call <samp class="SANS_Consolas_Regular_11">compileExpressionList</samp>, which will call <samp class="SANS_Consolas_Regular_11">compileExpression</samp> <i>n</i> times, and (ii) make the call informing that <i>n</i> arguments were pushed onto the stack before the call.</p>
<p class="STNI1"><b>Compiling Method Calls</b></p>
<p class="STNI1">The compiled version of calling a method that has <i>n</i> arguments must (i) push a reference to the object on which the method is called to operate, (ii) call <samp class="SANS_Consolas_Regular_11">compileExpressionList</samp>, which will call <samp class="SANS_Consolas_Regular_11">compileExpression</samp> <i>n</i> times, and (iii) make the call, informing that <img alt="" class="inline" height="12" src="../images/11-3.png" width="30"/> arguments were pushed onto the stack before the call.</p>
<p class="STNI1"><b>Compiling</b> <samp class="SANS_Consolas_Bold_B_11">do</samp> <b>Statements</b></p>
<p class="STNI1">We recommend compiling <samp class="SANS_Consolas_Regular_11">do</samp> <i>subroutineCall</i> statements as if they were <samp class="SANS_Consolas_Regular_11">do</samp> <i>expression</i> statements, and then yanking the topmost stack value using <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">temp</samp> <samp class="SANS_Consolas_Regular_11">0</samp>.</p>
<p class="STNI1"><b>Compiling Classes</b></p>
<p class="STNI1">When starting to compile a class, the compiler creates a class-level symbol table and adds to it all the <i>field</i> and <i>static</i> variables declared in the class declaration. The compiler also creates an empty subroutine-level symbol table. No code is generated.</p>
<p class="STNI1"><b>Compiling Subroutines</b></p>
<ul class="List-1">
<li class="BLF">When starting to compile a subroutine (<i>constructor</i>, <i>function</i>, or <i>method</i>), the compiler initializes the subroutine’s symbol table. If the subroutine is a <i>method</i>, the compiler adds to the symbol table the mapping <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">this</samp>, <i>className</i>, <samp class="SANS_Consolas_Regular_11">arg</samp>, <samp class="SANS_Consolas_Regular_11">0</samp><span class="symb-code">&gt;</span>.</li>
<li class="BL1">Next, the compiler adds to the symbol table all the parameters, if any, declared in the subroutine’s parameter list. Next, the compiler handles all the <samp class="SANS_Consolas_Regular_11">var</samp> declarations, if any, by adding to the symbol table all the subroutine’s local variables.</li>
<li class="BL1"><span aria-label="234" id="pg_234" role="doc-pagebreak"/>At this stage the compiler starts generating code, beginning with the command <samp class="SANS_Consolas_Regular_11">function</samp> <i>className.subroutineName nVars</i>, where <i>nVars</i> is the number of local variables in the subroutine.</li>
<li class="BLL">If the subroutine is a <i>method</i>, the compiler generates the code <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>. This sequence aligns the virtual memory segment <samp class="SANS_Consolas_Regular_11">this</samp> with the base address of the object on which the method was called.</li>
</ul>
<p class="STNI1"><b>Compiling Constructors</b></p>
<ul class="List-1">
<li class="BLF">First, the compiler performs all the actions described in the previous section, ending with the generation of the command <samp class="SANS_Consolas_Regular_11">function</samp> <i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>constructorName nVars</i>.</li>
<li class="BL1">Next, the compiler generates the code <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <i>nFields</i>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Memory.alloc</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, where <i>nFields</i> is the number of fields in the compiled class. This results in allocating a memory block of <i>nFields</i> 16-bit words and aligning the virtual memory segment <samp class="SANS_Consolas_Regular_11">this</samp> with the base address of the newly allocated block.</li>
<li class="BL1">The compiled constructor must end with <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">return</samp>. This sequence returns to the caller the base address of the new object created by the constructor.</li>
</ul>
<p class="STNI1"><b>Compiling Void Methods and Void Functions</b></p>
<p class="STNI1">Every VM function is expected to push a value onto the stack before returning. When compiling a void Jack method or function, the convention is to end the generated code with <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">return</samp>.</p>
<p class="STNI1"><b>Compiling Arrays</b></p>
<p class="STNI1">Statements of the form <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">arr[</samp><i>expression</i>1<samp class="SANS_Consolas_Regular_11">]</samp> <span class="code_eq-symb">=</span> <i>expression</i>2 are compiled using the technique described at the end of section 11.1.6. <i>Implementation tip</i>: When handling arrays, there is never a need to use <samp class="SANS_Consolas_Regular_11">that</samp> entries whose index is greater than <samp class="SANS_Consolas_Regular_11">0</samp>.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The Operating System</b></h3>
<p class="noindent">Consider the high-level expression <img alt="" class="inline" height="14" src="../images/11-C18.png" width="230"/>. The compiler compiles it into the VM commands <samp class="SANS_Consolas_Regular_11">push</samp> <i>dx</i>, <samp class="SANS_Consolas_Regular_11">push</samp> <i>dx</i>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Math.multiply</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <i>dy</i>, <samp class="SANS_Consolas_Regular_11">push</samp> <i>dy</i>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Math.multiply</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>, <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">Math.sqrt</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, where <i>dx</i> and <i>dy</i> are the symbol table mappings of <samp class="SANS_Consolas_Regular_11">dx</samp> and <samp class="SANS_Consolas_Regular_11">dy</samp>. This example illustrates the two ways in which operating system services come into play during compilation. First, some high-level abstractions, like the expression <samp class="SANS_Consolas_Regular_11">x</samp> <samp class="SANS_Consolas_Regular_11">*</samp> <samp class="SANS_Consolas_Regular_11">y</samp>, are compiled by generating code that calls OS subroutines like <samp class="SANS_Consolas_Regular_11">Math.multiply</samp>. Second, when a Jack expression includes a high-level call to an OS routine, for example, <samp class="SANS_Consolas_Regular_11">Math.sqrt(x)</samp>, the compiler generates VM code that makes exactly the same call using VM postfix syntax.</p>
<p><span aria-label="235" id="pg_235" role="doc-pagebreak"/>The OS features eight classes, documented in appendix 6. Nand to Tetris provides two different implementations of this OS—<i>native</i> and <i>emulated</i>.</p>
<p class="STNI1"><b>Native OS Implementation</b></p>
<p class="STNI1">In project 12 you will develop the OS class library in Jack and compile it using a Jack compiler. The compilation will yield eight <samp class="SANS_Consolas_Regular_11">.vm</samp> files, comprising the native OS implementation. If you put these eight <samp class="SANS_Consolas_Regular_11">.vm</samp> files in the same folder that stores the <samp class="SANS_Consolas_Regular_11">.vm</samp> files resulting from the compilation of <i>any</i> Jack program, all the OS functions will become accessible to the compiled VM code since they belong to the same code base.</p>
<p class="STNI1"><b>Emulated OS Implementation</b></p>
<p class="STNI1">The supplied VM emulator, which is a Java program, features a Java-based implementation of the Jack OS. Whenever the VM code loaded into the emulator calls an OS function, the emulator checks whether a VM function by that name exists in the loaded code base. If so, it executes the VM function. Otherwise, it calls the built-in implementation of this OS function. The bottom line is this: If you use the supplied VM emulator for executing the VM code generated by your compiler, as we do in project 11, you need not worry about the OS configuration; the emulator will service all the OS calls without further ado.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>11.3.3    Software Architecture</b></h3>
<p class="noindent">The proposed compiler architecture builds upon the syntax analyzer described in chapter 10. Specifically, we propose to gradually evolve the syntax analyzer into a full-scale compiler, using the following modules:</p>
<ul class="List-1">
<li class="BLF"><samp class="SANS_Consolas_Regular_11">JackCompiler:</samp> main program, sets up and invokes the other modules</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">JackTokenizer:</samp> tokenizer for the Jack language</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">SymbolTable:</samp> keeps track of all the variables found in the Jack code</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">VMWriter:</samp> writes VM code</li>
<li class="BLL"><samp class="SANS_Consolas_Regular_11">CompilationEngine:</samp> recursive top-down compilation engine</li>
</ul>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The JackCompiler</b></h3>
<p class="noindent">This module drives the compilation process. It operates on either a file name of the form <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> or on a folder name containing one or more such files. For each source <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> file, the program</p>
<ol class="List-1">
<li class="NLF" value="1">creates a <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> from the <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> input file;</li>
<li class="NL">creates an output file named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp>; and</li>
<li class="NLL1"><span aria-label="236" id="pg_236" role="doc-pagebreak"/>uses a <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp>, a <samp class="SANS_Consolas_Regular_11">SymbolTable</samp>, and a <samp class="SANS_Consolas_Regular_11">VMWriter</samp> for parsing the input file and emitting the translated VM code into the output file.</li>
</ol>
<p class="TNI1">We provide no API for this module, inviting you to implement it as you see fit. Remember that the first routine that must be called when compiling a <samp class="SANS_Consolas_Regular_11">.jack</samp> file is <samp class="SANS_Consolas_Regular_11">compileClass</samp>.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The JackTokenizer</b></h3>
<p class="noindent">This module is identical to the tokenizer built in project 10. See the API in section 10.3.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The SymbolTable</b></h3>
<p class="noindent">This module provides services for building, populating, and using symbol tables that keep track of the symbol properties <i>name</i>, <i>type</i>, <i>kind</i>, and a running <i>index</i> for each kind. See <a href="chapter_11.xhtml#fig11-2">figure 11.2</a> for an example.</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_11.3.png"/></figure>
<p><i>Implementation note</i>: During the compilation of a Jack class file, the Jack compiler uses two instances of <samp class="SANS_Consolas_Regular_11">SymbolTable</samp>.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>The VMWriter</b></h3>
<p class="noindent">This module features a set of simple routines for writing VM commands into the output file.</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_11.4.png"/>
</figure>
</section>
<section epub:type="division">
<h3 class="head b-head"><span aria-label="237" id="pg_237" role="doc-pagebreak"/><b>The CompilationEngine</b></h3>
<p class="noindent">This module runs the compilation process. Although the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> API is almost identical the API presented in chapter 10, we repeat it here for ease of reference.</p>
<p>The <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> gets its input from a <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> and uses a <samp class="SANS_Consolas_Regular_11">VMWriter</samp> for writing the VM code output (instead of the XML produced in project 10). The output is generated by a series of <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routines, each designed to handle the compilation of a specific Jack language construct <i>xxx</i> (for example, <samp class="SANS_Consolas_Regular_11">compileWhile</samp> generates the VM code that realizes <samp class="SANS_Consolas_Regular_11">while</samp> statements). The contract between these routines is as follows: Each <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routine gets from the input and handles all the tokens that make up <i>xxx</i>, advances the tokenizer exactly beyond these tokens, and emits to the output VM code effecting the semantics of <i>xxx</i>. If <i>xxx</i> is a part of an expression, and thus has a value, the emitted VM code should compute this value and leave it at the top of the stack. As a rule, each <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routine is called only if the current token is <i>xxx</i>. Since the first token in a valid <samp class="SANS_Consolas_Regular_11">.jack</samp> file must be the keyword <samp class="SANS_Consolas_Regular_11">class</samp>, the compilation process starts by calling the routine <samp class="SANS_Consolas_Regular_11">compileClass</samp>.</p>
<span aria-label="238" id="pg_238" role="doc-pagebreak"/>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_11.5.png"/>
</figure>
<p class="STNI1"><b>Note:</b> The following Jack grammar rules have no corresponding compile xxx routines in the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp>: <i>type</i>, <i>className</i>, <i>subroutineName</i>, <i>varName</i>, <i>statement</i>, <i>subroutineCall</i>.</p>
<p class="STNI1"><span aria-label="239" id="pg_239" role="doc-pagebreak"/>The parsing logic of these rules should be handled by the routines that implement the rules that refer to them. The Jack language grammar is presented in section 10.2.1.</p>
<p class="STNI1"><b>Token lookahead</b>: The need for token lookahead, and the proposed solution for handling it, are discussed in section 10.3, just after the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> API.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>11.4    Project</b></h2>
<p class="noindent"><b>Objective</b>: Extend the syntax analyzer built in chapter 10 into a full-scale Jack compiler. Apply your compiler to all the test programs described below. Execute each translated program, and make sure that it operates according to its given documentation.</p>
<p>This version of the compiler assumes that the source Jack code is error-free. Error checking, reporting, and handling can be added to later versions of the compiler but are not part of project 11.</p>
<p class="STNI1"><b>Resources</b>: The main tool that you need is the programming language in which you will implement the compiler. You will also need the supplied VM emulator for testing the VM code generated by your compiler. Since the compiler is implemented by extending the syntax analyzer built in project 10, you will also need the analyzer’s source code.</p>
<section epub:type="division">
<h3 class="head b-head"><b>Implementation Stages</b></h3>
<p class="noindent">We propose morphing the syntax analyzer built in project 10 into the final compiler. In particular, we propose to gradually replace the routines that generate passive XML output with routines that generate executable VM code. This can be done in two main development stages.</p>
<p class="STNI1">(Stage 0: Make a backup copy of the syntax analyzer code developed in project 10.)</p>
<p class="STNI1"><b>Stage 1: Symbol table</b>: Start by building the compiler’s <samp class="SANS_Consolas_Regular_11">SymbolTable</samp> module, and use it for extending the syntax analyzer built in Project 10, as follows. Presently, whenever an identifier is encountered in the source code, say <samp class="SANS_Consolas_Regular_11">foo</samp>, the syntax analyzer outputs the XML line <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">identifier</samp><span class="symb-code">&gt;</span> <samp class="SANS_Consolas_Regular_11">foo</samp> <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">/identifier</samp><span class="symb-code">&gt;</span>. Instead, extend your syntax analyzer to output the following information about each identifier:</p>
<ul class="List-1">
<li class="BLF"><i>name</i></li>
<li class="BL1"><i>category</i> (<samp class="SANS_Consolas_Regular_11">field</samp>, <samp class="SANS_Consolas_Regular_11">static</samp>, <samp class="SANS_Consolas_Regular_11">var</samp>, <samp class="SANS_Consolas_Regular_11">arg</samp>, <samp class="SANS_Consolas_Regular_11">class</samp>, <samp class="SANS_Consolas_Regular_11">subroutine</samp>)</li>
<li class="BL1"><i>index</i>: if the identifier’s category is <samp class="SANS_Consolas_Regular_11">field</samp>, <samp class="SANS_Consolas_Regular_11">static</samp>, <samp class="SANS_Consolas_Regular_11">var</samp>, or <samp class="SANS_Consolas_Regular_11">arg</samp>, the running index assigned to the identifier by the symbol table</li>
<li class="BLL1"><span aria-label="240" id="pg_240" role="doc-pagebreak"/><i>usage</i>: whether the identifier is presently being <i>declared</i> (for example, the identifier appears in a <samp class="SANS_Consolas_Regular_11">static</samp> / <samp class="SANS_Consolas_Regular_11">field</samp> / <samp class="SANS_Consolas_Regular_11">var</samp> Jack variable declaration) or <i>used</i> (for example, the identifier appears in a Jack expression)</li>
</ul>
<p class="TNI1">Have your syntax analyzer output this information as part of its XML output, using markup tags of your choice.</p>
<p>Test your new <samp class="SANS_Consolas_Regular_11">SymbolTable</samp> module and the new functionality just described by running your extended syntax analyzer on the test Jack programs supplied in project 10. If your extended syntax analyzer outputs the information described above correctly it means that you’ve developed a complete executable capability to understand the semantics of Jack programs. At this stage you can make the switch to developing the full-scale compiler and start generating VM code instead of XML output. This can be done gradually, as we now turn to describe.</p>
<p class="STNI1">(Stage 1.5: Make a backup copy of the extended syntax analyzer code).</p>
<p class="STNI1"><b>Stage 2: Code generation</b>: We provide six application programs, designed to gradually unit-test the code generation capabilities of your Jack compiler. We advise developing, and testing, your evolving compiler on the test programs in the given order. This way, you will be implicitly guided to build the compiler’s code generation capabilities in sensible stages, according to the demands presented by each test program.</p>
<p>Normally, when one compiles a high-level program and runs into difficulties, one concludes that the program is screwed up. In this project the setting is exactly the opposite. All the supplied test programs are error-free. Therefore, if their compilation yields any errors, it’s the compiler that you have to fix, not the programs. Specifically, for each test program, we recommend going through the following routine:</p>
<ol class="List-1">
<li class="NLF" value="1">Compile the program folder using the compiler that you are developing. This action should generate one <samp class="SANS_Consolas_Regular_11">.vm</samp> file for each source <samp class="SANS_Consolas_Regular_11">.jack</samp> file in the given folder.</li>
<li class="NL">Inspect the generated VM files. If there are visible problems, fix your compiler and go to step 1. Remember: All the supplied test programs are error-free.</li>
<li class="NL">Load the program folder into the VM emulator, and run the loaded code. Note that each one of the six supplied test programs contains specific execution guidelines; test the compiled program (translated VM code) according to these guidelines.</li>
<li class="NL">If the program behaves unexpectedly, or if an error message is displayed by the VM emulator, fix your compiler and go to step 1.</li>
</ol>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>Test Programs</b></h3>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">Seven</samp>: Tests how the compiler handles a simple program containing an arithmetic expression with integer constants, a <samp class="SANS_Consolas_Regular_11">do</samp> statement, and a <samp class="SANS_Consolas_Regular_11">return</samp> statement. Specifically, the program computes the expression <img alt="" class="inline" height="14" src="../images/11-C19.png" width="65"/> and prints its value at the top left of the screen. To test <span aria-label="241" id="pg_241" role="doc-pagebreak"/>whether your compiler has translated the program correctly, run the translated code in the VM emulator, and verify that it displays <samp class="SANS_Consolas_Regular_11">7</samp> correctly.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">ConvertToBin</samp>: Tests how the compiler handles all the procedural elements of the Jack language: expressions (without arrays or method calls), functions, and the statements <samp class="SANS_Consolas_Regular_11">if</samp>, <samp class="SANS_Consolas_Regular_11">while</samp>, <samp class="SANS_Consolas_Regular_11">do</samp>, <samp class="SANS_Consolas_Regular_11">let</samp>, and <samp class="SANS_Consolas_Regular_11">return</samp>. The program does not test the handling of methods, constructors, arrays, strings, static variables, and field variables. Specifically, the program gets a 16-bit decimal value from <samp class="SANS_Consolas_Regular_11-SC">RAM[8000]</samp>, converts it to binary, and stores the individual bits in <samp class="SANS_Consolas_Regular_11-SC">RAM[8001</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">8016]</samp> (each location will contain <samp class="SANS_Consolas_Regular_11">0</samp> or <samp class="SANS_Consolas_Regular_11">1</samp>). Before the conversion starts, the program initializes <samp class="SANS_Consolas_Regular_11-SC">RAM[8001</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">8016]</samp> to <img alt="" class="inline" height="10" src="../images/11-C20.png" width="15"/>. To test whether your compiler has translated the program correctly, load the translated code into the VM emulator, and proceed as follows:</p>
<ul class="List-1">
<li class="BLF">Put (interactively, using the emulator’s GUI) some decimal value in <samp class="SANS_Consolas_Regular_11-SC">RAM[8000]</samp>.</li>
<li class="BL1">Run the program for a few seconds, then stop its execution.</li>
<li class="BLL">Check (by visual inspection) that memory locations <samp class="SANS_Consolas_Regular_11-SC">RAM[8001</samp><span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">8016]</samp> contain the correct bits and that none of them contains <img alt="" class="inline" height="10" src="../images/11-C21.png" width="15"/>.</li>
</ul>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Square</samp>: Tests how the compiler handles the object-based features of the Jack language: constructors, methods, fields, and expressions that include method calls. Does not test the handling of static variables. Specifically, this multiclass program stages a simple interactive game that enables moving a black square around the screen using the keyboard’s four arrow keys.</p>
<p>While moving, the size of the square can be increased and decreased by pressing the <samp class="SANS_Consolas_Regular_11">z</samp> and <samp class="SANS_Consolas_Regular_11">x</samp> keys, respectively. To quit the game, press the <samp class="SANS_Consolas_Regular_11">q</samp> key. To test whether your compiler has translated the program correctly, run the translated code in the VM emulator, and verify that the game works as expected.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Average</samp>: Tests how the compiler handles arrays and strings. This is done by computing the average of a user-supplied sequence of integers. To test whether your compiler has translated the program correctly, run the translated code in the VM emulator, and follow the instructions displayed on the screen.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Pong</samp>: A complete test of how the compiler handles an object-based application, including the handling of objects and static variables. In the classical Pong game, a ball is moving randomly, bouncing off the edges of the screen. The user tries to hit the ball with a small paddle that can be moved by pressing the keyboard’s left and right arrow keys. Each time the paddle hits the ball, the user scores a point and the paddle shrinks a little, making the game increasingly more challenging. If the user misses and the ball hits the bottom the game is over. To test whether your compiler has translated this program correctly, run the translated code in the VM emulator and play the game. Make sure to score some points to test the part of the program that displays the score on the screen.</p>
<p class="STNI1"><span aria-label="242" id="pg_242" role="doc-pagebreak"/><samp class="SANS_Consolas_Bold_B_11">ComplexArrays</samp>: Tests how the compiler handles complex array references and expressions. To that end, the program performs five complex calculations using arrays. For each such calculation, the program prints on the screen the expected result along with the result computed by the compiled program. To test whether your compiler has translated the program correctly, run the translated code in the VM emulator, and make sure that the expected and actual results are identical.</p>
<p class="STNI1"><b>A web-based version of project 11</b> is available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>11.5    Perspective</b></h2>
<p class="noindent">Jack is a general-purpose, object-based programming language. By design, it was made to be a relatively simple language. This simplicity allowed us to sidestep several thorny compilation issues. For example, while Jack looks like a typed language, that is hardly the case: all of Jack’s data types—<samp class="SANS_Consolas_Regular_11">int</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, and <samp class="SANS_Consolas_Regular_11">boolean</samp>—are 16 bits wide, allowing Jack compilers to ignore almost all type information. In particular, when compiling and evaluating expressions, Jack compilers need not determine their types. The only exception is the compilation of method calls of the form <samp class="SANS_Consolas_Regular_11">x.m()</samp>, which requires determining the class type of <samp class="SANS_Consolas_Regular_11">x</samp>. Another aspect of the Jack type simplicity is that array elements are not typed.</p>
<p>Unlike Jack, most programming languages feature rich type systems, which place additional demands on their compilers: different amounts of memory must be allocated for different types of variables; conversion from one type into another requires implicit and explicit casting operations; the compilation of a simple expression like <img alt="" class="inline" height="11" src="../images/11-C22.png" width="30"/> depends strongly on the types of <samp class="SANS_Consolas_Regular_11">x</samp> and <samp class="SANS_Consolas_Regular_11">y</samp>; and so on.</p>
<p>Another significant simplification is that the Jack language does not support <i>inheritance</i>. In languages that support inheritance, the handling of method calls like <samp class="SANS_Consolas_Regular_11">x.m()</samp> depends on the class membership of the object <samp class="SANS_Consolas_Regular_11">x</samp>, which can be determined only during run-time. Therefore, compilers of object-oriented languages that feature inheritance must treat all methods as virtual and resolve their class memberships according to the run-time type of the object on which the method is applied. Since Jack does not support inheritance, all method calls can be compiled statically during compile time.</p>
<p>Another common feature of object-oriented languages not supported by Jack is the distinction between private and public class members. In Jack, all static and field variables are private (recognized only within the class in which they are declared), and all subroutines are public (can be called from any class).</p>
<p>The lack of real typing, inheritance, and public fields allows a truly independent compilation of classes: a Jack class can be compiled without accessing the code of any other class. The fields of other classes are never referred to directly, and all linking to methods of other classes is “late” and done just by name.</p>
<p><span aria-label="243" id="pg_243" role="doc-pagebreak"/>Many other simplifications of the Jack language are not significant and can be relaxed with little effort. For example, one can easily extend the language with <samp class="SANS_Consolas_Regular_11">for</samp> and <samp class="SANS_Consolas_Regular_11">switch</samp> statements. Likewise, one can add the capability to assign character constants like <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">c</samp><samp class="SANS_Consolas_Regular_11">'</samp> to <samp class="SANS_Consolas_Regular_11">char</samp> type variables, which is presently not supported by the language.</p>
<p>Finally, our code generation strategies paid no attention to optimization. Consider the high-level statement <samp class="SANS_Consolas_Regular_11">c</samp><span class="symb-code">++</span>. A na<span class="dcrit">ï</span>ve compiler will translate it into the series of low-level VM operations <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">c</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">add</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">c</samp>. Next, the VM translator will translate each one of these VM commands further into several machine-level instructions, resulting in a considerable chunk of code. At the same time, an optimized compiler will notice that we are dealing with a simple increment and translate it into, say, the two machine instructions <samp class="SANS_Consolas_Regular_11">@c</samp> followed by <img alt="" class="inline" height="10" src="../images/11-C23.png" width="48"/> Of course, this is only one example of the finesse expected from industrial-strength compilers. In general, compiler writers invest much effort and ingenuity to ensure that the generated code is time- and space-efficient.</p>
<p>In Nand to Tetris, efficiency is rarely an issue, with one major exception: the operating system. The Jack OS is based on efficient algorithms and optimized data structures, as we’ll elaborate in the next chapter.</p>
</section>
</section>
</div>
</body>
</html>