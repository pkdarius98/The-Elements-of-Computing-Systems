<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>12 Operating System</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch12" epub:type="chapter" role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch12"><span aria-label="245" id="pg_245" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">12</samp>     <samp class="SANS_Helvetica_LT_Std_Bold_B_11">Operating System</samp></h1>
</header>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP1">Civilization progresses by extending the number of operations that we can perform without thinking about them.</p>
<p class="EPA1">—Alfred North Whitehead, <i>Introduction to Mathematics</i> (1911)</p>
</blockquote>
<p class="noindent">In chapters 1–6 we described and built a general-purpose hardware architecture. In chapters 7–11 we developed a software hierarchy that makes the hardware usable, culminating in the construction of a modern, object-based language. Other high-level programming languages can be specified and implemented on top of the hardware platform, each requiring its own compiler.</p>
<p>The last major piece missing in this puzzle is an <i>operating system</i>. The OS is designed to close gaps between the computer’s hardware and software, making the computer system more accessible to programmers, compilers, and users. For example, to display the text <samp class="SANS_Consolas_Regular_11">Hello</samp> <samp class="SANS_Consolas_Regular_11">World</samp> on the screen, several hundred pixels must be drawn at specific screen locations. This can be done by consulting the hardware specification and writing code that turns bits on and off in selected RAM locations. Clearly, high-level programmers expect a better interface. They want to write <samp class="SANS_Consolas_Regular_11">print</samp> <samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">Hello</samp> <samp class="SANS_Consolas_Regular_11">World</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp> and let someone else worry about the details. That’s where the operating system enters the picture.</p>
<p>Throughout this chapter, the term <i>operating system</i> is used rather loosely. Our OS is minimal, aiming at (i) encapsulating low-level hardware-specific services in high-level programmer-friendly software services and (ii) extending high-level languages with commonly used functions and abstract data types. The dividing line between an <i>operating system</i> in this sense and a <i>standard class library</i> is not clear. Indeed, modern programming languages pack many standard operating system services like graphics, memory management, multitasking, and numerous other extensions into what is known as the language’s <i>standard class library</i>. Following this model, the Jack OS is packaged as a collection of supporting classes, each providing a set of related services via Jack subroutine calls. The complete OS API is given in appendix 6.</p>
<p>High-level programmers expect the OS to deliver its services through well-designed interfaces that hide the gory hardware details from their application programs. To do so, the <span aria-label="246" id="pg_246" role="doc-pagebreak"/>OS code must operate close to the hardware, manipulating memory, input/output, and processing devices almost directly. Further, because the OS supports the execution of every program that runs on the computer, it must be highly efficient. For example, application programs create and dispose objects and arrays all the time. Therefore, we better do it quickly and economically. Any gain in the time- and space-efficiency of an enabling OS service can impact dramatically the performance of all the application programs that depend on it.</p>
<p>Operating systems are usually written in a high-level language and compiled into binary form. Our OS is no exception—it is written in Jack, just like Unix was written in C. Like the C language, Jack was designed with sufficient “lowness” in it, permitting an intimate closeness to the hardware when needed.</p>
<p>The chapter starts with a relatively long Background section that presents key algorithms normally used is OS implementations. These include mathematical operations, string manipulations, memory management, text and graphics output, and keyboard input. This algorithmic introduction is followed by a Specification section describing the Jack OS, and an Implementation section that offers guidance on how to build the OS using the algorithms presented. As usual, the Project section provides the necessary guidelines and materials for gradually constructing and unit-testing the entire OS.</p>
<p>The chapter embeds key lessons in system-oriented software engineering and in computer science. On the one hand, we describe programming techniques for developing low-level system services, as well as “programming at the large” techniques for integrating and streamlining the OS services. On the other hand, we present a set of elegant and highly efficient algorithms, each being a computer science gem.</p>
<section epub:type="division">
<h2 class="head a-head"><b>12.1    Background</b></h2>
<p class="noindent">Computers are typically connected to a variety of input/output devices such as a keyboard, screen, mouse, mass storage, network interface card, microphone, speakers, and more. Each of these I/O devices has its own electromechanical idiosyncrasies; thus, reading and writing data on them involves many technical details. High-level languages abstract away these details by offering high-level abstractions like <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">n</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Keyboard.readInt(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">Enter</samp> <samp class="SANS_Consolas_Regular_11">a</samp> <samp class="SANS_Consolas_Regular_11">number:</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp>. Let’s delve into what should be done in order to realize this seemingly simple data-entry operation.</p>
<p>First, we engage the user by displaying the prompt <samp class="SANS_Consolas_Regular_11">Enter</samp> <samp class="SANS_Consolas_Regular_11">a</samp> <samp class="SANS_Consolas_Regular_11">number:</samp>. This entails creating a <samp class="SANS_Consolas_Regular_11">String</samp> object and initializing it to the array of <samp class="SANS_Consolas_Regular_11">char</samp> values <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">E</samp><samp class="SANS_Consolas_Regular_11">'</samp>, <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">n</samp><samp class="SANS_Consolas_Regular_11">'</samp>, <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">t</samp><samp class="SANS_Consolas_Regular_11">'</samp>, <span class="ellipsis">…</span>, and so on. Next, we have to render this string on the screen, one character at a time, while updating the <i>cursor</i> position for keeping track of where the next character should be physically displayed. After displaying the <samp class="SANS_Consolas_Regular_11">Enter</samp> <samp class="SANS_Consolas_Regular_11">a</samp> <samp class="SANS_Consolas_Regular_11">number:</samp> prompt, we have to stage a loop that waits until the user will oblige to press some keys on the keyboard—hopefully keys that represent digits. This requires knowing how to (i) capture a keystroke, (ii) get a single <span aria-label="247" id="pg_247" role="doc-pagebreak"/>character input, (iii) append these characters to a string, and (iv) convert the string into an integer value.</p>
<p>If what has been elaborated so far sounds arduous, the reader should know that we were actually quite gentle, sweeping many gory details under the rug. For example, what exactly is meant by “creating a string object,” “displaying a character on the screen,” and “getting a multicharacter input”?</p>
<p>Let’s start with “creating a string object.” String objects don’t pop out of thin air, fully formed. Each time we want to create an object, we must find available space for representing the object in the RAM, mark this space as used, and remember to free it when the object is no longer needed. Proceeding to the “display a character” abstraction, note that characters cannot be displayed. The only things that can be physically displayed are individual pixels. Thus, we have to figure out what is the character’s <i>font</i>, compute where the bits that represent the font image can be found in the screen memory map, and then turn these bits on and off as needed. Finally, to “get a multicharacter input,” we have to enter a loop that not only listens to the keyboard and accumulates characters as they come along but also allows the user to backspace, delete, and retype characters, not to mention the need to echo each of these actions on the screen for visual feedback.</p>
<p>The agent that takes care of this elaborate behind-the-scenes work is the operating system. The execution of the statement <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">n</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Keyboard.readInt(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">Enter</samp> <samp class="SANS_Consolas_Regular_11">a</samp> <samp class="SANS_Consolas_Regular_11">number:</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp> entails many OS function calls, dealing with diverse issues like memory allocation, input driving, output driving, and string processing. Compilers use the OS services abstractly by injecting OS function calls into the compiled code, as we saw in the previous chapter. In this chapter we explore <i>how these functions are actually realized</i>. Of course, what we have surveyed so far is just a small subset of the OS responsibilities. For example, we didn’t mention mathematical operations, graphical output, and other commonly needed services. The good news is that a well-written OS can integrate these diverse and seemingly unrelated tasks in an elegant and efficient way, using cool algorithms and data structures. That’s what this chapter is all about.</p>
<section epub:type="division">
<h3 class="head b-head"><b>12.1.1    Mathematical Operations</b></h3>
<p class="noindent">The four arithmetic operations <i>addition</i>, <i>subtraction</i>, <i>multiplication</i>, and <i>division</i> lie at the core of almost every computer program. If a loop that executes a million times contains expressions that use some of these operations, they’d better be implemented efficiently.</p>
<p>Normally, addition is implemented in hardware, at the ALU level, and subtraction is gained freely, courtesy of the two’s complement method. Other arithmetic operations can be handled either by hardware or by software, depending on cost/performance considerations. We now turn to present efficient algorithms for computing multiplication, division, and square roots. These algorithms lend themselves to both software and hardware implementations.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><span aria-label="248" id="pg_248" role="doc-pagebreak"/><b>Efficiency First</b></h2>
<p class="noindent">Mathematical algorithms are made to operate on <i>n</i>-bit values, <i>n</i> typically being 16, 32, or 64 bits, depending on the operands’ data types. As a rule, we seek algorithms whose running time is a polynomial function of this word size <i>n</i>. Algorithms whose running time depends on the <i>values</i> of <i>n</i>-bit numbers are unacceptable, since these values are exponential in <i>n</i>. For example, suppose we implement the multiplication operation <i>x</i> <span class="symb">×</span> <i>y</i> na<span class="dcrit">ï</span>vely, using the repeated addition algorithm <samp class="SANS_Consolas_Regular_11">for</samp> <img alt="" class="inline" height="14" src="../images/12-C1.png" width="163"/> If <i>y</i> is 64-bit wide, its value may well be greater than 9,000,000,000,000,000,000, implying that the loop may run for billions of years before terminating.</p>
<p>In sharp contrast, the running times of the multiplication, division, and square root algorithms that we present below depend not to the <i>n</i>-bit <i>values</i> on which they are called to operate, which may be as large as 2<i><sup>n</sup></i>, but rather on <i>n</i>, the number of their bits. When it comes to efficiency of arithmetic operations, that’s the best that we can possibly hope for.</p>
<p>We will use the <i>Big-O</i> notation, <i>O</i> (<i>n</i>), to describe a running time which is “in the order of magnitude of <i>n</i>.” The running time of all the arithmetic algorithms that we present in this chapter is <i>O</i> (<i>n</i>), where <i>n</i> is the bit width of the inputs.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>Multiplication</b></h2>
<p class="noindent">Consider the standard multiplication method taught in elementary school. To compute 356 times 73, we line up the two numbers one on top of the other, right-justified. Next, we multiply 356 by 3. Next, we shift 356 to the left one position, and multiply 3560 by 7 (which is the same as multiplying 356 by 70). Finally, we sum up the columns and obtain the result. This procedure is based on the insight that <img alt="" class="inline" height="12" src="../images/12-1.png" width="200"/> The binary version of this procedure is illustrated in <a href="chapter_12.xhtml#fig12-1" id="rfig12-1">figure 12.1</a>, using another example.</p>
<figure class="IMG"><img alt="" id="fig12-1" src="../images/figure_12.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-1">Figure 12.1</a></b>    Multiplication algorithm.</p></figcaption>
</figure>
<p class="STNI1"><span aria-label="249" id="pg_249" role="doc-pagebreak"/><b>Notation note</b>: The algorithms presented in this chapter are written in a self-explanatory pseudocode syntax. We use indentation to mark blocks of code, obviating the need for curly brackets or begin/end keywords. For example, in <a href="chapter_12.xhtml#fig12-1">figure 12.1</a>, <img alt="" class="inline" height="15" src="../images/12-2.png" width="138"/> belongs to the single-statement body of the <samp class="SANS_Consolas_Regular_11">if</samp> logic, and <img alt="" class="inline" height="15" src="../images/12-3.png" width="141"/> ends the two-statement body of the <samp class="SANS_Consolas_Regular_11">for</samp> logic.</p>
<p>Let’s inspect the multiplication procedure illustrated at the left of <a href="chapter_12.xhtml#fig12-1">figure 12.1</a>. For each <i>i</i>-th bit of <i>y</i>, we shift <i>x i</i> times to the left (same as multiplying <i>x</i> by 2<i><sup>i</sup></i>). Next, we look at the <i>i</i>-th bit of <i>y</i>: If it is 1, we add the shifted <i>x</i> to an accumulator; otherwise, we do nothing. The algorithm shown on the right formalizes this procedure. Note that 2 * <i>shiftedx</i> can be computed efficiently either by left-shifting the bitwise representation of <i>shiftedx</i> or by adding <i>shiftedx</i> to itself. Either operation lends itself to primitive hardware operations.</p>
<p class="STNI1"><b>Running time</b>: The multiplication algorithm performs <i>n</i> iterations, where <i>n</i> is the bit width of the <i>y</i> input. In each iteration, the algorithm performs a few addition and comparison operations. It follows that the total running time of the algorithm is <img alt="" class="inline" height="14" src="../images/12-4.png" width="55"/> where <i>a</i> is the time it takes to initialize a few variables, and <i>b</i> is the time it takes to perform a few addition and comparison operations. Formally, the algorithm’s running time is <i>O</i> (<i>n</i>), where <i>n</i> is the bit width of the inputs.</p>
<p>To reiterate, the running time of this <img alt="" class="inline" height="12" src="../images/12-5.png" width="33"/> algorithm does not depend on the <i>values</i> of the <i>x</i> and <i>y</i> inputs; rather, it depends on the <i>bit width</i> of the inputs. In computers, the bit width is normally a small fixed constant like 16 (<samp class="SANS_Consolas_Regular_11">short</samp>), 32 (<samp class="SANS_Consolas_Regular_11">int</samp>), or 64 (<samp class="SANS_Consolas_Regular_11">long</samp>), depending on the data types of the inputs. In the Hack platform, the bit width of all data types is 16. If we assume that each iteration of the multiplication algorithm entails about ten Hack machine instructions, it follows that each multiplication operation will require at most 160 clock cycles, irrespective of the size of the inputs. In contrast, algorithms whose running time is proportional not to the bit width but rather to the values of the inputs will require <img alt="" class="inline" height="15" src="../images/12-6.png" width="115"/> clock cycles.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>Division</b></h2>
<p class="noindent">The na<span class="dcrit">ï</span>ve way to compute the division of two <i>n</i>-bit numbers <i>x</i> / <i>y</i> is to count how many times <i>y</i> can be subtracted from <i>x</i> until the remainder becomes less than <i>y</i>. The running time of this algorithm is proportional to the value of the dividend <i>x</i> and thus is unacceptably exponential in the number of bits <i>n</i>.</p>
<p>To speed things up, we can try to subtract large chunks of <i>y’</i>s from <i>x</i> in each iteration. For example, suppose we have to divide 175 by 3. We start by asking: What is the largest number, <img alt="" class="inline" height="14" src="../images/12-7.png" width="173"/> so that <img alt="" class="inline" height="12" src="../images/12-8.png" width="72"/> The answer is 50. In other words, we managed to subtract fifty 3’s from 175, shaving fifty iterations from the na<span class="dcrit">ï</span>ve approach. This accelerated subtraction leaves a remainder of <img alt="" class="inline" height="12" src="../images/12-9.png" width="110"/> Moving along, we now ask: What is the largest number, <img alt="" class="inline" height="14" src="../images/12-10.png" width="124"/> so that <img alt="" class="inline" height="12" src="../images/12-11.png" width="66"/> The answer is 8, so <span aria-label="250" id="pg_250" role="doc-pagebreak"/>we managed to make eight additional subtractions of 3, and the answer, so far, is <img alt="" class="inline" height="12" src="../images/12-12.png" width="76"/>The remainder is <img alt="" class="inline" height="14" src="../images/12-13.png" width="84"/> which is less than 3, so we stop the process and announce that <img alt="" class="inline" height="12" src="../images/12-14.png" width="70"/> with a remainder of 1.</p>
<p>This technique is the rationale behind the dreaded school procedure known as <i>long division</i>. The binary version of this algorithm is identical, except that instead of accelerating the subtraction using powers of 10 we use powers of 2. The algorithm performs <i>n</i> iterations, <i>n</i> being the number of digits in the dividend, and each iteration entails a few multiplication (actually, shifting), comparison, and subtraction operations. Once again, we have an <img alt="" class="inline" height="15" src="../images/12-15.png" width="23"/>algorithm whose running time does not depend on the values of <i>x</i> and <i>y</i>. Rather, the running time is <i>O</i> (<i>n</i>), where <i>n</i> is the bit width of the inputs.</p>
<p>Writing down this algorithm as we have done for multiplication is an easy exercise. To make things interesting, <a href="chapter_12.xhtml#fig12-2" id="rfig12-2">figure 12.2</a> presents another division algorithm which is as efficient, but more elegant and easier to implement.</p>
<figure class="IMG"><img alt="" id="fig12-2" src="../images/figure_12.2.png" width="523"/>
<figcaption><p class="CAP"><b><a href="#rfig12-2">Figure 12.2</a></b>    Division algorithm.</p></figcaption>
</figure>
<p>Suppose we have to divide 480 by 17. The algorithm shown in <a href="chapter_12.xhtml#fig12-2">figure 12.2</a> is based on the insight <img alt="" class="inline" height="14" src="../images/12-16.png" width="427"/> and so on. The depth of this recursion is bounded by the number of times <i>y</i> can be multiplied by 2 before reaching <i>x</i>. This also happens to be, at most, the number of bits required to represent <i>x</i>. Thus, the running time of this algorithm is <i>O</i> (<i>n</i>), where <i>n</i> is the bit width of the inputs.</p>
<p>One snag in this algorithm is that each multiplication operation also requires <i>O</i> (<i>n</i>) operations. However, an inspection of the algorithm’s logic reveals that the value of the expression <img alt="" class="inline" height="15" src="../images/12-17.png" width="63"/> can be computed without multiplication. Instead, it can be obtained from its value in the previous recursion level, using addition.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>Square Root</b></h2>
<p class="noindent">Square roots can be computed efficiently in a number of different ways, for example, using the Newton-Raphson method or a Taylor series expansion. For our purpose, though, a simpler algorithm will suffice. The square root function <img alt="" class="inline" height="18" src="../images/Ch12_IEQ_001.png" width="46"/> has two attractive properties. First, it is monotonically increasing. Second, its inverse function, <img alt="" class="inline" height="16" src="../images/12-18.png" width="44"/> is a function <span aria-label="251" id="pg_251" role="doc-pagebreak"/>that we already know how to compute efficiently—multiplication. Taken together, these properties imply that we have all we need to compute square roots efficiently, using a form of <i>binary search</i>. <a href="chapter_12.xhtml#fig12-3" id="rfig12-3">Figure 12.3</a> gives the details.</p>
<figure class="IMG"><img alt="" id="fig12-3" src="../images/figure_12.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-3">Figure 12.3</a></b>    Square root algorithm.</p></figcaption>
</figure>
<p>Since the number of iterations in the binary search that the algorithm performs is bound by <i>n</i> / 2 where <i>n</i> is the number of bits in <i>x</i>, the algorithm’s running time is <i>O</i> (<i>n</i>).</p>
<p class="STNI1">To sum up this section about mathematical operations, we presented algorithms for computing multiplication, division, and square root. The running time of each of the algorithms is <i>O</i> (<i>n</i>), where <i>n</i> is the bit width of the inputs. We also observed that in computers, <i>n</i> is a small constant like 16, 32, or 64. Therefore, every addition, subtraction, multiplication, and division operation can be carried out swiftly, in a predictable time that is unaffected by the magnitude of the inputs.</p>
<section epub:type="division">
<h3 class="head b-head"><b>12.1.2    Strings</b></h3>
<p class="noindent">In addition to primitive data types, most programming languages feature a <i>string</i> type designed to represent sequences of characters like <samp class="SANS_Consolas_Regular_11">"Loading game</samp> <span class="ellipsis">…</span><samp class="SANS_Consolas_Regular_11">"</samp> and <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">QUIT</samp><samp class="SANS_Consolas_Regular_11">"</samp>. Typically, the string abstraction is supplied by a <samp class="SANS_Consolas_Regular_11">String</samp> class that is part of the standard class library that supports the language. This is also the approach taken by Jack.</p>
<p>All the string constants that appear in Jack programs are implemented as <samp class="SANS_Consolas_Regular_11">String</samp> objects. The <samp class="SANS_Consolas_Regular_11">String</samp> class, whose API is documented in appendix 6, features various string processing methods like appending a character to the string, deleting the last character, and so on. These services are not difficult to implement, as we’ll describe later in the chapter. The more challenging <samp class="SANS_Consolas_Regular_11">String</samp> methods are those that convert integer values to strings and strings of digit characters to integer values. We now turn to discuss algorithms that carry out these operations.</p>
<p class="STNI1"><b>String representation of numbers</b>: Computers represent numbers internally using binary codes. Yet humans are used to dealing with numbers that are written in decimal notation. Thus, when humans have to read or input numbers, <i>and only then</i>, a conversion to or from <span aria-label="252" id="pg_252" role="doc-pagebreak"/>decimal notation must be performed. When such numbers are captured from an input device like a keyboard, or rendered on an output device like a screen, they are cast as strings of characters, each representing one of the digits 0 to 9. The subset of relevant characters is:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_12.1.png"/></figure>
<p class="TNI1">(The complete Hack character set is given in appendix 5). We see that digit characters can be easily converted into the integers that they represent, and vice versa. The integer value of character <i>c</i>, where <img alt="" class="inline" height="14" src="../images/12-19.png" width="76"/> is <img alt="" class="inline" height="12" src="../images/12-20.png" width="44"/> Conversely, the character code of the integer <i>x</i>, where <img alt="" class="inline" height="14" src="../images/12-21.png" width="61"/> is <img alt="" class="inline" height="12" src="../images/12-22.png" width="45"/></p>
<p>Once we know how to handle single-digit characters, we can develop algorithms for converting any integer into a string and any string of digit characters into the corresponding integer. These conversion algorithms can be based on either iterative or recursive logic, so <a href="chapter_12.xhtml#fig12-4" id="rfig12-4">figure 12.4</a> presents one of each.</p>
<figure class="IMG"><img alt="" id="fig12-4" src="../images/figure_12.4.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-4">Figure 12.4</a></b>    String-integer conversions. (<samp class="SANS_Consolas_Regular_11">appendChar</samp>, <samp class="SANS_Consolas_Regular_11">length</samp>, and <samp class="SANS_Consolas_Regular_11">charAt</samp> are <samp class="SANS_Consolas_Regular_11">String</samp> class methods.)</p></figcaption>
</figure>
<p>It is easy to infer from <a href="chapter_12.xhtml#fig12-4">figure 12.4</a> that the running times of the <samp class="SANS_Consolas_Regular_11">int2String</samp> and <samp class="SANS_Consolas_Regular_11">string2Int</samp> algorithms are <i>O</i> (<i>n</i>), where <i>n</i> is the number of the digit-characters in the input.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>12.1.3    Memory Management</b></h3>
<p class="noindent">Each time a program creates a new array or a new object, a memory block of a certain size must be allocated for representing the new array or object. And when the array or object is no longer needed, its RAM space may be recycled. These chores are done by two classical OS functions called <samp class="SANS_Consolas_Regular_11">alloc</samp> and <samp class="SANS_Consolas_Regular_11">deAlloc</samp>. These functions are used by compilers when generating low-level code for handling constructors and destructors, as well as by high-level programmers, as needed.</p>
<p><span aria-label="253" id="pg_253" role="doc-pagebreak"/>The memory blocks for representing arrays and objects are carved from, and recycled back into, a designated RAM area called a <i>heap</i>. The agent responsible for managing this resource is the operating system. When the OS starts running, it initializes a pointer named <samp class="SANS_Consolas_Regular_11">heapBase</samp>, containing the heap’s base address in the RAM (in Jack, the heap starts just after the stack’s end, with <img alt="" class="inline" height="14" src="../images/12-C2.png" width="114"/> We’ll present two heap management algorithms: basic and improved.</p>
<p class="STNI1"><b>Memory allocation algorithm (basic)</b>: The data structure that this algorithm manages is a single pointer, named <samp class="SANS_Consolas_Regular_11">free</samp>, which points to the beginning of the heap segment that was not yet allocated. See <a href="chapter_12.xhtml#fig12-5a" id="rfig12-5a">figure 12.5a</a> for the details.</p>
<figure class="IMG"><img alt="" id="fig12-5a" src="../images/figure_12.5a.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-5a">Figure 12.5a</a></b>    Memory allocation algorithm (basic).</p></figcaption>
</figure>
<p>The basic heap management scheme is clearly wasteful, as it never reclaims any memory space. But, if your application programs use only a few small objects and arrays, and not too many strings, you may get away with it.</p>
<p class="STNI1"><b>Memory allocation algorithm (improved)</b>: This algorithm manages a linked list of available memory segments, called <samp class="SANS_Consolas_Regular_11">freeList</samp> (see <a href="chapter_12.xhtml#fig12-5b" id="rfig12-5b">figure 12.5b</a>). Each segment in the list begins with two housekeeping fields: the segment’s <i>length</i> and a pointer to the <i>next</i> segment in the list.</p>
<figure class="IMG"><img alt="" height="550" id="fig12-5b" src="../images/figure_12.5b.png"/>
<figcaption><p class="CAP"><b><a href="#rfig12-5b">Figure 12.5b</a></b>    Memory allocation algorithm (improved).</p></figcaption>
</figure>
<p>When asked to allocate a memory block of a given size, the algorithm has to search the <samp class="SANS_Consolas_Regular_11">freeList</samp> for a suitable segment. There are two heuristics for doing this search. <i>Best-fit</i> finds the shortest segment that is long enough for representing the required size, while <i>first-fit</i> finds the first segment that is long enough. Once a suitable segment has been found, the required memory block is carved from it (the location just before the beginning of the returned block, <samp class="SANS_Consolas_Regular_11">block[</samp><span class="symb">−</span><samp class="SANS_Consolas_Regular_11">1]</samp>, is reserved to hold its length, to be used during deallocation).</p>
<p>Next, the <i>length</i> of this segment is updated in the <samp class="SANS_Consolas_Regular_11">freeList</samp>, reflecting the length of the part that remained after the allocation. If no memory was left in the segment, or if the remaining part is practically too small, the entire segment is eliminated from the <samp class="SANS_Consolas_Regular_11">freeList</samp>.</p>
<p>When asked to reclaim the memory block of an unused object, the algorithm appends the deallocated block to the end of the <samp class="SANS_Consolas_Regular_11">freeList</samp>.</p>
<p><span aria-label="254" id="pg_254" role="doc-pagebreak"/>Dynamic memory allocation algorithms like the one shown in <a href="chapter_12.xhtml#fig12-5b">figure 12.5b</a> may create block fragmentation problems. Hence, a <i>defragmentation</i> operation should be considered, that is, merging memory areas that are physically adjacent in memory but logically split into different segments in the <samp class="SANS_Consolas_Regular_11">freeList</samp>. The defragmentation can be done each time an object is deallocated, when <samp class="SANS_Consolas_Regular_11">alloc()</samp> fails to find a block of the requested size, or according to some other, periodical ad hoc condition.</p>
<p class="STNI1"><b>Peek and poke</b>: We end the discussion of memory management with two simple OS functions that have nothing to do with resource allocation. <samp class="SANS_Consolas_Regular_11">Memory.peek(</samp><i>addr</i><samp class="SANS_Consolas_Regular_11">)</samp> returns the value of the RAM at address <i>addr</i>, and <samp class="SANS_Consolas_Regular_11">Memory.poke(</samp><i>addr</i><samp class="SANS_Consolas_Regular_11">,</samp><i>value</i><samp class="SANS_Consolas_Regular_11">)</samp> sets the word in RAM address <i>addr</i> to <i>value</i>. These functions play a role in various OS services that manipulate the memory, including graphics routines, as we now turn to discuss.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><span aria-label="255" id="pg_255" role="doc-pagebreak"/><b>12.1.4    Graphical Output</b></h3>
<p class="noindent">Modern computers render graphical output like animation and video on high-resolution color screens, using optimized graphics drivers and dedicated graphical processing units (GPUs). In Nand to Tetris we abstract away most of this complexity, focusing instead on fundamental graphics-drawing algorithms and techniques.</p>
<p>We assume that the computer is connected to a physical black-and-white screen arranged as a grid of rows and columns, and at the intersection of each lies a pixel. By convention, the columns are numbered from left to right and the rows are numbered from top to bottom. Thus pixel (0,0) is located at the screen’s top-left corner.</p>
<p>We assume that the screen is connected to the computer system through a <i>memory map</i>—a dedicated RAM area in which each pixel is represented by one bit. The screen is refreshed from this memory map many times per second by a process that is external to the computer. Programs that simulate the computer’s operations are expected to emulate this refresh process.</p>
<p>The most basic operation that can be performed on the screen is drawing an individual pixel specified by (<i>x,y</i>) coordinates. This is done by turning the corresponding bit in the memory map on or off. Other operations like drawing a line and drawing a circle are built on top of this basic operation. The graphics package maintains a <i>current color</i> that can be set to <i>black</i> or <i>white</i>. All the drawing operations use the current color.</p>
<p class="STNI1"><b>Pixel drawing (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">drawPixel</samp>)</b>: Drawing a selected pixel in screen location (<i>x</i>,<i>y</i>) is achieved by locating the corresponding bit in the memory map and setting it to the current color. Since the RAM is an <i>n</i>-bit device, this operation requires reading and writing an <i>n</i>-bit value. See <a href="chapter_12.xhtml#fig12-6" id="rfig12-6">figure 12.6</a>.</p>
<figure class="IMG"><img alt="" id="fig12-6" src="../images/figure_12.6.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-6">Figure 12.6</a></b>    Drawing a pixel.</p></figcaption>
</figure>
<p>The memory map interface of the Hack screen is specified in section 5.2.4. This mapping should be used in order to realize the <samp class="SANS_Consolas_Regular_11">drawPixel</samp> algorithm.</p>
<p class="STNI1"><span aria-label="256" id="pg_256" role="doc-pagebreak"/><b>Line drawing (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">drawLine</samp>)</b>: When asked to render a continuous “line” between two “points” on a grid made of discrete pixels, the best that we can possibly do is approximate the line by drawing a series of pixels along the imaginary line connecting the two points. The “pen” that we use for drawing the line can move in four directions only: up, down, left, and right. Thus, the drawn line is bound to be jagged, and the only way to make it look good is to use a high-resolution screen with the tiniest possible pixels. Note, though, that the human eye, being yet another machine, also has a limited image-capturing capacity, determined by the number and type of receptor cells in the retina. Thus, high-resolution screens can fool the human brain to believe that the lines made of pixels are visibly smooth. In fact they are always jagged.</p>
<p>The procedure for drawing a line from (<i>x</i>1,<i>y</i>1) to (<i>x</i>2,<i>y</i>2) starts by drawing the (<i>x</i>1,<i>y</i>1) pixel and then zigzagging in the direction of (<i>x</i>2,<i>y</i>2) until that pixel is reached. See <a href="chapter_12.xhtml#fig12-7" id="rfig12-7">figure 12.7</a>.</p>
<figure class="IMG"><img alt="" id="fig12-7" src="../images/figure_12.7.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-7">Figure 12.7</a></b>    Line-drawing algorithm: basic version (bottom, left) and improved version (bottom, right).</p></figcaption>
</figure>
<p>The use of two division operations in each loop iteration makes this algorithm neither efficient nor accurate. The first obvious improvement is replacing the <img alt="" class="inline" height="15" src="../images/12-23.png" width="91"/> condition with the equivalent <img alt="" class="inline" height="15" src="../images/12-24.png" width="88"/> which requires only integer multiplication. Careful inspection of the latter condition reveals that it may be checked without any multiplication. <span aria-label="257" id="pg_257" role="doc-pagebreak"/>As shown in the improved algorithm in <a href="chapter_12.xhtml#fig12-7">figure 12.7</a>, this may be done efficiently by maintaining a variable that updates the value of <img alt="" class="inline" height="15" src="../images/12-25.png" width="95"/> each time <i>a</i> or <i>b</i> is incremented.</p>
<p>The running time of this line-drawing algorithm is <i>O</i>(<i>n</i>), where <i>n</i> is the number of pixels along the drawn line. The algorithm uses only addition and subtraction operations and can be implemented efficiently in either software or hardware.</p>
<p class="STNI1"><b>Circle drawing (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">drawCircle</samp>)</b>: <a href="chapter_12.xhtml#fig12-8" id="rfig12-8">Figure 12.8</a> presents an algorithm that uses three routines that we’ve already implemented: multiplication, square root, and line drawing.</p>
<figure class="IMG"><img alt="" height="550" id="fig12-8" src="../images/figure_12.8.png"/>
<figcaption><p class="CAP"><b><a href="#rfig12-8">Figure 12.8</a></b>    Circle-drawing algorithm.</p></figcaption>
</figure>
<p>The algorithm is based on drawing a sequence of horizontal lines (like the typical line <i>ab</i> in the figure), one for each row in the range <img alt="" class="inline" height="13" src="../images/12-26.png" width="87"/> Since <i>r</i> is specified in pixels, the algorithm ends up drawing a line in every row along the circle’s north-south diameter, resulting in a completely filled circle. A simple tweak can cause this algorithm to draw only the circle’s outline, if so desired.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><span aria-label="258" id="pg_258" role="doc-pagebreak"/><b>12.1.5    Character Output</b></h3>
<p class="noindent">To develop a capability for displaying characters, we first turn our physical, pixel-oriented screen into a logical, character-oriented screen suitable for rendering fixed, bitmapped images that represent characters. For example, consider a physical screen that features 256 rows of 512 pixels each. If we allocate a grid of 11 rows by 8 columns for drawing a single character, then our screen can display 23 lines of 64 characters each, with 3 extra rows of pixels left unused.</p>
<p class="STNI1"><b>Fonts</b>: The character sets that computers use are divided into <i>printable</i> and <i>non-printable</i> subsets. For each printable character in the Hack character set (see appendix 5), an 11-row-by-8-column bitmap image was designed, to the best of our limited artistic abilities. Taken together, these images are called a <i>font</i>. <a href="chapter_12.xhtml#fig12-9" id="rfig12-9">Figure 12.9</a> shows how our font renders the uppercase letter <samp class="SANS_Consolas_Regular_11">N</samp>. To handle character spacing, each character image includes at least a 1-pixel space before the next character in the row and at least a 1-pixel space between adjacent rows (the exact spacing varies with the size and squiggles of individual characters). The Hack font consists of ninety-five such bitmap images, one for each printable character in the Hack character set.</p>
<figure class="IMG"><img alt="" height="550" id="fig12-9" src="../images/figure_12.9.png"/>
<figcaption><p class="CAP"><b><a href="#rfig12-9">Figure 12.9</a></b>    Example of a character bitmap.</p></figcaption>
</figure>
<p>Font design is an ancient yet vibrant art. The oldest fonts are as old as the art of writing, and new ones are routinely introduced by type designers who wish to make an artistic statement or solve a technical or functional objective. In our case, the small physical screen, on the one hand, and the wish to display a reasonable number of characters in each row, on the <span aria-label="259" id="pg_259" role="doc-pagebreak"/>other, led to the pragmatic choice of a frugal image area of <img alt="" class="inline" height="12" src="../images/12-27.png" width="37"/> pixels. This economy forced us to design a crude font, which nonetheless serves its purpose well.</p>
<p class="STNI1"><b>Cursor</b>: Characters are usually displayed one after the other, from left to right, until the end of the line is reached. For example, consider a program in which the statement <samp class="SANS_Consolas_Regular_11">print(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">a</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp> is followed (perhaps not immediately) by the statement <samp class="SANS_Consolas_Regular_11">print</samp> <samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">b</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp>. This implies that the program wants to display <samp class="SANS_Consolas_Regular_11">ab</samp> on the screen. To effect this continuity, the character-writing package maintains a global <i>cursor</i> that keeps track of the screen location where the next character should be drawn. The cursor information consists of column and row counts, say, <samp class="SANS_Consolas_Regular_11">cursor.col</samp> and <samp class="SANS_Consolas_Regular_11">cursor.row</samp>. After a character has been displayed, we do <samp class="SANS_Consolas_Regular_11">cursor.col</samp><span class="symb-code">++</span>. At the end of the row we do <samp class="SANS_Consolas_Regular_11">cursor.row</samp><span class="symb-code">++</span> and <samp class="SANS_Consolas_Regular_11">cursor.col</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">0</samp>. When the bottom of the screen is reached, there is a question of what to do next. Two possible actions are effecting a scrolling operation or clearing the screen and starting over by setting the cursor to <samp class="SANS_Consolas_Regular_11">(0,0)</samp>.</p>
<p>To recap, we described a scheme for writing individual characters on the screen. Writing other types of data follows naturally from this basic capability: strings are written character by character, and numbers are first converted to strings and then written as strings.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>12.1.6    Keyboard Input</b></h3>
<p class="noindent">Capturing inputs that come from the keyboard is more intricate than meets the eye. For example, consider the statement <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">name</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Keyboard.readLine(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">enter</samp> <samp class="SANS_Consolas_Regular_11">your</samp> <samp class="SANS_Consolas_Regular_11">name:</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp>. By definition, the execution of the <samp class="SANS_Consolas_Regular_11">readLine</samp> function depends on the dexterity and collaboration of an unpredictable entity: a human user. The function will not terminate until the user has pressed some keys on the keyboard, ending with an <samp class="SANS_Consolas_Regular_11">ENTER</samp>. The problem is that humans press and release keyboard keys for variable and unpredictable durations of time, and often take a coffee break in the middle. Also, humans are fond of backspacing, deleting, and retyping characters. The implementation of the <samp class="SANS_Consolas_Regular_11">readLine</samp> function must handle all these irregularities.</p>
<p>This section describes how keyboard input is managed, in three levels of abstraction: (i) detecting which key is currently pressed on the keyboard, (ii) capturing a single-character input, and (iii) capturing a multicharacter input.</p>
<p class="STNI1"><b>Detecting keyboard input (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">keyPressed</samp>)</b>: Detecting which key is presently pressed is a hardware-specific operation that depends on the keyboard interface. In the Hack computer, the keyboard continuously refreshes a 16-bit memory register whose address is kept in a pointer named <samp class="SANS_Consolas_Regular_11">KBD</samp>. The interaction contract is as follows: If a key is currently pressed on the keyboard, that address contains the key’s character code (the Hack character set is given in appendix 5); otherwise, it contains 0. This contract is used for implementing the <samp class="SANS_Consolas_Regular_11">keyPressed</samp> function shown in <a href="chapter_12.xhtml#fig12-10" id="rfig12-10">figure 12.10</a>.</p>
<figure class="IMG"><img alt="" id="fig12-10" src="../images/figure_12.10.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-10">Figure 12.10</a></b>    Handling input from the keyboard.</p></figcaption>
</figure>
<p class="STNI1"><span aria-label="260" id="pg_260" role="doc-pagebreak"/><b>Reading a single character (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">readChar</samp>)</b>: The elapsed time between the <i>key pressed</i> and the subsequent <i>key released</i> events is unpredictable. Hence, we have to write code that neutralizes this uncertainty. Also, when users press keys on the keyboard, we want to give feedback as to which keys have been pressed (something that you have probably grown to take for granted). Typically, we want to display some graphical cursor at the screen location where the next input goes, and, after some key has been pressed, we want to echo the inputted character by displaying its bitmap on the screen at the cursor location. All these actions are implemented by the <samp class="SANS_Consolas_Regular_11">readChar</samp> function.</p>
<p class="STNI1"><b>Reading a string (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">readLine</samp>)</b>: A multicharacter input typed by the user is considered final after the <samp class="SANS_Consolas_Regular_11">ENTER</samp> key has been pressed, yielding the <samp class="SANS_Consolas_Regular_11">newLine</samp> character. Until the <samp class="SANS_Consolas_Regular_11">ENTER</samp> key is pressed, the user should be allowed to backspace, delete, and retype previously typed characters. All these actions are accommodated by the <samp class="SANS_Consolas_Regular_11">readLine</samp> function.</p>
<p>As usual, our input-handling solutions are based on a cascading series of abstractions: The high-level program relies on the <samp class="SANS_Consolas_Regular_11">readLine</samp> abstraction, which relies on the <samp class="SANS_Consolas_Regular_11">readChar</samp> abstraction, which relies on the <samp class="SANS_Consolas_Regular_11">keyPressed</samp> abstraction, which relies on the <samp class="SANS_Consolas_Regular_11">Memory.peek</samp> abstraction, which relies on the hardware.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><span aria-label="261" id="pg_261" role="doc-pagebreak"/><b>12.2    The Jack OS Specification</b></h2>
<p class="noindent">The previous section presented algorithms that address various classical operating system tasks. In this section we turn to formally specify one particular operating system—the Jack OS. The Jack operating system is organized in eight classes:</p>
<ul class="List-1">
<li class="BLF"><samp class="SANS_Consolas_Regular_11">Math</samp>: provides mathematical operations</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">String</samp>: implements the <samp class="SANS_Consolas_Regular_11">String</samp> type</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">Array</samp>: implements the <samp class="SANS_Consolas_Regular_11">Array</samp> type</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">Memory</samp>: handles memory operations</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">Screen</samp>: handles graphics output to the screen</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">Output</samp>: handles character output to the screen</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">Keyboard</samp>: handles input from the keyboard</li>
<li class="BLL1"><samp class="SANS_Consolas_Regular_11">Sys</samp>: provides execution-related services</li>
</ul>
<p>The complete OS API is given in appendix 6. This API can be viewed as the OS specification. The next section describes how this API can be implemented using the algorithms presented in the previous section.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>12.3    Implementation</b></h2>
<p class="noindent">Each OS class is a collection of subroutines (constructors, functions, and methods). Most of the OS subroutines are simple to implement and are not discussed here. The remaining OS subroutines are based on the algorithms presented in section 12.2. The implementation of these subroutines can benefit from some tips and guidelines, which we now turn to present.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Init</samp> <b>functions</b>: Some OS classes use data structures that support the implementation of some of their subroutines. For each such <i>OSClass</i>, these data structures can be declared statically at the class level and initialized by a fucntion which, by convention, we call <i>OSClass</i><samp class="SANS_Consolas_Regular_11">.init</samp>. The <samp class="SANS_Consolas_Regular_11">init</samp> functions are for internal purposes and are not documented in the OS API.</p>
<section epub:type="division">
<h3 class="head b-head"><b>Math</b></h3>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">multiply</samp>: In each iteration <i>i</i> of the <i>multiplication</i> algorithm (see <a href="chapter_12.xhtml#fig12-1">figure 12.1</a>), the <i>i</i>-th bit of the second multiplicand is extracted. We suggest encapsulating this operation in a helper function <samp class="SANS_Consolas_Regular_11">bit</samp> <samp class="SANS_Consolas_Regular_11">(x,i)</samp> that returns <samp class="SANS_Consolas_Regular_11">true</samp> if the <samp class="SANS_Consolas_Regular_11">i</samp>-th bit of the integer <samp class="SANS_Consolas_Regular_11">x</samp> is 1, and <samp class="SANS_Consolas_Regular_11">false</samp> otherwise. The <samp class="SANS_Consolas_Regular_11">bit(x,i)</samp> function can be easily implemented using shifting operations. Alas, <span aria-label="262" id="pg_262" role="doc-pagebreak"/>Jack does not support shifting. Instead, it may be convenient to define a fixed static array of length 16, say <samp class="SANS_Consolas_Regular_11">twoToThe</samp>, and set each element <i>i</i> to 2 raised to the power of <i>i</i>. The array can then be used to support the implementation of <samp class="SANS_Consolas_Regular_11">bit</samp> <samp class="SANS_Consolas_Regular_11">(x,i)</samp>. The <samp class="SANS_Consolas_Regular_11">twoToThe</samp> array can be built by the <samp class="SANS_Consolas_Regular_11">Math.init</samp> function.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">divide</samp>: The <i>multiplication</i> and <i>division</i> algorithms presented in <a href="chapter_12.xhtml#fig12-1">figures 12.1</a> and <a href="chapter_12.xhtml#fig12-2">12.2</a> are designed to operate on nonnegative integers. Signed numbers can be handled by applying the algorithms to absolute values and setting the sign of the return values appropriately. For the multiplication algorithm, this is not needed: since the multiplicands are given in two’s complement, their product will be correct with no further ado.</p>
<p>In the <i>division</i> algorithm, <i>y</i> is multiplied by a factor of 2, until <i>y</i> <span class="symb">&gt;</span> <i>x</i>. Thus <i>y</i> can overflow. The overflow can be detected by checking when <i>y</i> becomes negative.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">sqrt</samp>: In the <i>square root</i> algorithm (<a href="chapter_12.xhtml#fig12-3">figure 12.3</a>), the calculation of <img alt="" class="inline" height="16" src="../images/Ch12_IEQ_002.png" width="56"/> can overflow, resulting in an abnormally negative result. This problem can be addressed by changing efficiently the algorithm’s if logic to: if <img alt="" class="inline" height="16" src="../images/Ch12_IEQ_003.png" width="82"/> and <img alt="" class="inline" height="16" src="../images/Ch12_IEQ_004.png" width="82"/> then <img alt="" class="inline" height="16" src="../images/Ch12_IEQ_005.png" width="63"/>.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>String</b></h3>
<p class="noindent">All the string constants that appear in a Jack program are realized as objects of the <samp class="SANS_Consolas_Regular_11">String</samp> class, whose API is documented in appendix 6. Specifically, each string is implemented as an object consisting of an array of <samp class="SANS_Consolas_Regular_11">char</samp> values, a <samp class="SANS_Consolas_Regular_11">maxLength</samp> property that holds the maximum length of the string, and a <samp class="SANS_Consolas_Regular_11">length</samp> property that holds the actual length of the string.</p>
<p>For example, consider the statement <img alt="" class="inline" height="14" src="../images/12-C3.png" width="128"/> When the compiler handles this statement, it calls the <samp class="SANS_Consolas_Regular_11">String</samp> constructor, which creates a <samp class="SANS_Consolas_Regular_11">char</samp> array with <img alt="" class="inline" height="14" src="../images/12-C4.png" width="92"/> and <img alt="" class="inline" height="14" src="../images/12-C5.png" width="70"/> If we later call the <samp class="SANS_Consolas_Regular_11">String</samp> method <samp class="SANS_Consolas_Regular_11">str.eraseLastChar()</samp>, the <samp class="SANS_Consolas_Regular_11">length</samp> of the array will become 5, and the string will effectively become <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">scoob</samp><samp class="SANS_Consolas_Regular_11">"</samp>. In general, then, array elements beyond <samp class="SANS_Consolas_Regular_11">length</samp> are not considered part of the string.</p>
<p>What should happen when an attempt is made to add a character to a string whose <samp class="SANS_Consolas_Regular_11">length</samp> equals <samp class="SANS_Consolas_Regular_11">maxLength</samp>? This issue is not defined by the OS specification: the <samp class="SANS_Consolas_Regular_11">String</samp> class may act gracefully and resize the array—or not; this is left to the discretion of individual OS implementations.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">intValue,</samp> <samp class="SANS_Consolas_Bold_B_11">setInt</samp>: These subroutines can be implemented using the algorithms presented in <a href="chapter_12.xhtml#fig12-4">figure 12.4</a>. Note that neither algorithm handles negative numbers—a detail that must be handled by the implementation.</p>
<p class="STNI1-NEW"><samp class="SANS_Consolas_Bold_B_11">newLine, backSpace, doubleQuote</samp>: As seen in appendix 5, the codes of these characters are 128, 129, and 34.</p>

<p>The remaining <samp class="SANS_Consolas_Regular_11">String</samp> methods can be implemented straightforwardly by operating on the <samp class="SANS_Consolas_Regular_11">char</samp> array and on the <samp class="SANS_Consolas_Regular_11">length</samp> field that characterizes each <samp class="SANS_Consolas_Regular_11">String</samp> object.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><span aria-label="263" id="pg_263" role="doc-pagebreak"/><b>Array</b></h3>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">new</samp>: In spite of its name, this subroutine is not a constructor but rather a function. Therefore, the implementation of this function must allocate memory space for the new array by explicitly calling the OS function <samp class="SANS_Consolas_Regular_11">Memory.alloc</samp>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">dispose</samp>: This void method is called by statements like <samp class="SANS_Consolas_Regular_11">do</samp> <samp class="SANS_Consolas_Regular_11">arr.dispose()</samp>. The <samp class="SANS_Consolas_Regular_11">dispose</samp> implementation deallocates the array by calling the OS function <samp class="SANS_Consolas_Regular_11">Memory.deAlloc</samp>.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>Memory</b></h3>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">peek,</samp> <samp class="SANS_Consolas_Bold_B_11">poke</samp>: These functions provide direct access to the host memory. How can this low-level access be accomplished using the Jack high-level language? As it turns out, the Jack language includes a trapdoor that enables gaining complete control of the host computer’s memory. This trapdoor can be exploited for implementing <samp class="SANS_Consolas_Regular_11">Memory.peek</samp> and <samp class="SANS_Consolas_Regular_11">Memory.poke</samp> using plain Jack programming.</p>
<p>The trick is based on an anomalous use of a reference variable (pointer). Jack is a weakly typed language; among other quirks, it does not prevent the programmer from assigning a constant to a reference variable. This constant can then be treated as an absolute memory address. When the reference variable happens to be an array, this scheme provides indexed access to every word in the host RAM. See <a href="chapter_12.xhtml#fig12-11" id="rfig12-11">figure 12.11</a>.</p>
<figure class="IMG"><img alt="" id="fig12-11" src="../images/figure_12.11.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-11">Figure 12.11</a></b>    A trapdoor enabling complete control of the host RAM from Jack.</p></figcaption>
</figure>
<p>Following the first two lines of code, the base of the <samp class="SANS_Consolas_Regular_11">memory</samp> array points to the first address in the computer’s RAM (address <samp class="SANS_Consolas_Regular_11">0</samp>). To get or set the value of the RAM location whose physical address is <i>i</i>, all we have to do is manipulate the array element <samp class="SANS_Consolas_Regular_11">memory[</samp><i>i</i><samp class="SANS_Consolas_Regular_11">]</samp>. This will cause the compiler to manipulate the RAM location whose address is <img alt="" class="inline" height="14" src="../images/12-28.png" width="33"/> which is what we want.</p>
<p>Jack arrays are not allocated space on the heap at compile-time but rather at run-time, if and when the array’s <samp class="SANS_Consolas_Regular_11">new</samp> function is called. Note that if new were a constructor and not a function, the compiler and the OS would have allocated the <samp class="SANS_Consolas_Regular_11">new</samp> array to some obscure address in the <span aria-label="264" id="pg_264" role="doc-pagebreak"/>RAM that we cannot control. Like many classical hacks, this trick works because we use the array variable without initializing it properly, as is normally done when using arrays.</p>
<p>The <samp class="SANS_Consolas_Regular_11">memory</samp> array can be declared at the class level and initialized by the <samp class="SANS_Consolas_Regular_11">Memory.init</samp> function. Once this hack is done, the implementation of <samp class="SANS_Consolas_Regular_11">Memory.peek</samp> and <samp class="SANS_Consolas_Regular_11">Memory.poke</samp> becomes trivial.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">alloc,</samp> <samp class="SANS_Consolas_Bold_B_11">deAlloc</samp>: These functions can be implemented by either one of the algorithms shown in <a href="chapter_12.xhtml#fig12-5a">figures 12.5a</a> and <a href="chapter_12.xhtml#fig12-5b">12.5b</a>. Either <i>best-fit</i> or <i>first-fit</i> can be used for implementing <samp class="SANS_Consolas_Regular_11">Memory.deAlloc</samp>.</p>
<p>The standard VM mapping on the Hack platform (see section 7.4.1) specifies that the <i>stack</i> be mapped on RAM addresses 256 to 2047. Thus the <i>heap</i> can start at address 2048.</p>
<p>In order to realize the <samp class="SANS_Consolas_Regular_11">freeList</samp> linked list, the <samp class="SANS_Consolas_Regular_11">Memory</samp> class can declare and maintain a static variable, <samp class="SANS_Consolas_Regular_11">freeList</samp>, as seen in <a href="chapter_12.xhtml#fig12-12" id="rfig12-12">figure 12.12</a>. Although <samp class="SANS_Consolas_Regular_11">freeList</samp> is initialized to the value of <samp class="SANS_Consolas_Regular_11">heapBase</samp> (2048), it is possible that following several <samp class="SANS_Consolas_Regular_11">alloc</samp> and <samp class="SANS_Consolas_Regular_11">deAlloc</samp> operations <samp class="SANS_Consolas_Regular_11">freeList</samp> will become some other address in memory, as illustrated in the figure.</p>
<figure class="IMG"><img alt="" id="fig12-12" src="../images/figure_12.12.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig12-12">Figure 12.12</a></b>    Logical view (left) and physical implementation (right) of a linked list that supports dynamic memory allocation.</p></figcaption>
</figure>
<p>For efficiency’s sake, it is recommended to write Jack code that manages the <samp class="SANS_Consolas_Regular_11">freeList</samp> linked list directly in the RAM, as seen in <a href="chapter_12.xhtml#fig12-12">figure 12.12</a>. The linked list can be initialized by the <samp class="SANS_Consolas_Regular_11">Memory.init</samp> function.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>Screen</b></h3>
<p class="noindent">The <samp class="SANS_Consolas_Regular_11">Screen</samp> class maintains a <i>current color</i> that is used by all the drawing functions of the class. The current color can be represented by a static Boolean variable.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">drawPixel</samp>: Drawing a pixel on the screen can be done using <samp class="SANS_Consolas_Regular_11">Memory.peek</samp> and <samp class="SANS_Consolas_Regular_11">Memory.poke</samp>. The screen memory map of the Hack platform specifies that the pixel at column <i>col</i> and row <i>row</i> <img alt="" class="inline" height="14" src="../images/12-29.png" width="194"/> is mapped to the <i>col</i> % 16 bit of memory location <img alt="" class="inline" height="12" src="../images/12-30.png" width="170"/> Drawing a single pixel requires changing a single bit in the accessed word (and that bit only).</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">drawLine</samp>: The basic algorithm in <a href="chapter_12.xhtml#fig12-7">figure 12.7</a> can potentially lead to overflow. However, the algorithm’s improved version eliminates the problem.</p>
<p>Some aspects of the algorithm should be generalized for drawing lines that extend to four possible directions. Be reminded that the screen origin (coordinates (0,0)) is at the top-left corner. Therefore, some of the directions and plus/minus operations specified in the algorithm should be modified by your <samp class="SANS_Consolas_Regular_11">drawLine</samp> implementation.</p>
<p>The special yet frequent cases of drawing straight lines, that is, when <img alt="" class="inline" height="12" src="../images/12-31.png" width="41"/> or <img alt="" class="inline" height="15" src="../images/12-32.png" width="44"/>should not be handled by this algorithm. Rather, they should benefit from a separate and optimized implementation.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">drawCircle</samp>: The algorithm shown in <a href="chapter_12.xhtml#fig12-8">figure 12.8</a> can potentially lead to overflow. Limiting circle radii to be at most 181 is a reasonable solution.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><span aria-label="265" id="pg_265" role="doc-pagebreak"/><b>Output</b></h3>
<p class="noindent">The <samp class="SANS_Consolas_Regular_11">Output</samp> class is a library of functions for displaying characters. The class assumes a character-oriented screen consisting of 23 rows (indexed 0 <span class="ellipsis">…</span> 22, top to bottom) of 64 characters each (indexed 0 <span class="ellipsis">…</span> 63, left to right). The top-left character location on the screen is indexed (0,0). A visible cursor, implemented as a small filled square, indicates where the next character will be displayed. Each character is displayed by rendering on the screen a rectangular image, 11 pixels high and 8 pixels wide (which includes margins for character spacing and line spacing). The collection of all the character images is called a <i>font</i>.</p>
<p class="STNI1"><b>Font implementation</b>: The design and implementation of a font for the Hack character set (appendix 5) is a drudgery, combining artistic judgment and rote implementation work. The resulting font is a collection of ninety-five rectangular bitmap images, each representing a printable character.</p>
<p><span aria-label="266" id="pg_266" role="doc-pagebreak"/>Fonts are normally stored in external files that are loaded and used by the character-drawing package, as needed. In Nand to Tetris, the font is embedded in the OS <samp class="SANS_Consolas_Regular_11">Output</samp> class. For each printable character, we define an array that holds the character’s bitmap. The array consists of 11 elements, each corresponding to a row of 8 pixels. Specifically, we set the value of each array entry <i>j</i> to an integer value whose binary representation (bits) codes the 8 pixels appearing in the <i>j</i>-th row of the character’s bitmap. We also define a static array of size 127, whose index values 32 <span class="ellipsis">…</span> 126 correspond to the codes of the printable characters in the Hack character set (entries 0 <span class="ellipsis">…</span> 31 are not used). We then set each array entry <i>i</i> of that array to the 11-entry array that represents the bitmap image of the character whose character code is <i>i</i> (did we mention drudgery?).</p>
<p>The project 12 materials include a skeletal <samp class="SANS_Consolas_Regular_11">Output</samp> class containing Jack code that carries out all the implementation work described above. The given code implements the ninety-five-character font, except for one character, whose design and implementation is left as an exercise. This code can be activated by the <samp class="SANS_Consolas_Regular_11">Output.init</samp> function, which can also initialize the cursor.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">printChar</samp>: Displays the character at the cursor location and advances the cursor one column forward. To display a character at location (<i>row</i>,<i>col</i>), where <img alt="" class="inline" height="14" src="../images/12-33.png" width="194"/> we write the character’s bitmap onto the box of pixels ranging from <img alt="" class="inline" height="12" src="../images/12-34.png" width="150"/> and from <img alt="" class="inline" height="12" src="../images/12-35.png" width="123"/></p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">printString</samp>: Can be implemented using a sequence of <samp class="SANS_Consolas_Regular_11">printChar</samp> calls.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">printInt</samp>: Can be implemented by converting the integer to a string and then printing the string.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>Keyboard</b></h3>
<p class="noindent">The Hack computer memory organization (see section 5.2.6) specifies that the <i>keyboard memory map</i> is a single 16-bit memory register located at address 24576.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">keyPressed</samp>: Can be implemented easily using <samp class="SANS_Consolas_Regular_11">Memory.peek</samp> <samp class="SANS_Consolas_Regular_11">()</samp>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">readChar,</samp> <samp class="SANS_Consolas_Bold_B_11">readString</samp>: Can be implemented by following the algorithms in <a href="chapter_12.xhtml#fig12-10">figure 12.10</a>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">readInt</samp>: Can be implemented by reading a string and converting it into an <samp class="SANS_Consolas_Regular_11">int</samp> value using a <samp class="SANS_Consolas_Regular_11">String</samp> method.</p>
</section>
<section epub:type="division">
<h3 class="head b-head"><b>Sys</b></h3>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">wait</samp>: This function is supposed to wait a given number of milliseconds and return. It can be implemented by writing a loop that runs approximately <samp class="SANS_Consolas_Regular_11">duration</samp> milliseconds before <span aria-label="267" id="pg_267" role="doc-pagebreak"/>terminating. You will have to time your specific computer to obtain a one millisecond wait, as this constant varies from one CPU to another. As a result, your <samp class="SANS_Consolas_Regular_11">Sys.wait()</samp> function will not be portable. The function can be made portable by running yet another configuration function that sets various constants reflecting the hardware specifications of the host platform, but for Nand to Tetris this is not needed.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">halt</samp>: Can be implemented by entering an infinite loop.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">init</samp>: According to the Jack language specification (see section 9.2.2), a Jack program is a set of one or more classes. One class must be named <samp class="SANS_Consolas_Regular_11">Main</samp>, and this class must include a function named <samp class="SANS_Consolas_Regular_11">main</samp>. To start running a program, the <samp class="SANS_Consolas_Regular_11">Main.main</samp> function should be called.</p>
<p>The operating system is also a collection of compiled Jack classes. When the computer boots up, we want to start running the operating system and have <i>it</i> start running the main program. This chain of command is implemented as follows. According to the Standard VM Mapping on the Hack Platform (section 8.5.2), the VM translator writes bootstrap code (in machine language) that calls the OS function <samp class="SANS_Consolas_Regular_11">Sys.init</samp>. This bootstrap code is stored in the ROM, starting at address 0. When we reset the computer, the program counter is set to 0, the bootstrap code starts running, and the <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function is called.</p>
<p>With that in mind, <samp class="SANS_Consolas_Regular_11">Sys.init</samp> should do two things: call all the <samp class="SANS_Consolas_Regular_11">init</samp> functions of the other OS classes, and then call <samp class="SANS_Consolas_Regular_11">Main.main</samp>.</p>
<p>From this point onward the user is at the mercy of the application program, and the Nand to Tetris journey has come to an end. We hope that you enjoyed the ride!</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>12.4    Project</b></h2>
<p class="noindent"><b>Objective</b>: Implement the operating system described in the chapter.</p>
<p class="STNI1"><b>Contract</b>: Implement the operating system in Jack, and test it using the programs and testing scenarios described below. Each test program uses a subset of OS services. Each of the OS classes can be implemented and unit-tested in isolation, in any order.</p>
<p class="STNI1"><b>Resources</b>: The main required tool is Jack—the language in which you will develop the OS. You will also need the supplied Jack compiler for compiling your OS implementation, as well as the supplied test programs, also written in Jack. Finally, you’ll need the supplied VM emulator, which is the platform on which the tests will be executed.</p>
<p>Your <samp class="SANS_Consolas_Regular_11">projects/12</samp> folder includes eight skeletal OS class files named <samp class="SANS_Consolas_Regular_11">Math.jack</samp>, <samp class="SANS_Consolas_Regular_11">String.jack</samp>, <samp class="SANS_Consolas_Regular_11">Array.jack</samp>, <samp class="SANS_Consolas_Regular_11">Memory.jack</samp>, <samp class="SANS_Consolas_Regular_11">Screen.jack</samp>, <samp class="SANS_Consolas_Regular_11">Output.jack</samp>, <samp class="SANS_Consolas_Regular_11">Keyboard.jack</samp>, and <samp class="SANS_Consolas_Regular_11">Sys.jack</samp>. Each file contains the signatures of all the class subroutines. Your task is completing the missing implementations.</p>
<p class="STNI1"><span aria-label="268" id="pg_268" role="doc-pagebreak"/><b>The VM emulator</b>: Operating system developers often face the following chicken-and-egg dilemma: How can we possibly test an OS class in isolation, if the class uses the services of other OS classes not yet developed? As it turns out, the VM emulator is perfectly positioned to support unit-testing the OS, one class at a time.</p>
<p>Specifically, the VM emulator features an executable version of the OS, written in Java. When a VM command <samp class="SANS_Consolas_Regular_11">call</samp> <samp class="SANS_Consolas_Regular_11">foo</samp> is found in the loaded VM code, the emulator proceeds as follows. If a VM function named <samp class="SANS_Consolas_Regular_11">foo</samp> exists in the loaded code base, the emulator executes its VM code. Otherwise, the emulator checks whether <samp class="SANS_Consolas_Regular_11">foo</samp> is one of the built-on OS functions. If so, it executes <samp class="SANS_Consolas_Regular_11">foo</samp>’s built-in implementation. This convention is ideally suited for supporting the testing strategy that we now turn to describe.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>Testing Plan</b></h2>
<p class="noindent">Your <samp class="SANS_Consolas_Regular_11">projects/12</samp> folder includes eight test folders, named <samp class="SANS_Consolas_Regular_11">MathTest</samp>, <samp class="SANS_Consolas_Regular_11">MemoryTest</samp>, <span class="ellipsis">…</span>, for testing each one the eight OS classes <samp class="SANS_Consolas_Regular_11">Math</samp>, <samp class="SANS_Consolas_Regular_11">Memory</samp>, <span class="ellipsis">…</span>. Each folder contains a Jack program, designed to test (by using) the services of the corresponding OS class. Some folders contain test scripts and compare files, and some contain only a <samp class="SANS_Consolas_Regular_11">.jack</samp> file or files. To test your implementation of the OS class <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp>, you may proceed as follows:</p>
<ul class="List-1">
<li class="BLF">Inspect the supplied <i>Xxx</i><samp class="SANS_Consolas_Regular_11">Test/*.jack</samp> code of the test program. Understand which OS services are tested and how they are tested.</li>
<li class="BL1">Put the OS class <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> that you developed in the <i>Xxx</i><samp class="SANS_Consolas_Regular_11">Test</samp> folder.</li>
<li class="BL1">Compile the folder using the supplied Jack compiler. This will result in translating both your OS class file and the <samp class="SANS_Consolas_Regular_11">.jack</samp> file or files of the test program into corresponding <samp class="SANS_Consolas_Regular_11">.vm</samp> files, stored in the same folder.</li>
<li class="BL1">If the folder includes a <samp class="SANS_Consolas_Regular_11">.tst</samp> test script, load the script into the VM emulator; otherwise, load the folder into the VM emulator.</li>
<li class="BLL1">Follow the specific testing guidelines given below for each OS class.</li>
</ul>
<p class="TNI1"><samp class="SANS_Consolas_Bold_B_11">Memory,</samp> <samp class="SANS_Consolas_Bold_B_11">Array,</samp> <samp class="SANS_Consolas_Bold_B_11">Math</samp>: The three folders that test these classes include test scripts and compare files. Each test script begins with the command <samp class="SANS_Consolas_Regular_11">load</samp>. This command loads all the <samp class="SANS_Consolas_Regular_11">.vm</samp> files in the current folder into the VM emulator. The next two commands in each test script create an output file and load the supplied compare file. Next, the test script proceeds to execute several tests, comparing the test results to those listed in the compare file. Your job is making sure that these comparisons end successfully.</p>
<p><span aria-label="269" id="pg_269" role="doc-pagebreak"/>Note that the supplied test programs don’t comprise a full test of <samp class="SANS_Consolas_Regular_11">Memory.alloc</samp> and <samp class="SANS_Consolas_Regular_11">Memory.deAlloc</samp>. A complete test of these memory management functions requires inspecting internal implementation details not visible in user-level testing. If you want to do so, you can test these functions by using step-by-step debugging and by inspecting the state of the host RAM.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">String</samp>: Execution of the supplied test program should yield the following output:</p>
<figure class="IMG-L"><img alt="" class="img70" src="../images/figure_12.13.png"/></figure>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Output</samp>: Execution of the supplied test program should yield the following output:</p>
<figure class="IMG-L"><img alt="" class="img70" src="../images/figure_12.14.png"/></figure>
<p class="STNI1"><span aria-label="270" id="pg_270" role="doc-pagebreak"/><samp class="SANS_Consolas_Bold_B_11">Screen</samp>: Execution of the supplied test program should yield the following output:</p>
<figure class="IMG-L"><img alt="" class="img70" src="../images/figure_12.15.png"/></figure>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Keyboard</samp>: This OS class is tested by a test program that effects user-program interaction. For each function in the <samp class="SANS_Consolas_Regular_11">Keyboard</samp> class (<samp class="SANS_Consolas_Regular_11">keyPressed</samp>, <samp class="SANS_Consolas_Regular_11">readChar</samp>, <samp class="SANS_Consolas_Regular_11">readLine</samp>, <samp class="SANS_Consolas_Regular_11">readInt</samp>) the program prompts the user to press some keys. If the OS function is implemented correctly and the requested keys are pressed, the program prints <samp class="SANS_Consolas_Regular_11">ok</samp> and proceeds to test the next OS function. Otherwise, the program repeats the request. If all requests end successfully, the program prints <samp class="SANS_Consolas_Regular_11">Test</samp> <samp class="SANS_Consolas_Regular_11">ended</samp> <samp class="SANS_Consolas_Regular_11">successfully</samp>. At this point the screen should show the following output:</p>
<figure class="IMG-L"><img alt="" class="img70" src="../images/figure_12.16.png"/></figure>
<section epub:type="division">
<h3 class="head b-head"><span aria-label="271" id="pg_271" role="doc-pagebreak"/><b>Sys</b></h3>
<p class="noindent">The supplied <samp class="SANS_Consolas_Regular_11">.jack</samp> file tests the <samp class="SANS_Consolas_Regular_11">Sys.wait</samp> function. The program requests the user to press a key (any key) and waits two seconds, using a call to <samp class="SANS_Consolas_Regular_11">Sys.wait</samp>. It then prints a message on the screen. Make sure that the time that elapses between your release of the key and the appearance of the printed message is about two seconds.</p>
<p>The <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function is not tested explicitly. However, recall that it performs all the necessary OS initializations and then calls the <samp class="SANS_Consolas_Regular_11">Main.main</samp> function of each test program. Therefore, we can assume that nothing will work properly unless <samp class="SANS_Consolas_Regular_11">Sys.init</samp> is implemented correctly.</p>
</section>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>Complete Test</b></h2>
<p class="noindent">After testing successfully each OS class in isolation, test your entire OS implementation using the Pong game introduced earlier in the book. The source code of Pong is available in <samp class="SANS_Consolas_Regular_11">projects/11/Pong</samp>. Put your eight OS <samp class="SANS_Consolas_Regular_11">.jack</samp> files in the <samp class="SANS_Consolas_Regular_11">Pong</samp> folder, and compile the folder using the supplied Jack compiler. Next, load the <samp class="SANS_Consolas_Regular_11">Pong</samp> folder into the VM emulator, execute the game, and ensure that it works as expected.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>12.5    Perspective</b></h2>
<p class="noindent">This chapter presented a subset of basic services that can be found in most operating systems. For example, managing memory, driving I/O devices, supplying mathematical operations not implemented in hardware, and implementing abstract data types like the string abstraction. We have chosen to call this standard software library an <i>operating system</i> to reflect its two main functions: encapsulating the gory hardware details, omissions, and idiosyncrasies in transparent software services, and enabling compilers and application programs to use these services via clean interfaces. However, the gap between what we have called an OS and industrial-strength operating systems remains wide.</p>
<p>For starters, our OS lacks some of the basic services most closely associated with operating systems. For example, our OS supports neither multi-threading nor multiprocessing; in contrast, the kernel of most operating systems is devoted to exactly that. Our OS supports no mass storage devices; in contrast, the main data store handled by operating systems is a file system abstraction. Our OS features neither a command-line interface (as in a Unix shell) nor a graphical interface consisting of windows and menus. In contrast, this is the operating system interface that users expect to see and interact with. Numerous other services commonly found in operating systems are not present in our OS, like security, communication, and more.</p>
<p><span aria-label="272" id="pg_272" role="doc-pagebreak"/>Another notable difference lies in the liberal way in which our OS operations are invoked. Some OS operations, for example, <samp class="SANS_Consolas_Regular_11">peek</samp> and <samp class="SANS_Consolas_Regular_11">poke</samp>, give the programmer complete access to the host computer resources. Clearly, inadvertent or malicious use of such functions can cause havoc. Therefore, many OS services are considered privileged, and accessing them requires a security mechanism that is more elaborate than a simple function call. In contrast, in the Hack platform, there is no difference between OS code and user code, and operating system services run in the same user mode as that of application programs.</p>
<p>In terms of efficiency, the algorithms that we presented for multiplication and division were standard. These algorithms, or variants thereof, are typically implemented in hardware rather than in software. The running time of these algorithms is <i>O</i> (<i>n</i>) addition operations. Since adding two <i>n</i>-bit numbers requires <i>O</i> (<i>n</i>) bit operations (gates in hardware), these algorithms end up requiring <i>O</i> (<i>n</i><small>2</small>) bit operations. There exist multiplication and division algorithms whose running time is asymptotically significantly faster than <i>O</i> (<i>n</i><small>2</small>), and for a large number of bits these algorithms are more efficient. In a similar fashion, optimized versions of the geometric operations that we presented, like line drawing and circle drawing, are often implemented in special graphics-acceleration hardware.</p>
<p>Like every hardware and software system developed in Nand to Tetris, our goal is not to provide a complete solution that addresses all wants and needs. Rather, we strive to build a working implementation and a solid understanding of the system’s <i>foundation</i>, and then propose ways to extend it further. Some of these optional extension projects are mentioned in the next and final chapter in the book.</p>
</section>
</section>
</div>
</body>
</html>