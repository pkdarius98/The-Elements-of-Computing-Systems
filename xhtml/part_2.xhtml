<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>II SOFTWARE</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="pt2" epub:type="part" role="doc-part">
<header>
<h1 class="PN" id="pt2"><span aria-label="117" id="pg_117" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">II       Software</samp></h1>
</header>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP1">Any sufficiently advanced technology is indistinguishable from magic.</p>
<p class="EPA1">—Arthur C. Clarke (1962)</p>
</blockquote>
<p class="noindent">To which we add: “and any sufficiently advanced magic is indistinguishable from hard work, behind the scenes.” In part I of the book we built the hardware platform of a computer system named Hack, capable of running programs written in the Hack machine language. In part II we will transform this barebone machine into an advanced technology, indistinguishable from magic: a black box that can metamorphose into a chess player, a search engine, a flight simulator, a media streamer, or anything else that tickles your fancy. In order to do so, we’ll unfold the elaborate behind-the-scenes software hierarchy that endows computers with the ability to execute programs written in high-level programming languages. In particular, we’ll focus on Jack, a simple, Java-like, object-based programming language, described formally in chapter 9. Over the years, Nand to Tetris readers and students have used Jack to develop Tetris, Pong, Snake, Space Invaders, and numerous other games and interactive apps. Being a general-purpose computer, Hack can execute all these programs, and any other program that comes to your mind.</p>
<p>Clearly, the gap between the expressive syntax of high-level programming languages, on the one hand, and the clunky instructions of low-level machine language, on the other, is huge. If you are not convinced, try developing a Tetris game using instructions like <samp class="SANS_Consolas_Regular_11">@17</samp> and <img alt="" class="inline" height="10" src="../images/PII-C1.png" width="50"/>. Bridging this gap is what part II of this book is all about. We will build this bridge by developing gradually some of the most powerful and ambitious programs in applied computer science: a <i>compiler</i>, a <i>virtual machine</i>, and a basic <i>operating system</i>.</p>
<p>Our Jack compiler will be designed to take a Jack program, say Tetris, and produce from it a stream of machine language instructions that, when executed, makes the Hack platform deliver a Tetris game experience. Of course Tetris is just one example: the compiler that you build will be capable of translating <i>any</i> given Jack program into machine code that can be executed on the Hack computer. The compiler, whose main tasks consist of <i>syntax analysis</i> and <i>code generation</i>, will be built in chapters 10 and 11.</p>
<p><span aria-label="118" id="pg_118" role="doc-pagebreak"/>As with programming languages like Java and C#, the Jack compiler will be <i>two-tiered</i>: the compiler will generate interim <i>VM code</i>, designed to run on an abstract <i>virtual machine</i>. The VM code will then be compiled further by a separate translator into the Hack machine language. <i>Virtualization</i>—one of the most important ideas in applied computer science—comes into play in numerous settings including program compilation, cloud computing, distributed storage, distributed processing, and operating systems. We will devote chapters 7 and 8 to motivating, designing, and building our virtual machine.</p>
<p>Like many other high-level languages, the basic Jack language is surprisingly simple. What turns modern languages into powerful programming systems are <i>standard libraries</i> providing mathematical functions, string processing, memory management, graphics drawing, user interaction handling, and more. Taken together, these standard libraries form a basic <i>operating system</i> (OS) which, in the Jack framework, is packaged as Jack’s <i>standard class library</i>. This basic OS, designed to bridge many gaps between the high-level Jack language and the low-level Hack platform, will be developed in Jack itself. You may be wondering how software that is supposed to enable a programming language can be developed in this very same language. We’ll deal with this challenge by following a development strategy known as <i>bootstrapping</i>, similar to how the Unix OS was developed using the C language.</p>
<p>The construction of the OS will give us an opportunity to present elegant algorithms and classical data structures that are typically used to manage hardware resources and peripheral devices. We will then implement these algorithms in Jack, extending the language’s capabilities one step at a time. As you go through the chapters of part II, you will deal with the OS from several different perspectives. In chapter 9, acting as an <i>application programmer</i>, you will develop a Jack app and use the OS services abstractly, from a high-level client perspective. In chapters 10 and 11, when building the Jack compiler, you will use the OS services as a low-level client, for example, for various memory management services required by the compiler. In chapter 12 you will finally don the hat of the OS developer and implement all these system services yourself.</p>
<section epub:type="division">
<h2 class="head a-head"><b>II.1    A Taste of Jack Programming</b></h2>
<p class="noindent">Before delving into all these exciting projects, we’ll give a brief and informal introduction of the Jack language. This will be done using two examples, starting with Hello World. We will use this example to demonstrate that even the most trivial high-level program has much more to it than meets the eye. We will then present a simple program that illustrates the object-based capabilities of the Jack language. Once we get a programmer-oriented taste of the high-level Jack language, we will be prepared to start the journey of realizing the language by building a virtual machine, a compiler, and an operating system.</p>
<p class="STNI1"><span aria-label="119" id="pg_119" role="doc-pagebreak"/><samp class="SANS_Consolas_Bold_B_11">Hello</samp> <samp class="SANS_Consolas_Bold_B_11">World, again</samp>: We began this book with the iconic Hello World program that learners often encounter as the first thing in introductory programming courses. Here is this trivial program once again, written in the Jack programming language:</p>
<p class="COMF"><samp class="SANS_Consolas_Regular_11">// First example in Programming 101 class Main {</samp></p>
<p class="COMI"><samp class="SANS_Consolas_Regular_11">function void main</samp> <samp class="SANS_Consolas_Regular_11">() {</samp></p>
<p class="COM1I"><samp class="SANS_Consolas_Regular_11">do Output.printString</samp> <samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">Hello</samp> <samp class="SANS_Consolas_Regular_11">World</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">); return;</samp></p>
<p class="COMI"><samp class="SANS_Consolas_Regular_11">}</samp></p>
<p class="COML"><samp class="SANS_Consolas_Regular_11">}</samp></p>
<p class="TNI1">Let’s discuss some of the implicit assumptions that we normally make when presented with such programs. The first magic that we take for granted is that a sequence characters, say, <samp class="SANS_Consolas_Regular_11">printString</samp> <samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">Hello</samp> <samp class="SANS_Consolas_Regular_11">World</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp>, can cause the computer to actually display something on the screen. How does the computer figure out <i>what</i> to do? And even if the computer knew what to do, <i>how</i> will it actually do it? As we saw in part I of the book, the screen is a grid of pixels. If we want to display <samp class="SANS_Consolas_Regular_11">H</samp> on the screen, we have to turn on and off a carefully selected subset of pixels that, taken together, render the desired letter’s image on the screen. Of course this is just the beginning. What about displaying this <samp class="SANS_Consolas_Regular_11">H</samp> legibly on screens that have different sizes and resolutions? And what about dealing with <i>while</i> and <i>for</i> loops, <i>arrays</i>, <i>objects</i>, <i>methods</i>, <i>classes</i>, and all the other goodies that high-level programmers are trained to use without ever thinking about how they work?</p>
<p>Indeed, the beauty of high-level programming languages, and that of well-designed abstractions in general, is that they permit using them in a state of blissful ignorance. Application programmers are in fact encouraged to view the language as a black box abstraction, without paying any attention to how it is actually implemented. All you need is a good tutorial, a few code examples, and off you go.</p>
<p>Clearly though, at one point or another, <i>someone</i> must implement this language abstraction. Someone must develop, once and for all, the ability to efficiently compute square roots when the application programmer blissfully says <samp class="SANS_Consolas_Regular_11">sqrt(1764)</samp>, to elicit a number from the user when the programmer happily says <img alt="" class="inline" height="14" src="../images/PII-C2.png" width="95"/> to find and carve out an available memory block when the programmer nonchalantly creates an object using <samp class="SANS_Consolas_Regular_11">new</samp>, and to perform transparently all the other abstract services that programmers expect to get without ever thinking about them. So, who are the good souls who turn high-level programming into an advanced technology indistinguishable from magic? They are the software wizards who develop <i>compilers</i>, <i>virtual machines</i>, and <i>operating systems</i>. And that’s precisely what <i>you</i> will do in the forthcoming chapters.</p>
<p>You may be wondering why you have to bother about this elusive behind-the-scenes scene. Didn’t we just say that you can use high-level languages without worrying about how they work? There are at least two reasons why. First, the more you delve into low-level system <span aria-label="120" id="pg_120" role="doc-pagebreak"/>internals, the more sophisticated high-level programmer you become. In particular, you learn how to write high-level code that exploits the hardware and the OS cleverly and efficiently and how to avoid baffling bugs like memory leaks.</p>
<p>Second, by getting your hands dirty and developing the system internals yourself, you will discover some of the most beautiful and powerful algorithms and data structures in applied computer science. Importantly, the ideas and techniques that will unfold in part II are not limited to compilers and operating systems. Rather, they are the building blocks of numerous software systems and applications that will accompany you throughout your career.</p>
<p class="STNI1"><b>The PointDemo program</b>: Suppose we want to represent and manipulate <i>points</i> on a plane. <a href="part_2.xhtml#figII-1" id="rfigII-1">Figure II.1</a> shows two such points, <i>p</i><small>1</small> and <i>p</i><small>2</small>, and a third point, <i>p</i><small>3</small>, resulting from the vector addition <img alt="" class="inline" height="15" src="../images/PartII.png" width="233"/> The figure also depicts the <i>Euclidean distance</i> between <i>p</i><small>1</small> and <i>p</i><small>3</small>, which can be computed using the Pythagorean theorem. The code in the <samp class="SANS_Consolas_Regular_11">Main</samp> class illustrates how such algebraic manipulations can be done using the object-based Jack language.</p>
<figure class="IMG"><img alt="" id="figII-1" src="../images/figure_II.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigII-1">Figure II.1</a></b>    Manipulating points on a plane: example and Jack code.</p></figcaption>
</figure>
<p>You may wonder why Jack uses keywords like <samp class="SANS_Consolas_Regular_11">var</samp>, <samp class="SANS_Consolas_Regular_11">let</samp>, and <samp class="SANS_Consolas_Regular_11">do</samp>. For now, we advise you not to dwell on syntactic details. Instead, let’s focus on the big picture and proceed to review how the Jack language can be used to implement the <samp class="SANS_Consolas_Regular_11">Point</samp> abstract data type (<a href="part_2.xhtml#figII-2" id="rfigII-2">figure II.2</a>).</p>
<figure class="IMG"><img alt="" id="figII-2" src="../images/figure_II.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigII-2">Figure II.2</a></b>    Jack implementation of the <samp class="SANS_Consolas_Regular_11">Point</samp> abstraction.</p></figcaption>
</figure>
<p>The code shown in <a href="part_2.xhtml#figII-2">figure II.2</a> illustrates that a Jack class (of which <samp class="SANS_Consolas_Regular_11">Main</samp> and <samp class="SANS_Consolas_Regular_11">Point</samp> are two examples) is a collection of one or more <i>subroutines</i>, each being a <i>constructor</i>, <i>method</i>, or <i>function</i>. <i>Constructors</i> are subroutines that create new objects, <i>methods</i> are subroutines that operate on the current object, and <i>functions</i> are subroutines that operate on no particular object. (Object-oriented design purists may frown about mixing methods and functions in the same class; we are doing it here for illustrative purposes).</p>
<p><span aria-label="121" id="pg_121" role="doc-pagebreak"/>The remainder of this section is an informal overview of the <samp class="SANS_Consolas_Regular_11">Main</samp> and the <samp class="SANS_Consolas_Regular_11">Point</samp> classes. Our goal is to give a taste of Jack programming, deferring a complete language description to chapter 9. So, allowing ourselves the luxury of focusing on essence only, let’s get started. The <samp class="SANS_Consolas_Regular_11">Main.main</samp> function begins by declaring three <i>object variables</i> (also known as <i>references</i>, or <i>pointers</i>), designed to refer to instances of the <samp class="SANS_Consolas_Regular_11">Point</samp> class. It then goes on to construct two <samp class="SANS_Consolas_Regular_11">Point</samp> objects, and assigns the <samp class="SANS_Consolas_Regular_11">p1</samp> and <samp class="SANS_Consolas_Regular_11">p2</samp> variables to them. Next, it calls the <samp class="SANS_Consolas_Regular_11">plus</samp> method, and assigns <samp class="SANS_Consolas_Regular_11">p3</samp> to the <samp class="SANS_Consolas_Regular_11">Point</samp> object returned by that method. The rest of the <samp class="SANS_Consolas_Regular_11">Main.main</samp> function prints some results.</p>
<p>The <samp class="SANS_Consolas_Regular_11">Point</samp> class begins by declaring that every <samp class="SANS_Consolas_Regular_11">Point</samp> object is characterized by two <i>field</i> variables (also known as <i>properties</i>, or <i>instance variables</i>). It then declares a <i>static variable</i>, that is, a class-level variable associated with no particular object. The class constructor sets up the field values of the newly created object and increments the number of instances derived from this class so far. Note that a Jack constructor must explicitly return the memory address of the newly created object, which, according to the language rules, is denoted <samp class="SANS_Consolas_Regular_11">this</samp>.</p>
<p>You may wonder why the result of the square root computed by the <samp class="SANS_Consolas_Regular_11">distance</samp> method is stored in an <samp class="SANS_Consolas_Regular_11">int</samp> variable—clearly a real-valued data type like <samp class="SANS_Consolas_Regular_11">float</samp> would make more sense. The reason for this peculiarity is simple: the Jack language features only three primitive data types: <samp class="SANS_Consolas_Regular_11">int</samp>, <samp class="SANS_Consolas_Regular_11">boolean</samp>, and <samp class="SANS_Consolas_Regular_11">char</samp>. Other data types can be implemented at will using classes, as we’ll do in chapters 9 and 12.</p>
<p class="STNI1"><span aria-label="122" id="pg_122" role="doc-pagebreak"/><b>The operating system</b>: The <samp class="SANS_Consolas_Regular_11">Main</samp> and <samp class="SANS_Consolas_Regular_11">Point</samp> classes use three OS functions: <samp class="SANS_Consolas_Regular_11">Output.printInt</samp>, <samp class="SANS_Consolas_Regular_11">Output.printString</samp>, and <samp class="SANS_Consolas_Regular_11">Math.sqrt</samp>. Like other modern high-level languages, the Jack language is augmented by a set of <i>standard classes</i> that provide commonly used OS services (the complete OS API is given in appendix 6). We will have much more to say about the OS services in chapter 9, where we’ll use them in the context of Jack programming, as well as in chapter 12, where we’ll build the OS.</p>
<p>In addition to calling OS services for their effects directly from Jack programs, the OS comes to play in other, less obvious ways. For example, consider the <samp class="SANS_Consolas_Regular_11">new</samp> operation, used to construct objects in object-oriented languages. How does the compiler know where in the host RAM to put the newly constructed object? Well, it doesn’t. An OS routine is called to figure it out. When we build the OS in chapter 12, you will implement, among many other things, a typical run-time memory management system. You will then learn, hands-on, how this system interacts with the hardware, from the one end, and with compilers, from the other, in order to allocate and reclaim RAM space cleverly and efficiently. This is just one example that illustrates how the OS bridges gaps between high-level applications and the host hardware platform.</p>
</section>
<section epub:type="division">
<h2 class="head a-head"><b>II.2    Program Compilation</b></h2>
<p class="noindent">A high-level program is a symbolic abstraction that means nothing to the underlying hardware. Before executing a program, the high-level code must be translated into machine language. This translation process is called <i>compilation</i>, and the program that carries it out is called a <i>compiler</i>. Writing a compiler that translates high-level programs into low-level machine instructions is a worthy challenge. Some languages, for example, Java and C#, deal with this challenge by employing an elegant <i>two-tier</i> compilation model. First, the source program is translated into an interim, abstract VM code (called <i>bytecode</i> in Java and Python and <i>Intermediate Language</i> in C#/.NET). Next, using a completely separate and independent process, the VM code can be translated further into the machine language of any target hardware platform.</p>
<p>This modularity is at least one reason why Java became such a dominant programming language. Taking a historical perspective, Java can be viewed as a powerful object-oriented language whose two-tier compilation model was the right thing in the right time, just when computers began evolving from a few predictable processor/OS platforms into a bewildering hodgepodge of numerous PCs, cell phones, mobile devices, and Internet of Things devices, all connected by a global network. Writing high-level programs that can execute on any one of these host platforms is a daunting challenge. One way to streamline this distributed, multi-vendor ecosystem (from a compilation perspective) is to base it on some overarching, agreed-upon virtual machine architecture. Acting as a common, intermediate run-time environment, the VM approach allows developers to write high-level programs <span aria-label="123" id="pg_123" role="doc-pagebreak"/>that run almost as is on many different hardware platforms, each equipped with its own VM implementation. We will have much more to say about the enabling power of this modularity as part II unfolds.</p>
<p class="STNI1"><b>The road ahead</b>: In the remainder of the book we’ll apply ourselves to developing all the exciting software technologies mentioned above. Our ultimate goal is creating an infrastructure for turning high-level programs—<i>any</i> program—into executable code. The road map is shown in <a href="part_2.xhtml#figII-3" id="rfigII-3">figure II.3</a>.</p>
<figure class="IMG"><img alt="" id="figII-3" src="../images/figure_II.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigII-3">Figure II.3</a></b>    Road map of part II (the assembler belongs to part I and is shown here for completeness). The road map describes a translation hierarchy, from a high-level, object-based, multi-class program to VM code, to assembly code, to executable binary code. The numbered circles stand for the projects that implement the compiler, the VM translator, the assembler, and the operating system. Project 9 focuses on writing a Jack application in order to get acquainted with the language.</p></figcaption>
</figure>
<p>Following the Nand to Tetris spirit, we’ll pursue the part II road map from the bottom up. To get started, we assume that we have a hardware platform equipped with an assembly language. In chapters 7–8 we’ll present a virtual machine architecture and a VM language, and we’ll implement this abstraction by developing a <i>VM translator</i> that translates VM programs into Hack assembly programs. In chapter 9 we’ll present the Jack high-level language and use it to develop a simple computer game. This way, you’ll get acquainted with the Jack language and operating system before setting out to build them. In chapters 10–11 we’ll develop the Jack compiler, and in chapter 12 we’ll build the operating system.</p>
<p>So, let’s roll up our sleeves and get to work!</p>
</section>
</section>
</div>
</body>
</html>