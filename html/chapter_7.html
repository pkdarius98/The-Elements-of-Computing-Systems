<html lang="en">
<head>
<title>7 Virtual Machine I: Processing</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch7"role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch7"><span aria-label="125" id="pg_125" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">7</samp>       <samp class="SANS_Helvetica_LT_Std_Bold_B_11">Virtual Machine I: Processing</samp></h1>
</header>
<blockquoterole="doc-epigraph">
<p class="EP1">Programmers are creators of universes for which they alone are responsible. Universes of virtually unlimited complexity can be created in the form of computer programs.</p>
<p class="EPA1">—Joseph Weizenbaum, <i>Computer Power and Human Reason</i> (1974)</p>
</blockquote>
<p class="noindent">This chapter describes the first steps toward building a compiler for a typical object-based, high-level language. We approach this challenge in two major stages, each spanning two chapters. In chapters 10–11 we’ll describe the construction of a <i>compiler</i>, designed to translate high-level programs into <i>intermediate code</i>; in chapters 7–8 we describe the construction of a follow-up <i>translator</i>, designed to translate the intermediate code into the machine language of a target hardware platform. As the chapter numbers suggest, we will pursue this substantial development from the bottom up, starting with the translator.</p>
<p>The intermediate code that lies at the core of this compilation model is designed to run on an abstract computer, called a <i>virtual machine</i>, or VM. There are several reasons why this two-tier compilation model makes sense, compared to traditional compilers that translate high-level programs directly to machine language. One benefit is cross-platform compatibility: since the virtual machine may be realized with relative ease on many hardware platforms, the same VM code can run as is on any device equipped with such a VM implementation. That’s one reason Java became a dominant language for developing apps for mobile devices, which are characterized by many different processor/OS combinations. The VM can be implemented on the target devices by using software interpreters, or special-purpose hardware, or by translating the VM programs into the device’s machine language. The latter implementation approach is taken by Java, Scala, C#, and Python, as well as by the Jack language developed in Nand to Tetris.</p>
<p>This chapter presents a typical VM architecture and VM language, conceptually similar to the Java Virtual Machine (JVM) and bytecode, respectively. As usual in Nand to Tetris, the virtual machine will be presented from two perspectives. First, we will motivate and specify the VM abstraction, describing what the VM is designed to do. Next, we will describe a proposed implementation of the VM over the Hack platform. Our implementation entails writing a program called a <i>VM translator</i> that translates VM code into Hack assembly code.</p>
<p><span aria-label="126" id="pg_126" role="doc-pagebreak"/>The VM language that we’ll present consists of arithmetic-logical commands, memory access commands called <i>push</i> and <i>pop</i>, branching commands, and function call-and-return commands. We split the discussion and implementation of this language into two parts, each covered in a separate chapter and project. In this chapter we build a basic VM translator which implements the VM’s arithmetic-logical and push/pop commands. In the next chapter we extend the basic translator to handle branching and function commands. The result will be a full-scale virtual machine implementation that will serve as the back end of the compiler that we will build in chapters 10–11.</p>
<p>The virtual machine that will emerge from this effort illustrates several important ideas and techniques. First, the notion of having one computing framework emulate another is a fundamental idea in computer science, tracing back to Alan Turing in the 1930s. Today, the virtual machine model is the centerpiece of several mainstream programming environments, including Java, .NET, and Python. The best way to gain an intimate inside view of how these programming environments work is to build a simple version of their VM cores, as we do here.</p>
<p>Another important theme in this chapter is <i>stack processing</i>. The <i>stack</i> is a fundamental and elegant data structure that comes to play in numerous computer systems, algorithms, and applications. Since the VM presented in this chapter is stack-based, it provides a working example of this remarkably versatile and powerful data structure.</p>
<section>
<h2 class="head a-head"><b>7.1    The Virtual Machine Paradigm</b></h2>
<p class="noindent">Before a high-level program can run on a target computer, it must be translated into the computer’s machine language. Traditionally, a separate compiler was developed specifically for any given pair of high-level language and low-level machine language. Over the years, the reality of many high-level languages, on the one hand, and many processors and instruction sets, on the other, has led to a proliferation of many different compilers, each depending on every detail of both its source and target languages. One way to decouple this dependency is to break the overall compilation process into two nearly separate stages. In the first stage, the high-level code is parsed and translated into intermediate and abstract processing steps—steps that are neither high nor low. In the second stage, the intermediate steps are translated further into the low-level machine language of the target hardware.</p>
<p>This decomposition is very appealing from a software engineering perspective. First, note that the first translation stage depends only on the specifics of the source high-level language, and the second stage only on the specifics of the target low-level machine language. Of course, the interface between the two translation stages—the exact definition of the intermediate processing steps—must be carefully designed and optimized. At some point in the evolution of program translation solutions, compiler developers concluded that this intermediate interface is sufficiently important to merit its own definition as a standalone language designed to run on an abstract machine. Specifically, one can describe a <i>virtual machine</i> <span aria-label="127" id="pg_127" role="doc-pagebreak"/>whose commands realize the intermediate processing steps into which high-level commands are translated. The compiler that was formerly a single monolithic program is now split into two separate and much simpler programs. The first program, still termed <i>compiler</i>, translates the high-level code into intermediate VM commands; the second program, called <i>VM translator</i>, translates the VM commands further into the machine instructions of the target hardware platform. <a href="chapter_7.xhtml#fig7-1" id="rfig7-1">Figure 7.1</a> outlines how this two-tiered compilation framework has contributed to the cross-platform portability of Java programs.</p>
<figure class="IMG"><img alt="" id="fig7-1" src="../images/figure_7.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig7-1">Figure 7.1</a></b>    The virtual machine framework, using Java as an example. High-level programs are compiled into intermediate VM code. The same VM code can be shipped to, and executed on, any hardware platform equipped with a suitable <i>JVM implementation</i>. These VM implementations are typically realized as client-side programs that translate the VM code into the machine languages of the target devices.</p></figcaption>
</figure>
<p>The virtual machine framework entails many practical benefits. When a vendor introduces to the market a new digital device—say, a cell phone—it can develop for it a JVM <span aria-label="128" id="pg_128" role="doc-pagebreak"/>implementation, known as JRE (Java Runtime Environment), with relative ease. This client-side enabling infrastrucutre immediately endows the device with a huge base of available Java software. And, in a world like .NET, in which several high-level languages are made to compile into the same intermediate VM language, compilers for different languages can share the same VM back end, allowing usage of common software libraries and language interoperability.</p>
<p>The price paid for the elegance and power of the VM framework is reduced efficiency. Naturally, a two-tier translation process results, ultimately, in generating machine code that is more verbose and cumbersome than the code produced by direct compilation. However, as processors become faster and VM implementations more optimized, the degraded efficiency is hardly noticeable in most applications. Of course, there will always be high-performance applications and embedded systems that will continue to demand the efficient code generated by single-tier compilers of language like C and C<span class="symb">++</span>. That said, modern versions of C<span class="symb">++</span> feature both classical one-tier compilers and two-tier VM-based compilers.</p>
</section>
<section>
<h2 class="head a-head"><b>7.2    Stack Machine</b></h2>
<p class="noindent">The design of an effective VM language seeks to strike a convenient balance between high-level programming languages, on the one hand, and a great variety of low-level machine languages, on the other. Thus, the desired VM language should satisfy several requirements coming both from above and from below. First, the language should have a reasonable expressive power. We achieve this by designing a VM language that features arithmetic-logical commands, push/pop commands, branching commands, and function commands. These VM commands should be sufficiently “high” so that the VM code generated by the compiler will be reasonably elegant and well structured. At the same time, the VM commands should be sufficiently “low” so that the machine code generated from them by VM translators will be tight and efficient. Said otherwise, we have to make sure that the translation gaps between the high-level and the VM level, on the one hand, and the VM level and the machine level, on the other, will not be wide. One way to satisfy these somewhat conflicting requirements is to base the interim VM language on an abstract architecture called a <i>stack machine</i>.</p>
<p>Before going on, we’d like to issue a plea for patience. The relationship between the stack machine that we now turn to describe and the compiler that we’ll introduce later in the book is subtle. Therefore, we advise readers to allow themselves to savor the intrinsic beauty of the stack machine abstraction without worrying about its ultimate purpose in every step of the way. The full practical power of this remarkable abstraction will carry its weight only toward the end of the <i>next</i> chapter; for now, suffice it to say that any program, written in any high-level programming language, can be translated into a sequence of operations on a stack.</p>
<section>
<h3 class="head b-head"><span aria-label="129" id="pg_129" role="doc-pagebreak"/><b>7.2.1    Push and Pop</b></h3>
<p class="noindent">The centerpiece of the stack machine model is an abstract data structure called a <i>stack</i>. A stack is a sequential storage space that grows and shrinks as needed. The stack supports various operations, the two key ones being <samp class="SANS_Consolas_Regular_11">push</samp> and <samp class="SANS_Consolas_Regular_11">pop</samp>. The <samp class="SANS_Consolas_Regular_11">push</samp> operation adds a value to the top of the stack, like adding a plate to the top of a stack of plates. The <samp class="SANS_Consolas_Regular_11">pop</samp> operation removes the stack’s top value; the value that was just before it becomes the top stack element. See <a href="chapter_7.xhtml#fig7-2" id="rfig7-2">figure 7.2</a> for an example. Note that the push/pop logic results in a <i>last-in-first-out</i> (LIFO) access logic: the popped value is always the last one that was pushed onto the stack. As it turns out, this access logic lends itself perfectly to program translation and execution purposes, but this insight will take two chapters to unfold.</p>
<figure class="IMG"><img alt="" id="fig7-2" src="../images/figure_7.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig7-2">Figure 7.2</a></b>    Stack processing example, illustrating the two elementary operations <samp class="SANS_Consolas_Regular_11">push</samp> and <samp class="SANS_Consolas_Regular_11">pop</samp>. The setting consists of two data structures: a RAM-like memory segment and a stack. Following convention, the stack is drawn as if it grows downward. The location just following the stack’s top value is referred to by a pointer called <i>sp</i>, or <i>stack pointer</i>. The <i>x</i> and <i>y</i> symbols refer to two arbitrary memory locations.</p></figcaption>
</figure>
<p>As <a href="chapter_7.xhtml#fig7-2">figure 7.2</a> shows, our VM abstraction includes a <i>stack</i>, as well as a sequential, RAM-like memory segment. Observe that stack access is different from conventional memory access. First, the stack is accessible only from its top, whereas regular memory allows direct and indexed access to any value in the memory. Second, <i>reading</i> a value from the stack is a lossy operation: only the top value can be read, and the only way to access it entails <span aria-label="130" id="pg_130" role="doc-pagebreak"/><i>removing</i> it from the stack (although some stack models also provide a <i>peek</i> operation, which allows reading without removing). In contrast, the act of reading a value from a regular memory leaves no impact on the memory’s state. Lastly, <i>writing</i> to the stack entails adding a value onto the stack’s top without changing the other values in the stack. In contrast, writing an item into a regular memory location is a lossy operation, since it overrides the location’s previous value.</p>
</section>
<section>
<h3 class="head b-head"><b>7.2.2    Stack Arithmetic</b></h3>
<p class="noindent">Consider the generic operation <i>x op y</i>, where the operator <i>op</i> is applied to the operands <i>x</i> and <i>y</i>, for example, <img alt="" class="inline" height="12" src="../images/7-C1.png" width="77"/> and so on. In a stack machine, each <i>x op y</i> operation is carried out as follows: first, the operands <i>x</i> and <i>y</i> are popped off the top of the stack; next, the value of <i>x op y</i> is computed; finally, the computed value is pushed onto the top of the stack. Likewise, the unary operation <i>op x</i> is realized by popping <i>x</i> off the top of the stack, computing the value of <i>op x</i>, and finally pushing this value onto the top of the stack. For example, here is how addition and negation are handled:</p>
<figure class="IMG"><img alt="" class="img100" src="../images/figure_wo_caption_7.1.png"/></figure>
<p class="noindent">Stack-based evaluation of general arithmetic expressions is an extension of the same idea. For example, consider the expression <img alt="" class="inline" height="14" src="../images/7-C2.png" width="131"/> taken from some high-level program. The stack-based evaluation of this expression is shown in <a href="chapter_7.xhtml#fig7-3a" id="rfig7-3a">figure 7.3a</a>. Stack-based evaluation of logical expressions, shown in <a href="chapter_7.xhtml#fig7-3b" id="rfig7-3b">figure 7.3b</a>, follows the same scheme.</p>
<figure class="IMG"><img alt="" id="fig7-3a" src="../images/figure_7.3a.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig7-3a">Figure 7.3a</a></b>    Stack-based evaluation of arithmetic expressions.</p></figcaption>
</figure>
<figure class="IMG"><img alt="" id="fig7-3b" src="../images/figure_7.3b.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig7-3b">Figure 7.3b</a></b>    Stack-based evaluation of logical expressions.</p></figcaption>
</figure>
<p>Note that from the stack’s perspective, each arithmetic or logical operation has the net impact of replacing the operation’s operands with the operation’s result, without affecting the rest of the stack. This is similar to how humans perform mental arithmetic, using our short-term memory. For example, how to compute the value of <img alt="" class="inline" height="14" src="../images/7-2.png" width="106"/> We start by mentally popping 11 and 7 off the expression and calculating <img alt="" class="inline" height="12" src="../images/7-4.png" width="38"/>. We then plug the resulting value back into the expression, yielding <img alt="" class="inline" height="12" src="../images/7-3.png" width="66"/> The net effect is that <img alt="" class="inline" height="14" src="../images/7-5.png" width="50"/>has been replaced by 18, and the rest of the expression remains the same as before. We can now proceed to perform similar pop-compute-and-push mental operations until the expression is reduced to a single value.</p>
<p>These examples illustrate an important virtue of stack machines: any arithmetic and logical expression—no matter how complex—can be systematically converted into, and evaluated by, a sequence of simple operations on a stack. Therefore, one can write a <i>compiler</i> that translates high-level arithmetic and logical expressions into sequences of stack commands, as indeed we’ll do in chapters 10–11. Once the high-level expressions have <span aria-label="131" id="pg_131" role="doc-pagebreak"/>been reduced into stack commands, we can proceed to evaluate them using a stack machine implementation.</p>
</section>
<section>
<h3 class="head b-head"><span aria-label="132" id="pg_132" role="doc-pagebreak"/><b>7.2.3    Virtual Memory Segments</b></h3>
<p class="noindent">So far in our stack processing examples, the push/pop commands were illustrated conceptually, using the syntax <samp class="SANS_Consolas_Regular_11">push</samp> <i>x</i> and <samp class="SANS_Consolas_Regular_11">pop</samp> <i>y</i>, where <i>x</i> and <i>y</i> referred abstractly to arbitrary memory locations. We now turn to give a formal description of our <samp class="SANS_Consolas_Regular_11">push</samp> and <samp class="SANS_Consolas_Regular_11">pop</samp> commands.</p>
<p>High-level languages feature symbolic variables like <samp class="SANS_Consolas_Regular_11">x</samp>, <samp class="SANS_Consolas_Regular_11">y</samp>, <samp class="SANS_Consolas_Regular_11">sum,</samp> <samp class="SANS_Consolas_Regular_11">count</samp>, and so on. If the language is object-based, each such variable can be a class-level <i>static</i> variable, an instance-level <i>field</i> of an object, or a method-level <i>local</i> or <i>argument</i> variable. In virtual machines like Java’s JVM and in our own VM model, there are no symbolic variables. Instead, variables are represented as entries in virtual memory segments that have names like <samp class="SANS_Consolas_Regular_11">static</samp>, <samp class="SANS_Consolas_Regular_11">this</samp>, <samp class="SANS_Consolas_Regular_11">local</samp>, and <samp class="SANS_Consolas_Regular_11">argument</samp>. In particular, as we’ll see in later chapters, the compiler maps the first, second, third, <span class="ellipsis">…</span> static variable found in the high-level program onto <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, and so on. The other variable kinds are mapped similarly on the segments <samp class="SANS_Consolas_Regular_11">this</samp>, <samp class="SANS_Consolas_Regular_11">local</samp>, and <samp class="SANS_Consolas_Regular_11">argument</samp>. For example, if the local variable <samp class="SANS_Consolas_Regular_11">x</samp> and the field <samp class="SANS_Consolas_Regular_11">y</samp> have been mapped on <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">1</samp> and <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">3</samp>, respectively, then a high-level statement like <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="11" src="../images/7-C3.png" width="32"/> will be translated by the compiler into <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">this</samp> <samp class="SANS_Consolas_Regular_11">3</samp> followed by <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">1</samp>. Altogether, our VM model features eight memory segments, whose names and roles are listed in <a href="chapter_7.xhtml#fig7-4" id="rfig7-4">figure 7.4</a>.</p>
<figure class="IMG"><img alt="" id="fig7-4" src="../images/figure_7.4.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig7-4">Figure 7.4</a></b>    Virtual memory segments.</p></figcaption>
</figure>
<p>We note in passing that developers of VM implementations need not care about how the compiler maps symbolic variables on the virtual memory segments. We will deal with these issues at length when we develop the compiler in chapters 10–11. For now, we observe that VM commands access all the virtual memory segments in exactly the same way: by using the <i>segment name</i> followed by a nonnegative <i>index</i>.</p>
</section>
</section>
<section>
<h2 class="head a-head"><span aria-label="133" id="pg_133" role="doc-pagebreak"/><b>7.3    VM Specification, Part I</b></h2>
<p class="noindent">Our VM model is <i>stack-based</i>: all the VM operations take their operands from, and store their results on, the <i>stack</i>. There is only one data type: a signed 16-bit integer. A VM <i>program</i> is a sequence of VM commands that fall into four categories:</p>
<ul class="List-1">
<li class="BLF"><i>Push</i> / <i>pop commands</i> transfer data between the stack and memory segments.</li>
<li class="BL1"><i>Arithmetic-logical commands</i> perform arithmetic and logical operations.</li>
<li class="BL1"><i>Branching commands</i> facilitate conditional and unconditional branching operations.</li>
<li class="BLL1"><i>Function commands</i> facilitate function call-and-return operations.</li>
</ul>
<p>The specification and implementation of these commands span two chapters. In this chapter we focus on the <i>arithmetic-logical</i> and <i>push/pop</i> commands. In the next chapter we complete the specification of the remaining commands.</p>
<p class="STNI1"><b>Comments and white space</b>: Lines beginning with <samp class="SANS_Consolas_Regular_11">//</samp> are considered comments and are ignored. Blank lines are permitted and are ignored.</p>
<section>
<h3 class="head b-head"><b>Push / Pop Commands</b></h3>
<figure class="IMG-L"><img alt="" class="img80" src="../images/1.png"/></figure>
</section>
<section>
<h3 class="head b-head"><b>Arithmetic-Logical Commands</b></h3>
<ul class="List-1">
<li class="BL1"><i>Arithmetic commands</i>: <samp class="SANS_Consolas_Regular_11">add</samp>, <samp class="SANS_Consolas_Regular_11">sub</samp>, <samp class="SANS_Consolas_Regular_11">neg</samp></li>
<li class="BL1"><i>Comparison commands</i>: <samp class="SANS_Consolas_Regular_11">eq</samp>, <samp class="SANS_Consolas_Regular_11">gt</samp>, <samp class="SANS_Consolas_Regular_11">lt</samp></li>
<li class="BLL1"><i>Logical commands</i>: <samp class="SANS_Consolas_Regular_11">and</samp>, <samp class="SANS_Consolas_Regular_11">or</samp>, <samp class="SANS_Consolas_Regular_11">not</samp></li>
</ul>
<p class="noindent">The commands <samp class="SANS_Consolas_Regular_11">add</samp>, <samp class="SANS_Consolas_Regular_11">sub</samp>, <samp class="SANS_Consolas_Regular_11">eq</samp>, <samp class="SANS_Consolas_Regular_11">gt</samp>, <samp class="SANS_Consolas_Regular_11">lt</samp>, <samp class="SANS_Consolas_Regular_11">and</samp>, and <samp class="SANS_Consolas_Regular_11">or</samp> have two implicit operands. To execute each one of them, the VM implementation pops two values off the stack’s top, computes the stated function on them, and pushes the resulting value back onto the stack (by <i>implicit operand</i> we mean that the operand is not part of the command syntax: since the command is designed to always operate on the two top stack values, there is no need to specify them). The remaining <samp class="SANS_Consolas_Regular_11">neg</samp> and <samp class="SANS_Consolas_Regular_11">not</samp> commands have one implicit operand and work the same way. <a href="chapter_7.xhtml#fig7-5" id="rfig7-5">Figure 7.5</a> gives the details.</p>
<figure class="IMG"><img alt="" id="fig7-5" src="../images/figure_7.5.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig7-5">Figure 7.5</a></b>    The arithmetic-logical commands of the VM language.</p></figcaption>
</figure>
</section>
</section>
<section>
<h2 class="head a-head"><span aria-label="134" id="pg_134" role="doc-pagebreak"/><b>7.4    Implementation</b></h2>
<p class="noindent">The virtual machine described up to this point is an abstraction. If we want to use this VM for real, it must be implemented on some real, host platform. There are several implementation options, of which we’ll describe one: a VM <i>translator</i>. The VM translator is a program that translates VM commands into machine language instructions. Writing such a program entails two main tasks. First, we have to decide how to represent the stack and the virtual memory segments on the target platform. Second, we have to translate each VM command into a sequence of low-level instructions that can execute on the target platform.</p>
<p>For example, suppose that the target platform is a typical von Neumann machine. In this case, we can represent the VM’s stack using a designated memory block in the host RAM. The lower end of this RAM block will be a fixed base address, and its higher end will change as the stack grows and shrinks. Thus, given a fixed <samp class="SANS_Consolas_Regular_11">stackBase</samp> address, we can manage the stack by keeping track of a single variable: a <i>stack pointer</i>, or <samp class="SANS_Consolas_Regular_11">SP</samp>, which holds the address of the RAM entry just following the stack’s topmost value. To initialize the stack, we set <samp class="SANS_Consolas_Regular_11">SP</samp> to <samp class="SANS_Consolas_Regular_11">stackBase</samp>. From this point onward, each <samp class="SANS_Consolas_Regular_11">push</samp> <i>x</i> command can be implemented by the pseudocode operations <img alt="" class="inline" height="14" src="../images/7-C3a.png" width="79"/> followed by <samp class="SANS_Consolas_Regular_11">SP</samp><span class="symb-code">++</span>, and each <samp class="SANS_Consolas_Regular_11">pop</samp> <i>x</i> command can be implemented by <samp class="SANS_Consolas_Regular_11">SP</samp><samp class="SANS_Consolas_Regular_11">—</samp><samp class="SANS_Consolas_Regular_11">—</samp> followed by <img alt="" class="inline" height="14" src="../images/7-C3b.png" width="80"/>.</p>
<p>Let us assume that the host platform is the Hack computer and that we decide to anchor the stack base at address 256 in the Hack RAM. In that case, the VM translator can start by generating assembly code that realizes <img alt="" class="inline" height="10" src="../images/7-C3c.png" width="56"/>, that is, <samp class="SANS_Consolas_Regular_11">@256</samp>, <img alt="" class="inline" height="10" src="../images/7-C4.png" width="29"/>, <samp class="SANS_Consolas_Regular_11">@SP</samp>, <img alt="" class="inline" height="10" src="../images/7-C3e.png" width="28"/>. From this point onward, the VM translator can handle each <samp class="SANS_Consolas_Regular_11">push</samp> <i>x</i> and <samp class="SANS_Consolas_Regular_11">pop</samp> <i>x</i> command by generating assembly code that realizes the operations <img alt="" class="inline" height="14" src="../images/7-C3d.png" width="98"/> and <img alt="" class="inline" height="14" src="../images/7-C3f.png" width="98"/>, respectively.</p>
<p><span aria-label="135" id="pg_135" role="doc-pagebreak"/>With that in mind, let us now consider the implementation of the VM arithmetic-logical commands <samp class="SANS_Consolas_Regular_11">add</samp>, <samp class="SANS_Consolas_Regular_11">sub</samp>, <samp class="SANS_Consolas_Regular_11">neg</samp>, and so on. Conveniently, all these commands share exactly the same access logic: popping the command’s operands off the stack, carrying out a simple calculation, and pushing the result onto the stack. This means that once we figure out how to implement the VM’s push and pop commands, the implementation of the VM’s arithmetic-logical commands will follow straightforwardly.</p>
<section>
<h3 class="head b-head"><b>7.4.1    Standard VM Mapping on the Hack Platform, Part I</b></h3>
<p class="noindent">So far in this chapter, we have made no assumption whatsoever about the target platform on which our virtual machine will be implemented: everything was described abstractly. When it comes to virtual machines, this platform independence is the whole point: you don’t want to commit your abstract machine to any particular hardware platform, precisely because you want it to potentially run on <i>any</i> platform, including those that were not yet built or invented.</p>
<p>Of course, at some point we have to implement the VM abstraction on a particular hardware platform (for example, on one of the target platforms mentioned in <a href="chapter_7.xhtml#fig7-1">figure 7.1</a>). How should we go about it? In principle, we can do whatever we please, as long as we end up realizing the VM abstraction faithfully and efficiently. Nevertheless, VM architects normally publish basic implementation guidelines, known as <i>standard mappings</i>, for different hardware platforms. With that in mind, the remainder of this section specifies the standard mapping of our VM abstraction on the Hack computer. In what follows, we use the terms <i>VM implementation</i> and <i>VM translator</i> interchangeably.</p>
<p class="STNI1"><b>VM program</b>: The complete definition of a VM <i>program</i> will be presented in the next chapter. For now, we view a VM program as a sequence of VM commands stored in a text file named <i>FileName</i><samp class="SANS_Consolas_Regular_11">.vm</samp> (the first character of the file name must be an uppercase letter, and the extension must be <samp class="SANS_Consolas_Regular_11">vm</samp>). The VM translator should read each line in the file, treat it as a VM command, and translate it into one or more instructions written in the Hack language. The resulting output—a sequence of Hack assembly instructions—should be stored in a text file named <i>FileName</i><samp class="SANS_Consolas_Regular_11">.asm</samp> (the file name is identical to that of the source file; the extension must be <samp class="SANS_Consolas_Regular_11">asm</samp>). When translated by the Hack assembler into binary code or run as is on a Hack CPU emulator, this <samp class="SANS_Consolas_Regular_11">.asm</samp> file should perform the semantics mandated by the source VM program.</p>
<p class="STNI1"><b>Data type</b>: The VM abstraction has only one data type: a signed integer. This type is implemented on the Hack platform as a two’s complement 16-bit value. The VM Boolean values <i>true</i> and <i>false</i> are represented as <img alt="" class="inline" height="10" src="../images/7-C6.png" width="15"/> and <samp class="SANS_Consolas_Regular_11">0</samp>, respectively.</p>
<p class="STNI1"><b>RAM usage</b>: The host Hack RAM consists of 32K 16-bit words. VM implementations should use the top of this address space as follows:<span aria-label="136" id="pg_136" role="doc-pagebreak"/></p>
<figure class="IMG-L"><img alt="" class="img60" src="../images/figure_wo_caption_7.2.png"/></figure>
<p class="TNI1">Recall that according to the <i>Hack machine language specification</i> (chapter 6), RAM addresses 0 to 4 can be referred to using the symbols <samp class="SANS_Consolas_Regular_11">SP</samp>, <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, and <samp class="SANS_Consolas_Regular_11">THAT</samp>. This convention was introduced into the assembly language with foresight, to help developers of VM implementations write readable code. The expected use of these addresses in the VM implementation is as follows:</p>
<figure class="IMG-L"><img alt="" class="img80" src="../images/figure_wo_caption_7.3.png"/></figure>
<p class="noindent">When we say <i>base address</i> of a segment, we mean a physical address in the host RAM. For example, if we wish to map the <samp class="SANS_Consolas_Regular_11">local</samp> segment on the physical RAM segment starting at address 1017, we can write Hack code that sets <samp class="SANS_Consolas_Regular_11">LCL</samp> to 1017. We note in passing that deciding where to locate virtual memory segments in the host RAM is a delicate issue. For example, each time a function starts executing, we have to allocate RAM space to hold its <samp class="SANS_Consolas_Regular_11">local</samp> and <samp class="SANS_Consolas_Regular_11">argument</samp> memory segments. And when the function calls another function, we have to put these segments on hold and allocate additional RAM space for representing the segments of the called function, and so on and so forth. How can we ensure that these open-ended memory segments will not overflow into each other and into other reserved RAM areas? These memory management challenges will be addressed in the next chapter, when we’ll implement the VM language’s function-call-and-return commands.</p>
<p>For now though, none of these memory allocation issues should bother us. Instead, you are to assume that <samp class="SANS_Consolas_Regular_11">SP</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, and <samp class="SANS_Consolas_Regular_11">THAT</samp> have been already initialized to some sensible addresses in the host RAM. Note that VM implementations never see these addresses anyway. Rather, they manipulate them symbolically, using the pointer names. <span aria-label="137" id="pg_137" role="doc-pagebreak"/>For example, suppose we want to push the value of the <samp class="SANS_Consolas_Regular_11">D</samp> register onto the stack. This operation can be implemented using the logic <img alt="" class="inline" height="14" src="../images/7-C7.png" width="102"/> which can be expressed in Hack assembly as <samp class="SANS_Consolas_Regular_11">@SP</samp>, <img alt="" class="inline" height="12" src="../images/7-C8.png" width="65"/> <samp class="SANS_Consolas_Regular_11">@SP</samp>, <img alt="" class="inline" height="10" src="../images/7-C9.png" width="48"/> This code will execute the push operation perfectly, while knowing neither where the stack is located in the host RAM nor what is the current value of the stack pointer.</p>
<p>We suggest taking a few minutes to digest the assembly code just shown. If you don’t understand it, you must refresh your knowledge of pointer manipulation in the Hack assembly language (section 4.3, example 3). This knowledge is a prerequisite for developing the VM translator, since the translation of each VM command entails generating code in the Hack assembly language.</p>
</section>
<section>
<h3 class="head b-head"><b>Memory Segments Mapping</b></h3>
<p class="noindent"><b>Local, argument, this, that</b>: In the next chapter we discuss how the VM implementation maps these segments dynamically on the host RAM. For now, all we have to know is that the base addresses of these segments are stored in the registers <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, and <samp class="SANS_Consolas_Regular_11">THAT</samp>, respectively. Therefore, any access to the <i>i</i>-th entry of a virtual segment (in the context of a VM “<samp class="SANS_Consolas_Regular_11">push</samp> / <samp class="SANS_Consolas_Regular_11">pop</samp> <i>segmentName i</i>” command) should be translated into assembly code that accesses address <img alt="" class="inline" height="14" src="../images/137.png" width="61"/> in the RAM, where <i>base</i> is one of the pointers <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, or <samp class="SANS_Consolas_Regular_11">THAT</samp>.</p>
<p class="STNI1"><b>Pointer</b>: Unlike the virtual segments described above, the <samp class="SANS_Consolas_Regular_11">pointer</samp> segment contains exactly two values and is mapped directly onto RAM locations 3 and 4. Recall that these RAM locations are also called, respectively, <samp class="SANS_Consolas_Regular_11">THIS</samp> and <samp class="SANS_Consolas_Regular_11">THAT</samp>. Thus, the semantics of the <samp class="SANS_Consolas_Regular_11">pointer</samp> segment is as follows. Any access to <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp> should result in accessing the <samp class="SANS_Consolas_Regular_11">THIS</samp> pointer, and any access to <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">1</samp> should result in accessing the <samp class="SANS_Consolas_Regular_11">THAT</samp> pointer. For example, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">0</samp> should set <samp class="SANS_Consolas_Regular_11">THIS</samp> to the popped value, and <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">1</samp> should push onto the stack the current value of <samp class="SANS_Consolas_Regular_11">THAT</samp>. These peculiar semantics will make perfect sense when we write the compiler in chapters 10–11, so stay tuned.</p>
<p class="STNI1"><b>Temp</b>: This 8-word segment is also fixed and mapped directly on RAM locations 5 – 12. With that in mind, any access to <samp class="SANS_Consolas_Regular_11">temp</samp> <i>i</i>, where <i>i</i> varies from 0 to 7, should be translated into assembly code that accesses RAM location <img alt="" class="inline" height="12" src="../images/7-6.png" width="31"/></p>
<p class="STNI1"><b>Constant</b>: This virtual memory segment is truly virtual, as it does not occupy any physical RAM space. Instead, the VM implementation handles any access to <samp class="SANS_Consolas_Regular_11">constant</samp> <i>i</i> by simply supplying the constant <i>i</i>. For example, the command <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <samp class="SANS_Consolas_Regular_11">17</samp> should be translated into assembly code that pushes the value 17 onto the stack.</p>
<p class="STNI1"><b>Static</b>: Static variables are mapped on addresses 16 to 255 of the host RAM. The VM translator can realize this mapping automatically, as follows. Each reference to <samp class="SANS_Consolas_Regular_11">static</samp> <i>i</i> in <span aria-label="138" id="pg_138" role="doc-pagebreak"/>a VM program stored in file <samp class="SANS_Consolas_Regular_11">Foo.vm</samp> can be translated to the assembly symbol <samp class="SANS_Consolas_Regular_11">Foo.</samp><i>i</i>. According to the <i>Hack machine language specification</i> (chapter 6), the Hack assembler will map these symbolic variables on the host RAM, starting at address 16. This convention will cause the static variables that appear in a VM program to be mapped on addresses 16 and onward, <i>in the order in which they appear in the VM code</i>. For example, suppose that a VM program starts with the code <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <samp class="SANS_Consolas_Regular_11">100</samp>, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <samp class="SANS_Consolas_Regular_11">200</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">5</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">2</samp>. The translation scheme described above will cause <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">5</samp> and <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">2</samp> to be mapped on RAM addresses 16 and 17, respectively.</p>
<p>This implementation of static variables is somewhat devious, but works well. It causes the static variables of different VM files to coexist without intermingling, since their generated <i>FileName</i><samp class="SANS_Consolas_Regular_11">.</samp><i>i</i> symbols have unique prefix file names. We note in closing that since the stack begins at address 256, the implementation limits the number of static variables in a Jack program to <img alt="" class="inline" height="12" src="../images/7-7.png" width="123"/></p>
<p class="STNI1"><b>Assembly language symbols</b>: Let us summarize all the special symbols mentioned above. Suppose that the VM program that we have to translate is stored in a file named <samp class="SANS_Consolas_Regular_11">Foo.vm</samp>. VM translators conforming to the standard <i>VM mapping on the Hack platform</i> generate assembly code that uses the following symbols: <samp class="SANS_Consolas_Regular_11">SP</samp>, <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, <samp class="SANS_Consolas_Regular_11">THAT</samp>, and <samp class="SANS_Consolas_Regular_11">Foo.</samp><i>i</i>, where <i>i</i> is a nonnegative integer. If they need to generate code that uses variables for temporary storage, VM translators can use the symbols <samp class="SANS_Consolas_Regular_11">R13</samp>, <samp class="SANS_Consolas_Regular_11">R14</samp>, and <samp class="SANS_Consolas_Regular_11">R15</samp>.</p>
</section>
<section>
<h3 class="head b-head"><b>7.4.2    The VM Emulator</b></h3>
<p class="noindent">One relatively simple way to implement a virtual machine is to write a high-level program that represents the stack and the memory segments and implements all the VM commands using high-level programming. For example, if we represent the stack using a sufficiently-large array named <samp class="SANS_Consolas_Regular_11">stack</samp>, then push and pop operations can be directly realized using high-level statements like <img alt="" class="inline" height="14" src="../images/7-C10.png" width="112"/> and <img alt="" class="inline" height="14" src="../images/7-C11.png" width="109"/> respectively. The virtual memory segments can also be handled using arrays.</p>
<p>If we want this VM emulation program to be fancy, we can augment it with a graphical interface, allowing users to experiment with VM commands and visually inspect their impact on images of the stack and the memory segments. The Nand to Tetris software suite includes one such emulator, written in Java (see <a href="chapter_7.xhtml#fig7-6" id="rfig7-6">figure 7.6</a>). This handy program allows loading and executing VM code as is and observing visually, during simulated run-time, how the VM commands effect the states of the emulated stack and memory segments. In addition, the emulator shows how the stack and the memory segments are mapped on the host RAM and how the RAM state changes when VM commands execute. The supplied VM emulator is a cool program—try it!</p>
<figure class="IMG"><img alt="" id="fig7-6" src="../images/figure_7.6.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig7-6">Figure 7.6</a></b>    The VM emulator supplied with the Nand to Tetris software suite.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><span aria-label="139" id="pg_139" role="doc-pagebreak"/><b>7.4.3    Design Suggestions for the VM Implementation</b></h3>
<p class="noindent"><b>Usage</b>: The VM translator accepts a single command-line argument, as follows:</p>
<p class="COM2"><samp class="SANS_Consolas_Regular_11">prompt</samp><span class="symb">&gt;</span> <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> <i>source</i></p>
<p class="noindent">where <i>source</i> is a file name of the form <i>ProgName</i><samp class="SANS_Consolas_Regular_11">.vm</samp>. The file name may contain a file path. If no path is specified, the VM translator operates on the current folder. The first character in the file name must be an uppercase letter, and the <samp class="SANS_Consolas_Regular_11">vm</samp> extension is mandatory. The file contains a sequence of one or more VM commands. In response, the translator creates an output file, named <i>ProgName</i><samp class="SANS_Consolas_Regular_11">.asm</samp>, containing the assembly instructions that realize the VM commands. The output file <i>ProgName</i><samp class="SANS_Consolas_Regular_11">.asm</samp> is stored in the same folder as that of the input. If the file <i>ProgName</i><samp class="SANS_Consolas_Regular_11">.asm</samp> already exists, it will be overwritten.</p>
</section>
<section>
<h3 class="head b-head"><b>Program Structure</b></h3>
<p class="noindent">We propose implementing the VM translator using three modules: a main program called <samp class="SANS_Consolas_Regular_11">VMTranslator</samp>, a <samp class="SANS_Consolas_Regular_11">Parser</samp>, and a <samp class="SANS_Consolas_Regular_11">CodeWriter</samp>. The <samp class="SANS_Consolas_Regular_11">Parser</samp>’s job is to make sense out of each VM command, that is, understand what the command seeks to do. The <samp class="SANS_Consolas_Regular_11">CodeWriter</samp>’s job is <span aria-label="140" id="pg_140" role="doc-pagebreak"/>to translate the understood VM command into assembly instructions that realize the desired operation on the Hack platform. The <samp class="SANS_Consolas_Regular_11">VMTranslator</samp> drives the translation process.</p>
</section>
<section>
<h3 class="head b-head"><b>The Parser</b></h3>
<p class="noindent">This module handles the parsing of a single <samp class="SANS_Consolas_Regular_11">.vm</samp> file. The parser provides services for reading a VM command, unpacking the command into its various components, and providing convenient access to these components. In addition, the parser ignores all white space and comments. The parser is designed to handle all the VM commands, including the <i>branching</i> and <i>function</i> commands that will be implemented in chapter 8.</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_7.4.png"/></figure>
<p>For example, if the current command is <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, then calling <samp class="SANS_Consolas_Regular_11">arg1()</samp> and <samp class="SANS_Consolas_Regular_11">arg2()</samp> would return, respectively, <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">local</samp><samp class="SANS_Consolas_Regular_11">"</samp> and <samp class="SANS_Consolas_Regular_11">2</samp>. If the current command is <samp class="SANS_Consolas_Regular_11">add</samp>, then calling <samp class="SANS_Consolas_Regular_11">arg1()</samp> would return <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">add</samp><samp class="SANS_Consolas_Regular_11">"</samp>, and <samp class="SANS_Consolas_Regular_11">arg2()</samp> would not be called.</p>
</section>
<section>
<h3 class="head b-head"><span aria-label="141" id="pg_141" role="doc-pagebreak"/><b>The CodeWriter</b></h3>
<p class="noindent">This module translates a parsed VM command into Hack assembly code.</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_7.5.png"/></figure>
<p class="TNI1">For example, calling <samp class="SANS_Consolas_Regular_11">writePushPop</samp> <samp class="SANS_Consolas_Regular_11">(C_PUSH,</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">local</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">,2)</samp> would result in generating assembly instructions that implement the VM command <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">2</samp>. Another example: Calling <samp class="SANS_Consolas_Regular_11">WriteArithmetic(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">add</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp> would result in generating assembly instructions that pop the two topmost elements from the stack, add them up, and push the result onto the stack.</p>
</section>
<section>
<h3 class="head b-head"><b>The VM Translator</b></h3>
<p class="noindent">This is the main program that drives the translation process, using the services of a <samp class="SANS_Consolas_Regular_11">Parser</samp> and a <samp class="SANS_Consolas_Regular_11">CodeWriter</samp>. The program gets the name of the input source file, say <i>Prog</i><samp class="SANS_Consolas_Regular_11">.vm</samp>, from the command-line argument. It constructs a <samp class="SANS_Consolas_Regular_11">Parser</samp> for parsing the input file <i>Prog</i><samp class="SANS_Consolas_Regular_11">.vm</samp> and creates an output file, <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp>, into which it will write the translated assembly instructions. The program then enters a loop that iterates through the VM commands in the input file. For each command, the program uses the <samp class="SANS_Consolas_Regular_11">Parser</samp> and the <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> services for parsing the command into its fields and then generating from them a sequence of assembly instructions. The instructions are written into the output <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> <samp class="SANS_Consolas_Regular_11">file</samp>.</p>
<p>We provide no API for this module, inviting you to implement it as you see fit.</p>
</section>
<section>
<h3 class="head b-head"><b>Implementation Tips</b></h3>
<ol class="List-1">
<li class="NL" value="1">When starting to translate a VM command, for example, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">2</samp>, consider generating, and emitting to the output assembly code stream, a comment like <samp class="SANS_Consolas_Regular_11">//</samp> <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">2</samp>. These comments will help you read the generated code and debug your translator if needed.</li>
<li class="NL">Almost every VM command needs to push data onto and/or pop data off the stack. Therefore, your <samp class="SANS_Consolas_Regular_11">write</samp><i>Xxx</i> routines will need to output similar assembly instructions over and <span aria-label="142" id="pg_142" role="doc-pagebreak"/>over. To avoid writing repetitive code, consider writing and using private routines (sometimes called <i>helper methods</i>) that generate these frequently used code snippets.</li>
<li class="NL">As was explained in chapter 6, it is recommended to end each machine language program with an infinite loop. Therefore, consider writing a private routine that writes the infinite loop code in assembly. Call this routine once, when you are done translating all the VM commands.</li>
</ol>
</section>
</section>
<section>
<h2 class="head a-head"><b>7.5    Project</b></h2>
<p class="noindent">Basically, you have to write a program that reads VM commands, one command at a time, and translates each command into Hack instructions. For example, how should we handle the VM command <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">2</samp>? <i>Tip:</i> We should write several Hack assembly instructions that, among other things, manipulate the <samp class="SANS_Consolas_Regular_11">SP</samp> and <samp class="SANS_Consolas_Regular_11">LCL</samp> pointers. Coming up with a sequence of Hack instructions that realizes each one of the VM arithmetic-logical and push/pop commands is the very essence of this project. That’s what code generation is all about.</p>
<p>We recommend you start by writing and testing these assembly code snippets on paper. Draw a RAM segment, draw a trace table that records the values of, say, <samp class="SANS_Consolas_Regular_11">SP</samp> and <samp class="SANS_Consolas_Regular_11">LCL</samp>, and initialize these variables to arbitrary memory addresses. Now, track on paper the assembly code that you think realizes say, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">2</samp>. Does the code impact the stack and the <samp class="SANS_Consolas_Regular_11">local</samp> segments correctly (RAM-wise)? Did you remember to update the stack pointer? And so on. Once you feel confident that your assembly code snippets do their jobs correctly, you can have your <samp class="SANS_Consolas_Regular_11">CodeWriter</samp> generate them, almost as is.</p>
<p>Since your VM translator has to write assembly code, you must flex your low-level Hack programming muscles. The best way to do it is by reviewing the assembly program examples in chapter 4 and the programs that you wrote in project 4. If you need to consult the Hack assembly language documentation, see section 4.2.</p>
<p class="STNI1"><b>Objective</b>: Build a basic VM translator designed to implement the <i>arithmetic-logical</i> and <i>push</i> / <i>pop</i> commands of the VM language.</p>
<p>This version of the VM translator assumes that the source VM code is error-free. Error checking, reporting, and handling can be added to later versions of the VM translator but are not part of project 7.</p>
<p class="STNI1"><b>Resources</b>: You will need two tools: the programming language in which you will implement the VM translator and the <i>CPU emulator</i> supplied in your <samp class="SANS_Consolas_Regular_11">nand2tetris/tools</samp> folder. The CPU emulator will allow you to execute and test the assembly code generated by your translator. If the generated code runs correctly in the CPU emulator, we will assume that your VM translator performs as expected. This is just a partial test of the translator, but it will suffice for our purposes.</p>
<p><span aria-label="143" id="pg_143" role="doc-pagebreak"/>Another tool that comes in handy in this project is the <i>VM emulator</i>, also supplied in your <samp class="SANS_Consolas_Regular_11">nand2tetris/tools</samp> folder. We encourage using this program for executing the supplied test programs and watching how the VM code effects the (simulated) states of the stack and the virtual memory segments. For example, suppose that a test program pushes a few constants onto the stack and then pops them into the <samp class="SANS_Consolas_Regular_11">local</samp> segment. You can run the test program on the VM emulator, inspect how the stack grows and shrinks, and see how the <samp class="SANS_Consolas_Regular_11">local</samp> segment becomes populated with values. This can help you understand which actions the VM translator is supposed to generate before setting out to implement it.</p>
<p class="STNI1"><b>Contract</b>: Write a VM-to-Hack translator conforming to the VM Specification given in section 7.3 and to the standard VM mapping on the Hack platform given in section 7.4.1. Use your translator to translate the supplied test VM programs, yielding corresponding programs written in the Hack assembly language. When executed on the supplied CPU emulator, the assembly programs generated by your translator should deliver the results mandated by the supplied test scripts and compare files.</p>
<section>
<h3 class="head b-head"><b>Testing and Implementation Stages</b></h3>
<p class="noindent">We provide five test VM programs. We advise developing and testing your evolving translator on the test programs in the order in which they are given. This way, you will be implicitly guided to build the translator’s code generation capabilities gradually, according to the demands presented by each test program.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">SimpleAdd</samp>: This program pushes two constants onto the stack and adds them up. Tests how your implementation handles the commands <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">constant</samp> <i>i</i> and <samp class="SANS_Consolas_Regular_11">add</samp>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">StackTest</samp>: Pushes some constants onto the stack and tests how your implementation handles all the arithmetic-logical commands.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">BasicTest</samp>: Executes push, pop, and arithmetic commands using the memory segments <samp class="SANS_Consolas_Regular_11">constant</samp>, <samp class="SANS_Consolas_Regular_11">local</samp>, <samp class="SANS_Consolas_Regular_11">argument</samp>, <samp class="SANS_Consolas_Regular_11">this</samp>, <samp class="SANS_Consolas_Regular_11">that</samp>, and <samp class="SANS_Consolas_Regular_11">temp</samp>. Tests how your implementation handles these memory segments (you’ve already handled <samp class="SANS_Consolas_Regular_11">constant</samp>).</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">PointerTest</samp>: Executes push, pop, and arithmetic commands using the memory segments <samp class="SANS_Consolas_Regular_11">pointer</samp>, <samp class="SANS_Consolas_Regular_11">this</samp>, and <samp class="SANS_Consolas_Regular_11">that</samp>. Tests how your implementation handles the <samp class="SANS_Consolas_Regular_11">pointer</samp> segment.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">StaticTest</samp>: Executes push, pop, and arithmetic commands using constants and the memory segment <samp class="SANS_Consolas_Regular_11">static</samp>. Tests how your implementation handles the <samp class="SANS_Consolas_Regular_11">static</samp> segment.</p>
<p class="STNI1"><b>Initialization</b>: In order for any translated VM program to start running, it must include startup code that forces the generated assembly code to start executing on the host platform. <span aria-label="144" id="pg_144" role="doc-pagebreak"/>And, before this code starts running, the VM implementation must anchor the base addresses of the stack and the virtual memory segments in selected RAM locations. Both issues—startup code and segments initializations—are described and implemented in the next chapter. The difficulty here is that we need these initializations in place for executing the test programs in this project. The good news is that you need not worry about these details, since all the initializations necessary for this project are handled “manually” by the supplied test scripts.</p>
<p class="STNI1"><b>Testing / Debugging:</b> We supply five sets of test programs, test scripts, and compare files. For each test program <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp> we recommend following these steps:</p>
<p class="NLF"><span class="nl">0.</span>  Use the <i>Xxx</i><samp class="SANS_Consolas_Regular_11">VME.tst</samp> script to execute the test program <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp> on the supplied VM emulator. This will familiarize you with the intended behavior of the test program. Inspect the simulated stack and virtual segments, and make sure that you understand what the test program is doing.</p>
<p class="NL"><span class="nl">1.  </span>Use your partially implemented translator to translate the file <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp> (test program). The result should be a text file named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.asm</samp>, containing the Hack assembly code generated by your translator.</p>
<p class="NL"><span class="nl">2.  </span>Inspect the generated <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.asm</samp> code produced by your translator. If there are visible errors, debug and fix your translator.</p>
<p class="NL"><span class="nl">3.  </span>Use the supplied <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.tst</samp> and <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.cmp</samp> files to run and test your translated <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.asm</samp> program on the supplied <i>CPU emulator</i>. If there are any errors, debug and fix your translator.</p>
<p class="STNI1">When you are done with this project, be sure to save a copy of your VM translator. In the next chapter you will be asked to extend this program, adding the handling of more VM commands. If your project 8 modifications end up breaking the code developed in project 7, you’ll be able to resort to your backup version.</p>
<p class="STNI1"><b>A web-based version of project 7</b> is available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>7.6    Perspective</b></h2>
<p class="noindent">In this chapter we began the process of developing a compiler for a high-level language. Following modern software engineering practices, we have chosen to base the compiler on a two-tier compilation model. In the <i>front-end</i> tier, covered in chapters 10 and 11, the high-level code is translated into an intermediate code designed to run on a virtual machine. In the <i>back-end</i> tier, covered in this and in the next chapter, the intermediate code is translated further into the machine language of a target hardware platform (see <a href="chapter_7.xhtml#fig7-1">figure 7.1</a>).</p>
<p><span aria-label="145" id="pg_145" role="doc-pagebreak"/>Over the years, this two-stage compilation model has been used—implicitly and explicitly—in many compiler construction projects. In the late 1970s, IBM and Apple corporations introduced two pioneering and phenomenally successful personal computers, known as the IBM PC and the Apple II. One high-level language that became popular on these early PCs was Pascal. Alas, different Pascal compilers had to be developed, since the IBM and Apple machines used different processors, different machine languages, and different operating systems. Also, IBM and Apple were rival companies and had no interest in helping developers port their software to the other machine. As a result, software developers who wanted their Pascal apps to run on both lines of computers had to use different compilers, each designed to generate machine-specific binary code. Could there not be a better way to handle cross-platform compilation, so that programs could be written once and run everywhere?</p>
<p>One solution to this challenge was an early virtual machine framework called <i>p-code</i>. The basic idea was to compile Pascal programs into intermediate p-code (similar to our VM language) and then use one implementation for translating the abstract p-code into Intel’s x86 instruction set, used by IBM PCs, and another implementation for translating the same p-code into Motorola’s 68000 instruction set, used by Apple computers. Meanwhile, other companies developed highly optimized Pascal compilers that generated efficient p-code. The net result was that the same Pascal program could run as is on practically every machine in this nascent PC market: no matter which computer your customers used, you could ship them exactly the same p-code files, obviating the need to use multiple compilers. Of course, the whole scheme was based on the assumption that the customer’s computer was equipped with a client-side p-code implementation (equivalent to our VM translator). To make this happen, the p-code implementations were distributed freely over the Internet, and customers were invited to download them to their computers. Historically, this was perhaps the first time that the notion of a cross-platform high-level language began realizing its full potential.</p>
<p>Following the explosive growth of the Internet and mobile devices in the mid-1990s, cross-platform compatibility became a universally vexing issue. To address the problem, the Sun Microsystems company (later acquired by Oracle) sought to develop a new programming language whose compiled code could potentially run as is on any computer and digital device connected to the Internet. The language that emerged from this initiative—<i>Java</i>—was founded on an intermediate code execution model called the <i>Java Virtual Machine</i>, or JVM.</p>
<p>The JVM is a specification that describes an intermediate language called <i>bytecode</i>—the target VM language of Java compilers. Files written in bytecode are widely used for code distribution of Java programs over the Internet. In order to execute these portable programs, the client PCs, tablets, and cell phones that download them must be equipped with suitable JVM implementations, known as JREs (Java Runtime Environments). These programs are widely available for numerous processor and operating system combinations. Today, many personal computer and cell phone owners use these infrastructure programs (the JREs) routinely and implicitly, without ever noticing their existence on their devices.</p>
<p><span aria-label="146" id="pg_146" role="doc-pagebreak"/>The Python language, conceived in the late 1980s, is also based on a two-tier translation model, whose centerpiece is the PVM (Python Virtual Machine), which uses its own version of bytecode.</p>
<p>In the early 2000s, Microsoft launched its .NET Framework. The centerpiece of .NET is a virtual machine framework called <i>Common Language Runtime</i> (CLR). According to Microsoft’s vision, many programming languages, like C# and C<span class="symb">++</span>, can be compiled into intermediate code running on the CLR. This enables code written in different languages to interoperate and share the software libraries of a common run-time environment. Of course, single-tier compilers for C and C<span class="symb">++</span> are still widely used, especially in high-performance applications requiring tight and optimized code.</p>
<p>Indeed, one issue that was completely sidestepped in this chapter is <i>efficiency</i>. Our contract calls for developing a VM translator, without requiring that the generated assembly code be efficient. Clearly, this is a serious oversight. The VM translator is a mission-critical enabling technology, lying at the core of your PC, tablet, or cell phone: if it will generate tight and efficient low-level code, apps will run on your machine swiftly, using as little hardware resources as possible. Therefore, optimizing the VM translator is a top priority.</p>
<p>In general, there are numerous opportunities to optimize the VM translator. For example, assignments like <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="11" src="../images/7-C12.png" width="32"/> are prevalent in high-level code; these statements are translated by the compiler into VM commands like, for example, <samp class="SANS_Consolas_Regular_11">push</samp> <samp class="SANS_Consolas_Regular_11">local</samp> <samp class="SANS_Consolas_Regular_11">3</samp> followed by <samp class="SANS_Consolas_Regular_11">pop</samp> <samp class="SANS_Consolas_Regular_11">static</samp> <samp class="SANS_Consolas_Regular_11">1</samp>. Clever implementations of such pairs of VM commands can generate assembly code that sidesteps the stack completely, resulting in dramatic performance gains. Of course, this is one out of many examples of possible VM optimizations. Indeed, over the years, the VM implementations of Java, Python, and C# became dramatically more powerful and sophisticated.</p>
<p>We note in closing that a crucial ingredient that must be added to the virtual machine model before its full potential is unleashed is a common software library. Indeed the Java Virtual Machine comes with the <i>standard Java class library</i>, and the Microsoft’s .NET Framework comes with the <i>Framework Class Library</i>. These vast software libraries can be viewed as portable operating systems, providing numerous services like memory management, GUI toolkits, string functions, math functions, and so on. These extensions will be described and built in chapter 12.</p>
</section>
</section>
</div>
</body>
</html>