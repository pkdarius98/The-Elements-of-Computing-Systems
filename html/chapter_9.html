<html lang="en">
<head>
<title>9 High-Level Language</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch9"role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch9"><span aria-label="171" id="pg_171" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">9</samp>       <samp class="SANS_Helvetica_LT_Std_Bold_B_11">High-Level Language</samp></h1>
</header>
<blockquoterole="doc-epigraph">
<p class="EP1">High thoughts need a high language.</p>
<p class="EPA1">—Aristophanes (427–386 B.C.)</p>
</blockquote>
<p class="noindent">The assembly and VM languages presented so far in this book are low-level, meaning that they are intended for controlling machines, not for developing applications. In this chapter we present a high-level language, called Jack, designed to enable programmers to write high-level programs. Jack is a simple object-based language. It has the basic features and flavor of mainstream languages like Java and C<span class="symb">++</span>, with a simpler syntax and no support for inheritance. Despite this simplicity, Jack is a general-purpose language that can be used to create numerous applications. In particular, it lends itself nicely to interactive games like Tetris, Snake, Pong, Space Invaders, and similar classics.</p>
<p>The introduction of Jack marks the beginning of the end of our journey. In chapters 10 and 11 we will write a compiler that translates Jack programs into VM code, and in chapter 12 we will develop a simple operating system for the Jack/Hack platform. This will complete the computer’s construction. With that in mind, it’s important to say at the outset that the goal of this chapter is not to turn you into a Jack programmer. Neither do we claim that Jack is an important language outside the Nand to Tetris context. Rather, we view Jack as a necessary scaffold for chapters 10–12, in which we will build a compiler and an operating system that make Jack possible.</p>
<p>If you have any experience with a modern object-oriented programming language, you will immediately feel at home with Jack. Therefore, we begin the chapter with a few representative examples of Jack programs. All these programs can be compiled by the Jack compiler supplied in <samp class="SANS_Consolas_Regular_11">nand2tetris/tools</samp>. The VM code produced by the compiler can then be executed as is on any VM implementation, including the supplied VM emulator. Alternatively, you can translate the compiled VM code further into machine language, using the VM translator built in chapters 7–8. The resulting assembly code can then be executed on the supplied CPU emulator or translated further into binary code and executed on the hardware platform built in chapters 1–5.</p>
<p><span aria-label="172" id="pg_172" role="doc-pagebreak"/>Jack is a simple language, and this simplicity has a purpose. First, you can learn (and unlearn) Jack in about one hour. Second, the Jack language was carefully designed to lend itself nicely to common compilation techniques. As a result, you can write an elegant <i>Jack compiler</i> with relative ease, as we will do in chapters 10 and 11. In other words, the deliberately simple structure of Jack is designed to help uncover the software infrastructure of modern languages like Java and C#. Rather than taking the compilers and run-time environments of these languages apart, we find it more instructive to build a compiler and a run-time environment ourselves, focusing on the most important ideas underlying their construction. This will be done later, in the last three chapters of the book. Presently, let’s take Jack out of the box.</p>
<section>
<h2 class="head a-head"><b>9.1    Examples</b></h2>
<p class="noindent">Jack is mostly self-explanatory. Therefore, we defer the language specification to the next section and start with examples. The first example is the inevitable <i>Hello World</i> program. The second example illustrates procedural programming and array processing. The third example illustrates how abstract data types can be implemented in the Jack language. The fourth example illustrates a linked list implementation using the language’s object-handling capabilities.</p>
<p>Throughout the examples, we discuss briefly various object-oriented idioms and commonly used data structures. We assume that the reader has a basic familiarity with these subjects. If not, read on—you’ll manage.</p>
<p class="STNI1"><b>Example 1: Hello World:</b> The program shown in <a href="chapter_9.html#fig9-1" id="rfig9-1">figure 9.1</a> illustrates several basic Jack features. By convention, when we execute a compiled Jack program, execution always starts with the <samp class="SANS_Consolas_Regular_11">Main.main</samp> function. Thus, each Jack program must include at least one class, named <samp class="SANS_Consolas_Regular_11">Main</samp>, and this class must include at least one function, named <samp class="SANS_Consolas_Regular_11">Main.main</samp>. This convention is illustrated in <a href="chapter_9.html#fig9-1">figure 9.1</a>.</p>
<figure class="IMG"><img alt="" id="fig9-1" src="../images/figure_9.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-1">Figure 9.1</a></b>    <i>Hello World</i>, written in the Jack language.</p></figcaption>
</figure>
<p><span aria-label="173" id="pg_173" role="doc-pagebreak"/>Jack comes with a <i>standard class library</i> whose complete API is given in appendix 6. This software library, also known as the <i>Jack OS</i>, extends the basic language with various abstractions and services such as mathematical functions, string processing, memory management, graphics, and input/output functions. Two such OS functions are invoked by the Hello World program, affecting the program’s output. The program also illustrates the comment formats supported by Jack.</p>
<p class="STNI1"><b>Example 2: Procedural programming and array handling</b>: Jack features typical statements for handling assignment and iteration. The program shown in <a href="chapter_9.html#fig9-2" id="rfig9-2">figure 9.2</a> illustrates these capabilities in the context of array processing.</p>
<figure class="IMG"><img alt="" id="fig9-2" src="../images/figure_9.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-2">Figure 9.2</a></b>    Typical procedural programming and simple array handling. Uses the services of the OS classes <samp class="SANS_Consolas_Regular_11">Array</samp>, <samp class="SANS_Consolas_Regular_11">Keyboard</samp>, and <samp class="SANS_Consolas_Regular_11">Output</samp>.</p></figcaption>
</figure>
<p>Most high-level programming languages feature array declaration as part of the basic syntax of the language. In Jack, we have opted for treating arrays as instances of an <samp class="SANS_Consolas_Regular_11">Array</samp> class, which is part of the OS that extends the basic language. This was done for pragmatic reasons, as it simplifies the construction of Jack compilers.</p>
<p class="STNI1"><b>Example 3: Abstract data types</b>: Every programming language features a fixed set of primitive data types, of which Jack has three: <samp class="SANS_Consolas_Regular_11">int</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, and <samp class="SANS_Consolas_Regular_11">boolean</samp>. In object-based languages, programmers can introduce new types by creating classes that represent abstract <span aria-label="174" id="pg_174" role="doc-pagebreak"/>data types as needed. For example, suppose we wish to endow Jack with the ability to handle rational numbers like 2/3 and 314159/100000 without loss of precision. This can be done by developing a standalone Jack class designed to create and manipulate fraction objects of the form <i>x/y</i>, where <i>x</i> and <i>y</i> are integers. This class can then provide a fraction abstraction to any Jack program that needs to represent and manipulate rational numbers. We now turn to describe how a <samp class="SANS_Consolas_Regular_11">Fraction</samp> class can be used and developed. This example illustrates typical multi-class, object-based programming in Jack.</p>
<p class="STNI1"><b>Using classes</b>: <a href="chapter_9.html#fig9-3a" id="rfig9-3a">Figure 9.3a</a> lists a class skeleton (a set of method signatures) that specifies some of the services that one can reasonably expect to get from a fraction abstraction. Such a specification is often called an <i>Application Program Interface</i>. The client code at the bottom of the figure illustrates how this API can be used for creating and manipulating fraction objects.</p>
<figure class="IMG"><img alt="" id="fig9-3a" src="../images/figure_9.3a.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-3a">Figure 9.3a</a></b>    <samp class="SANS_Consolas_Regular_11">Fraction</samp> API (top) and sample Jack class that uses it for creating and manipulating <samp class="SANS_Consolas_Regular_11">Fraction</samp> objects.</p></figcaption>
</figure>
<p><a href="chapter_9.html#fig9-3a">Figure 9.3a</a> illustrates an important software engineering principle: users of an abstraction (like <samp class="SANS_Consolas_Regular_11">Fraction</samp>) don’t have to know anything about its implementation. All they need is the class <i>interface</i>, also known as API. The API informs what functionality the class offers and how to use this functionality. That’s all the client needs to know.</p>
<p class="STNI1"><span aria-label="175" id="pg_175" role="doc-pagebreak"/><b>Implementing classes</b>: So far, we have seen only the client perspective of the <samp class="SANS_Consolas_Regular_11">Fraction</samp> class—the view from which <samp class="SANS_Consolas_Regular_11">Fraction</samp> is used as a black box abstraction. <a href="chapter_9.html#fig9-3b" id="rfig9-3b">Figure 9.3b</a> lists one possible implementation of this abstraction.</p>
<figure class="IMG"><img alt="" id="fig9-3b" src="../images/figure_9.3b.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-3b">Figure 9.3b</a></b>    A Jack implementation of the <samp class="SANS_Consolas_Regular_11">Fraction</samp> abstraction.</p></figcaption>
</figure>
<p>The <samp class="SANS_Consolas_Regular_11">Fraction</samp> class illustrates several key features of object-based programming in Jack. <i>Fields</i> specify object properties (also called <i>member variables</i>). <i>Constructors</i> are subroutines that create new objects, and <i>methods</i> are subroutines that operate on the current object (referred to using the keyword <samp class="SANS_Consolas_Regular_11">this</samp>). <i>Functions</i> are class-level subroutines (also called <i>static methods</i>) that operate on no particular object. The <samp class="SANS_Consolas_Regular_11">Fraction</samp> class also demonstrates all the statement types available in the Jack language: <samp class="SANS_Consolas_Regular_11">let</samp>, <samp class="SANS_Consolas_Regular_11">do</samp>, <samp class="SANS_Consolas_Regular_11">if</samp>, <samp class="SANS_Consolas_Regular_11">while</samp>, and <samp class="SANS_Consolas_Regular_11">return</samp>. The <samp class="SANS_Consolas_Regular_11">Fraction</samp> class is of course just one example of the unlimited number of classes that can be created in Jack to support any conceivable programming objective.</p>
<p class="STNI1"><b>Example 4: Linked list implementation</b>: The data structure <i>list</i> is defined recursively as a value, followed by a list. The value <samp class="SANS_Consolas_Regular_11">null</samp>—the definition’s base case—is also considered a list. <a href="chapter_9.html#fig9-4" id="rfig9-4">Figure 9.4</a> shows a possible Jack implementation of a list of integers. This example illustrates how Jack can be used for realizing a major data structure, widely used in computer science.</p>
<figure class="IMG"><img alt="" id="fig9-4" src="../images/figure_9.4.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-4">Figure 9.4</a></b>    Linked list implementation in Jack (left and top right) and sample usage (bottom right).</p></figcaption>
</figure>
<p class="STNI1"><b>The operating system</b>: Jack programs make extensive use of the Jack operating system, which will be discussed and developed in chapter 12. For now, suffice it to say that Jack <span aria-label="176" id="pg_176" role="doc-pagebreak"/>programs use the OS services abstractly, without paying attention to their underlying implementation. Jack programs can use the OS services directly—there is no need to include or import any external code.</p>
<p>The OS consists of eight classes, summarized in <a href="chapter_9.html#fig9-5" id="rfig9-5">figure 9.5</a> and documented in appendix 6.</p>
<span aria-label="177" id="pg_177" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" id="fig9-5" src="../images/figure_9.5.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-5">Figure 9.5</a></b>    Operating system services (summary). The complete OS API is given in appendix 6.</p></figcaption>
</figure>
</section>
<section>
<h2 class="head a-head"><b>9.2    The Jack Language Specification</b></h2>
<p class="noindent">This section can be read once and then used as a technical reference, to be consulted as needed.</p>
<section>
<h3 class="head b-head"><b>9.2.1    Syntactic Elements</b></h3>
<p class="noindent">A Jack program is a sequence of tokens, separated by an arbitrary amount of white space and comments. Tokens can be symbols, reserved words, constants, and identifiers, as listed in <a href="chapter_9.html#fig9-6" id="rfig9-6">figure 9.6</a>.</p>
<figure class="IMG"><img alt="" height="550" id="fig9-6" src="../images/figure_9.6.png"/>
<figcaption><p class="CAP"><b><a href="#rfig9-6">Figure 9.6</a></b>    The syntax elements of the Jack language.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><b>9.2.2    Program Structure</b></h3>
<p class="noindent">A Jack program is a collection of one or more classes stored in the same folder. One class must be named <samp class="SANS_Consolas_Regular_11">Main</samp>, and this class must have a function named <samp class="SANS_Consolas_Regular_11">main</samp>. The execution of a compiled Jack program always starts with the <samp class="SANS_Consolas_Regular_11">Main.main</samp> function.</p>
<p>The basic programming unit in Jack is a <i>class</i>. Each class <i>Xxx</i> resides in a separate file named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> and is compiled separately. By convention, class names begin with an uppercase letter. The file name must be identical to the class name, including capitalization. The class declaration has the following structure:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.1.png"/></figure>
<p>Each class declaration specifies a name through which the class services can be globally accessed. Next comes a sequence of zero or more field declarations and zero or more static variable declarations. Next comes a sequence of one or more subroutine declarations, each defining a <i>method</i>, a <i>function</i>, or a <i>constructor</i>.</p>
<p><i>Methods</i> are designed to operate on the current object. <i>Functions</i> are class-level <i>static methods</i> that are not associated with any particular object. <i>Constructors</i> create and return new objects of the class type. A subroutine declaration has the following structure:<span aria-label="178" id="pg_178" role="doc-pagebreak"/></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.2.png"/></figure>
<p class="TNI1">where <i>subroutine</i> is either <samp class="SANS_Consolas_Regular_11">constructor</samp>, <samp class="SANS_Consolas_Regular_11">method</samp>, or <samp class="SANS_Consolas_Regular_11">function</samp>. Each subroutine has a <i>name</i> through which it can be accessed and a <i>type</i> specifying the data type of the value returned by the subroutine. If the subroutine is designed to return no value, its type is declared <samp class="SANS_Consolas_Regular_11">void</samp>. The <i>parameter-list</i> is a comma-separated list of <span class="symb">&lt;</span><i>type identifier</i><span class="symb">&gt;</span> pairs, for example, (<samp class="SANS_Consolas_Regular_11">int</samp> <samp class="SANS_Consolas_Regular_11">x,</samp> <samp class="SANS_Consolas_Regular_11">boolean</samp> <samp class="SANS_Consolas_Regular_11">sign,</samp> <samp class="SANS_Consolas_Regular_11">Fraction</samp> <samp class="SANS_Consolas_Regular_11">g</samp>).</p>
<p><span aria-label="179" id="pg_179" role="doc-pagebreak"/>If the subroutine is a <i>method</i> or a <i>function</i>, its return type can be any of the primitive data types supported by the language (<samp class="SANS_Consolas_Regular_11">int</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, or <samp class="SANS_Consolas_Regular_11">boolean</samp>), any of the class types supplied by the standard class library (<samp class="SANS_Consolas_Regular_11">String</samp> or <samp class="SANS_Consolas_Regular_11">Array</samp>), or any of the types realized by other classes in the program (e.g., <samp class="SANS_Consolas_Regular_11">Fraction</samp> or <samp class="SANS_Consolas_Regular_11">List</samp>). If the subroutine is a <i>constructor</i>, it may have an arbitrary name, but its type must be the name of the class to which it belongs. A class can have 0, 1, or more constructors. By convention, one of the constructors is named <samp class="SANS_Consolas_Regular_11">new</samp>.</p>
<p>Following its interface specification, the subroutine declaration contains a sequence of zero or more local variable declarations (<samp class="SANS_Consolas_Regular_11">var</samp> statements) and then a sequence of one or more statements. Each subroutine must end with the statement <samp class="SANS_Consolas_Regular_11">return</samp> <i>expression</i>. In the case of a void subroutine, when there is nothing to return, the subroutine must end with the statement <samp class="SANS_Consolas_Regular_11">return</samp> (which can be viewed as a shorthand of <samp class="SANS_Consolas_Regular_11">return</samp> <samp class="SANS_Consolas_Regular_11">void</samp>, where <samp class="SANS_Consolas_Regular_11">void</samp> is a constant representing “nothing”). Constructors must terminate with the statement <samp class="SANS_Consolas_Regular_11">return</samp> <samp class="SANS_Consolas_Regular_11">this</samp>. This action returns the memory address of the newly constructed object, denoted <samp class="SANS_Consolas_Regular_11">this</samp> (Java constructors do the same, implicitly).</p>
</section>
<section>
<h3 class="head b-head"><b>9.2.3    Data Types</b></h3>
<p class="noindent">The data type of a variable is either <i>primitive</i> (<samp class="SANS_Consolas_Regular_11">int</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, or <samp class="SANS_Consolas_Regular_11">boolean</samp>), or <i>ClassName</i>, where <i>ClassName</i> is either <samp class="SANS_Consolas_Regular_11">String</samp>, <samp class="SANS_Consolas_Regular_11">Array</samp>, or the name of a class residing in the program folder.</p>
<p class="STNI1"><b>Primitive types</b>: Jack features three primitive data types:</p>
<p class="COMF"><samp class="SANS_Consolas_Regular_11">int</samp><span class="p-alt">: two’s-complement 16-bit integer</span></p>
<p class="COM1"><samp class="SANS_Consolas_Regular_11">char</samp><span class="p-alt">: nonnegative, 16-bit integer</span></p>
<p class="COM3"><samp class="SANS_Consolas_Regular_11">boolean</samp><span class="p-alt">:</span> <samp class="SANS_Consolas_Regular_11">true</samp> <span class="p-alt">or</span> <samp class="SANS_Consolas_Regular_11">false</samp></p>
<p class="TNI1-NEW">Each one of the three primitive data types <samp class="SANS_Consolas_Regular_11">int</samp>, <samp class="SANS_Consolas_Regular_11">char</samp>, and <samp class="SANS_Consolas_Regular_11">boolean</samp> is represented internally as a 16-bit value. The language is weakly typed: a value of any type can be assigned to a variable of any type without casting.</p>
<p class="STNI1"><b>Arrays</b>: Arrays are declared using the OS class <samp class="SANS_Consolas_Regular_11">Array</samp>. Array elements are accessed using the typical <samp class="SANS_Consolas_Regular_11">arr</samp>[<i>i</i>] notation, where the index of the first element is 0. A multidimensional array may be obtained by creating an array of arrays. The array elements are not typed, and different elements in the same array may have different types. The declaration of an array creates a reference, while the array proper is constructed by executing the constructor call <samp class="SANS_Consolas_Regular_11">Array.new</samp> <samp class="SANS_Consolas_Regular_11">(</samp><i>arrayLength</i><samp class="SANS_Consolas_Regular_11">)</samp>. For an example of working with arrays, see <a href="chapter_9.html#fig9-2">figure 9.2</a>.</p>
<p class="STNI1"><b>Object types</b>: A Jack class that contains at least one method defines an object type. As typical in object-oriented programming, object creation is a two-step affair. Here is an example:<span aria-label="180" id="pg_180" role="doc-pagebreak"/></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.3.png"/></figure>
<p class="STNI1"><b>Strings</b>: Strings are instances of the OS class <samp class="SANS_Consolas_Regular_11">String</samp>, which implements strings as arrays of <samp class="SANS_Consolas_Regular_11">char</samp> values. The Jack compiler recognizes the syntax <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">foo</samp><samp class="SANS_Consolas_Regular_11">"</samp> and treats it as a <samp class="SANS_Consolas_Regular_11">String</samp> object. The contents of a <samp class="SANS_Consolas_Regular_11">String</samp> object can be accessed using <samp class="SANS_Consolas_Regular_11">charAt</samp>(<i>index</i>) and other methods documented in the <samp class="SANS_Consolas_Regular_11">String</samp> class API (see appendix 6). Here is an example:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.4.png"/></figure>
<p class="TNI1">The statement <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="11" src="../images/9-C1.png" width="122"/> is equivalent to the statement <samp class="SANS_Consolas_Regular_11">let</samp> <samp class="SANS_Consolas_Regular_11">s</samp> <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">String.new(11)</samp>, followed by the eleven method calls <samp class="SANS_Consolas_Regular_11">do</samp> <samp class="SANS_Consolas_Regular_11">s.appendChar(72)</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">do</samp> <samp class="SANS_Consolas_Regular_11">s.appendChar(100)</samp>, where the argument of <samp class="SANS_Consolas_Regular_11">appendChar</samp> is the character’s integer code. In fact, that’s exactly how the compiler handles the translation of <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="11" src="../images/9-C2.png" width="126"/> Note that the single character idiom, for example, <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">H</samp><samp class="SANS_Consolas_Regular_11">'</samp>, is not supported by the Jack language. The only way to represent a character is to use its integer character code or a <samp class="SANS_Consolas_Regular_11">charAt</samp> method call. The Hack character set is documented in appendix 5.</p>
<p class="STNI1"><b>Type conversions</b>: Jack is weakly typed: the language specification does not define what happens when a value of one type is assigned to a variable of a different type. The decisions of whether to allow such casting operations, and how to handle them, are left to specific Jack compilers. This under-specification is intentional, allowing the construction of minimal compilers that ignore typing issues. Having said that, all Jack compilers are expected to support, and automatically perform, the following assignments.</p>
<ul class="bullet">
<li class="BLF"><span aria-label="181" id="pg_181" role="doc-pagebreak"/>A character value can be assigned to an integer variable, and vice versa, according to the Jack character set specification (appendix 5). Example:</li>
</ul>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.5.png"/></figure>
<ul class="bullet">
<li class="BLF">An integer can be assigned to a reference variable (of any object type), in which case it is interpreted as a memory address. Example:</li>
</ul>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.6.png"/></figure>
<ul class="bullet">
<li class="BLF">An object variable may be assigned to an <samp class="SANS_Consolas_Regular_11">Array</samp> variable, and vice versa. This allows accessing the object fields as array elements, and vice versa. Example:</li>
</ul>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.7.png"/></figure>
</section>
<section>
<h3 class="head b-head"><b>9.2.4    Variables</b></h3>
<p class="noindent">Jack features four kinds of variables. <i>Static variables</i> are defined at the class level and can be accessed by all the class subroutines. <i>Field variables</i>, also defined at the class level, are used to represent the properties of individual objects and can be accessed by all the class constructors and methods. <i>Local variables</i> are used by subroutines for local computations, and <i>parameter variables</i> represent the arguments that were passed to the subroutine by the caller. Local and parameter values are created just before the subroutine starts executing and are recycled when the subroutine returns. <a href="chapter_9.html#fig9-7" id="rfig9-7">Figure 9.7</a> gives the details. The <i>scope</i> of a variable is the region in the program in which the variable is recognized.</p>
<figure class="IMG"><img alt="" id="fig9-7" src="../images/figure_9.7.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-7">Figure 9.7</a></b>    Variable kinds in the Jack language. Throughout the table, <i>subroutine</i> refers to either a <i>function</i>, a <i>method</i>, or a <i>constructor</i>.</p></figcaption>
</figure>
<p class="STNI1"><b>Variable initialization</b>: Static variables are not initialized, and it is up to the programmer to write code that initializes them before using them. Field variables are not initialized; it <span aria-label="182" id="pg_182" role="doc-pagebreak"/>is expected that they will be initialized by the class constructor, or constructors. Local variables are not initialized, and it is up to the programmer to initialize them. Parameter variables are initialized to the values of the arguments passed by the caller.</p>
<p class="STNI1"><b>Variable visibility</b>: Static and field variables cannot be accessed directly from outside the class in which they are defined. They can be accessed only through accessor and mutator methods, as facilitated by the class designer.</p>
</section>
<section>
<h3 class="head b-head"><b>9.2.5    Statements</b></h3>
<p class="noindent">The Jack language features five statements, as seen in <a href="#fig9-8" id="rfig9-8">figure 9.8</a>.</p>
<figure class="IMG-L"><img alt="" id="fig9-8" src="../images/figure_wo_caption_9.8.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-8">Figure 9.8</a></b>    Statements in the Jack language.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><b>9.2.6    Expressions</b></h3>
<p class="noindent">A Jack expression is one of the following:</p>
<ul class="bullet">
<li class="BLF">A <i>constant</i></li>
<li class="BL1">A <i>variable name</i> in scope. The variable may be <i>static</i>, <i>field</i>, <i>local</i>, or <i>parameter</i></li>
<li class="BL1">The <samp class="SANS_Consolas_Regular_11">this</samp> keyword, denoting the current object (cannot be used in functions)</li>
<li class="BL1">An <i>array element</i> using the syntax <i>arr</i><samp class="SANS_Consolas_Regular_11">[</samp><i>expression</i><samp class="SANS_Consolas_Regular_11">]</samp>, where <i>arr</i> is a variable name of type <samp class="SANS_Consolas_Regular_11">Array</samp> in scope</li>
<li class="BL1">A <i>subroutine call</i> that returns a non-void type</li>
<li class="BL1">An expression prefixed by one of the unary operators <samp class="SANS_Consolas_Regular_11">-</samp> or <samp class="SANS_Consolas_Regular_11">~</samp>:</li>
</ul>
<p class="UL1"><span aria-label="183" id="pg_183" role="doc-pagebreak"/><samp class="SANS_Consolas_Regular_11">-</samp> <i>expression</i>: arithmetic negation</p>
<p class="UL1"><samp class="SANS_Consolas_Regular_11">~</samp> <i>expression</i>: Boolean negation (bitwise for integers)</p>
<ul class="bullet">
<li class="BL1">An expression of the form <i>expression op expression</i> where <i>op</i> is one of the following binary operators:</li>
</ul>
<p class="UL1"><span class="symb-code">+</span> <samp class="SANS_Consolas_Regular_11">-</samp> <samp class="SANS_Consolas_Regular_11">*</samp> <samp class="SANS_Consolas_Regular_11">/</samp>:      integer arithmetic operators</p>
<p class="UL1"><samp class="SANS_Consolas_Regular_11">&amp;</samp> <samp class="SANS_Consolas_Regular_11">|</samp>:           Boolean And and Boolean Or (bitwise for integers) operators</p>
<p class="UL1"><span class="symb-code">&lt; &gt;</span> <span class="code_eq-symb">=</span>:      comparison operators</p>
<ul class="bullet">
<li class="BL1"><samp class="SANS_Consolas_Regular_11">(</samp><i>expression</i><samp class="SANS_Consolas_Regular_11">)</samp>: an expression in parentheses</li>
</ul>
<p class="STNI1"><b>Operator priority and order of evaluation</b>: Operator priority is <i>not</i> defined by the language, except that expressions in parentheses are evaluated first. Thus the value of the expression <img alt="" class="inline" height="10" src="../images/9-C3.png" width="54"/> is unpredictable, whereas <img alt="" class="inline" height="14" src="../images/9-C4.png" width="67"/> is guaranteed to evaluate to 14. The Jack compiler supplied in Nand to Tetris (as well as the compiler that we’ll develop in chapters 10–11) evaluates expressions left to right, so the expression <img alt="" class="inline" height="10" src="../images/9-C3.png" width="54"/> evaluates to 20. Once again, if you wish to get the algebraically correct result, use <img alt="" class="inline" height="14" src="../images/9-C6.png" width="69"/></p>
<p>The need to use parentheses for enforcing operator priority makes Jack expressions a bit cumbersome. This lack of formal operator priority is intentional, though, as it simplifies the implementation of Jack compilers. Different Jack compilers are welcome to specify an operator priority and add it to the language documentation, if so desired.</p>
</section>
<section>
<h3 class="head b-head"><span aria-label="184" id="pg_184" role="doc-pagebreak"/><b>9.2.7    Subroutine Calls</b></h3>
<p class="noindent">A subroutine call invokes a function, a constructor, or a method for its effect, using the general syntax <i>subroutineName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span>, <i>exp<sub>n</sub></i><samp class="SANS_Consolas_Regular_11">)</samp>, where each argument <i>exp</i> is an expression. The number and type of the arguments must match those of the subroutine’s parameters, as specified in the subroutine’s declaration. The parentheses must appear even if the argument list is empty.</p>
<p>Subroutines can be called from the class in which they are defined, or from other classes, according to the following syntax rules:</p>
</section>
<section>
<h3 class="head b-head"><b>Function calls / Constructor calls:</b></h3>
<ul class="List-1">
<li class="BL1"><i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>functionName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span> <samp class="SANS_Consolas_Regular_11">,</samp> <i>exp<sub>n</sub></i><samp class="SANS_Consolas_Regular_11">)</samp></li>
<li class="BLL1"><i>className</i><samp class="SANS_Consolas_Regular_11">.</samp><i>constructorName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span> <samp class="SANS_Consolas_Regular_11">,</samp> <i>exp<sub>n</sub></i><samp class="SANS_Consolas_Regular_11">)</samp></li>
</ul>
<p class="TNI1">The <i>className</i> must always be specified, even if the function/constructor is in the same class as the caller.</p>
</section>
<section>
<h3 class="head b-head"><b>Method calls:</b></h3>
<ul class="List-1">
<li class="BL1"><i>varName</i><samp class="SANS_Consolas_Regular_11">.</samp><i>methodName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span> <samp class="SANS_Consolas_Regular_11">,</samp> <i>exp<sub>n</sub></i><samp class="SANS_Consolas_Regular_11">)</samp></li>
</ul>
<p class="BLTX">Applies the method to the object referred to by <i>varName</i>.</p>
<ul class="List-1">
<li class="BL1"><i>methodName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span> <samp class="SANS_Consolas_Regular_11">,</samp> <i>exp<sub>n</sub></i><samp class="SANS_Consolas_Regular_11">)</samp></li>
</ul>
<p class="BLTX1">Applies the method to the <i>current object</i>. Same as <samp class="SANS_Consolas_Regular_11">this.</samp><i>methodName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span> <samp class="SANS_Consolas_Regular_11">,</samp> <i>exp<sub>n</sub></i><samp class="SANS_Consolas_Regular_11">)</samp>.</p>
<p class="TNI1">Here are subroutine call examples:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_9.9.png"/></figure>
</section>
<section>
<h3 class="head b-head"><span aria-label="185" id="pg_185" role="doc-pagebreak"/><b>9.2.8 Object Construction and Disposal</b></h3>
<p class="noindent">Object construction is done in two stages. First, a reference variable (pointer to an object) is declared. To complete the object’s construction (if so desired), the program must call a constructor from the object’s class. Thus, a class that implements a type (e.g., <samp class="SANS_Consolas_Regular_11">Fraction</samp>) must feature at least one constructor. Jack constructors may have arbitrary names; by convention, one of them is named <samp class="SANS_Consolas_Regular_11">new</samp>.</p>
<p>Objects are constructed and assigned to variables using the idiom <samp class="SANS_Consolas_Regular_11">let</samp> <i>varName</i> <span class="code_eq-symb">=</span> <i>className.constructorName</i> <samp class="SANS_Consolas_Regular_11">(</samp><i>exp</i><sub>1</sub><samp class="SANS_Consolas_Regular_11">,</samp> <i>exp</i><sub>2</sub><samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span> <samp class="SANS_Consolas_Regular_11">,</samp> <i>exp<sub>n</sub></i>), for example, <samp class="SANS_Consolas_Regular_11">let</samp> c <span class="code_eq-symb">=</span> <samp class="SANS_Consolas_Regular_11">Circle.new</samp> <samp class="SANS_Consolas_Regular_11">(x,y,50)</samp>. Constructors typically include code that initializes the fields of the new object to the argument values passed by the caller.</p>
<p>When an object is no longer needed, it can be disposed, to free the memory that it occupies. For example, suppose that the object that <samp class="SANS_Consolas_Regular_11">c</samp> points at is no longer needed. The object can be deallocated from memory by calling the OS function <samp class="SANS_Consolas_Regular_11">Memory.deAlloc</samp> <samp class="SANS_Consolas_Regular_11">(c)</samp>. Since Jack has no garbage collection, the best-practice advice is that every class that represents an object must feature a <samp class="SANS_Consolas_Regular_11">dispose()</samp> method that properly encapsulates this de-allocation. <a href="chapter_9.html#fig9-3a">Figures 9.3</a> and <a href="chapter_9.html#fig9-4">9.4</a> give examples. To avoid memory leaks, Jack programmers are advised to dispose objects when they are no longer needed.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>9.3    Writing Jack Applications</b></h2>
<p class="noindent">Jack is a general-purpose language that can be implemented over different hardware platforms. In Nand to Tetris we develop a <i>Jack compiler over the Hack platform</i>, and thus it is natural to discuss Jack applications in the Hack context.</p>
<p class="STNI1"><b>Examples</b>: <a href="chapter_9.html#fig9-9" id="rfig9-9">Figure 9.9</a> shows screenshots of four sample Jack programs. Generally speaking, the Jack/Hack platform lends itself nicely to simple interactive games like Pong, Snake, Tetris, and similar classics. Your <samp class="SANS_Consolas_Regular_11">projects/09/Square</samp> folder includes the full Jack code of a simple interactive program that allows the user to move a square image on the screen using the four keyboard arrow keys.</p>
<figure class="IMG"><img alt="" id="fig9-9" src="../images/figure_9.8.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig9-9">Figure 9.9</a></b>    Screenshots of Jack applications running on the Hack computer.</p></figcaption>
</figure>
<p>Executing this program while reviewing its Jack source code is a good way for learning how to use Jack to write interactive graphical applications. Later in the chapter we describe how to compile and execute Jack programs using the supplied tools.</p>
<p class="STNI1"><b>Application design and implementation</b>: Software development should always rest on careful planning, especially when done over a spartan hardware platform like the Hack computer. First, the program designer must consider the physical limitations of the hardware and plan accordingly. To start with, the dimensions of the computer’s screen limit the size of the graphical images that the program can handle. Likewise, one must consider <span aria-label="186" id="pg_186" role="doc-pagebreak"/>the language’s range of input/output commands and the platform’s execution speed to gain a realistic expectation of what can and cannot be done.</p>
<p>The design process normally starts with a conceptual description of the desired program’s behavior. In the case of graphical and interactive programs, this may take the form of handwritten drawings of typical screens. Next, one normally designs an object-based architecture of the program. This entails the identification of <i>classes</i>, <i>fields</i>, and <i>subroutines</i>. For example, if the program is supposed to allow the user to create square objects and move them around the screen using the keyboard’s arrow keys, it will make sense to design a <samp class="SANS_Consolas_Regular_11">Square</samp> class that encapsulates these operations using methods like <samp class="SANS_Consolas_Regular_11">moveRight</samp>, <samp class="SANS_Consolas_Regular_11">moveLeft</samp>, <samp class="SANS_Consolas_Regular_11">moveUp</samp>, and <samp class="SANS_Consolas_Regular_11">moveDown</samp>, as well as a constructor subroutine for creating squares and a disposer subroutine for disposing them. In addition, it will make sense to create a <samp class="SANS_Consolas_Regular_11">SquareGame</samp> class that carries out the user interaction and a <samp class="SANS_Consolas_Regular_11">Main</samp> class that gets things started. Once the APIs of these classes are carefully specified, one can proceed to implement, compile, and test them.</p>
<p class="STNI1"><b>Compiling and executing Jack programs</b>: All the <samp class="SANS_Consolas_Regular_11">.jack</samp> files comprising the program must reside in the same folder. When you apply the Jack compiler to the program folder, each source <samp class="SANS_Consolas_Regular_11">.jack</samp> file will be translated into a corresponding <samp class="SANS_Consolas_Regular_11">.vm</samp> file, stored in the same program folder.</p>
<p>The simplest way to execute or debug a compiled Jack program is to load the program folder into the VM emulator. The emulator will load all the VM functions in all the <samp class="SANS_Consolas_Regular_11">.vm</samp> files in the folder, one after the other. The result will be a (possibly long) stream of VM functions, listed in the VM emulator’s code pane using their full <i>fileName</i><samp class="SANS_Consolas_Regular_11">.</samp><i>functionName</i> names. When <span aria-label="187" id="pg_187" role="doc-pagebreak"/>you instruct the emulator to execute the program, the emulator will start executing the OS <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function, which will then call the <samp class="SANS_Consolas_Regular_11">Main.main</samp> function in your Jack program.</p>
<p>Alternatively, you can use a VM translator (like the one built in projects 7–8) for translating the compiled VM code, as well as the eight supplied <samp class="SANS_Consolas_Regular_11">tools/OS/*.vm</samp> OS files, into a single <samp class="SANS_Consolas_Regular_11">.asm</samp> file written in the Hack machine language. The assembly code can then be executed on the supplied CPU emulator. Or, you can use an assembler (like the one built in project 6) for translating the <samp class="SANS_Consolas_Regular_11">.asm</samp> file further into a binary code <samp class="SANS_Consolas_Regular_11">.hack</samp> file. Next, you can load a Hack computer chip (like the one built in projects 1–5) into the hardware simulator or use the built-in <samp class="SANS_Consolas_Regular_11">Computer</samp> chip, load the binary code into the ROM chip, and execute it.</p>
<p class="STNI1"><b>The operating system</b>: Jack programs make extensive use of the language’s <i>standard class library</i>, which we also refer to as the <i>Operating System</i>. In project 12 you will develop the OS class library in Jack (like Unix is written in C) and compile it using a Jack compiler. The compilation will yield eight <samp class="SANS_Consolas_Regular_11">.vm</samp> files, comprising the OS implementation. If you put these eight <samp class="SANS_Consolas_Regular_11">.vm</samp> files in your program folder, all the OS functions will become accessible to the compiled VM code, since they belong to the same code base (by virtue of belonging to the same folder).</p>
<p>Presently, though, there is no need to worry about the OS implementation. The supplied VM emulator, which is a Java program, features a built-in Java implementation of the Jack OS. When the VM code loaded into the emulator calls an OS function, say <samp class="SANS_Consolas_Regular_11">Math.sqrt</samp>, one of two things happens. If the OS function is found in the loaded code base, the VM emulator executes it, just like executing any other VM function. If the OS function is not found in the loaded code base, the emulator executes its built-in implementation.</p>
</section>
<section>
<h2 class="head a-head"><b>9.4    Project</b></h2>
<p class="noindent">Unlike the other projects in this book, this one does not require building a hardware of software module. Rather, you have to pick some application of your choice and build it in Jack over the Hack platform.</p>
<p class="STNI1"><b>Objective</b>: The “hidden agenda” of this project is to get acquainted with the Jack language, for two purposes: writing the Jack compiler in projects 10 and 11, and writing the Jack operating system in project 12.</p>
<p class="STNI1"><b>Contract</b>: Adopt or invent an application idea like a simple computer game or some interactive program. Then design and build the application.</p>
<p class="STNI1"><b>Resources</b>: You will need the supplied <samp class="SANS_Consolas_Regular_11">tools/JackCompiler</samp> for translating your program into a set of <samp class="SANS_Consolas_Regular_11">.vm</samp> files, and the supplied <samp class="SANS_Consolas_Regular_11">tools/VMEmulator</samp> for running and testing the compiled code.</p>
<section>
<h3 class="head b-head"><span aria-label="188" id="pg_188" role="doc-pagebreak"/><b>Compiling and Running a Jack Program</b></h3>
<p class="NL"><span class="nl">0.</span>  Create a folder for your program. Let’s call it the <i>program folder</i>.</p>
<p class="NL"><span class="nl">1.  </span>Write your Jack program—a set of one or more Jack classes—each stored in a separate <i>ClassName</i><samp class="SANS_Consolas_Regular_11">.jack</samp> text file. Put all these <samp class="SANS_Consolas_Regular_11">.jack</samp> files in the program folder.</p>
<p class="NL"><span class="nl">2.</span>  Compile the program folder using the supplied Jack compiler. This will cause the compiler to translate all the <samp class="SANS_Consolas_Regular_11">.jack</samp> classes found in the folder into corresponding <samp class="SANS_Consolas_Regular_11">.vm</samp> files. If a compilation error is reported, debug the program and recompile until no error messages are issued.</p>
<p class="NL"><span class="nl">3.</span>  At this point the program folder should contain your source <samp class="SANS_Consolas_Regular_11">.jack</samp> files along with the compiled <samp class="SANS_Consolas_Regular_11">.vm</samp> files. To test the compiled program, load the program folder into the supplied VM emulator, and run the loaded code. In case of run-time errors or undesired program behavior, fix the relevant file and go back to step 2.</p>
<p class="STNI1"><b>Program examples</b>: Your <samp class="SANS_Consolas_Regular_11">nand2tetris/project/09</samp> folder includes the source code of a complete, three-class interactive Jack program (<samp class="SANS_Consolas_Regular_11">Square</samp>). It also includes the source code of the Jack programs discussed in this chapter.</p>
<p class="STNI1"><b>Bitmap editor</b>: If you develop a program that needs high-speed graphics, it is best to design <i>sprites</i> for rendering the key graphical elements of the program. For example, the output of the Sokoban application depicted in <a href="chapter_9.html#fig9-9">figure 9.9</a> consists of several repeating sprites. If you wish to design such sprites and write them directly into the screen memory map (bypassing the services of the OS <samp class="SANS_Consolas_Regular_11">Screen</samp> class, which may be too slow), you will find the <samp class="SANS_Consolas_Regular_11">projects/09/BitmapEditor</samp> tool useful.</p>
<p class="STNI1"><b>A web-based version of project 9</b> is available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>9.5    Perspective</b></h2>
<p class="noindent">Jack is an <i>object-based</i> language, meaning that it supports objects and classes but not inheritance. In this respect it is positioned somewhere between procedural languages like Pascal or C and object-oriented languages like Java or C<span class="symb">++</span>. Jack is certainly more simple-minded than any of these industrial strength programming languages. However, its basic syntax and semantics are similar to those of modern languages.</p>
<p>Some features of the Jack language leave much to be desired. For example, its primitive type system is, well, rather primitive. Moreover, it is a weakly typed language, meaning that type conformity in assignments and operations is not strictly enforced. Also, you may wonder why the Jack syntax includes clunky keywords like <samp class="SANS_Consolas_Regular_11">do</samp> and <samp class="SANS_Consolas_Regular_11">let</samp>, why every sub<span aria-label="189" id="pg_189" role="doc-pagebreak"/>routine must end with a <samp class="SANS_Consolas_Regular_11">return</samp> statement, why the language does not enforce operator priority, and so on—you may add your favorite complaint to the list.</p>
<p>All these somewhat tedious idiosyncrasies were introduced into Jack with one purpose: allowing the development of simple and minimal Jack compilers, as we will do in the next two chapters. For example, the parsing of a statement (in any language) is significantly easier if the first token of the statement reveals which statement we’re in. That’s why Jack uses a <samp class="SANS_Consolas_Regular_11">let</samp> keyword for prefixing assignment statements. Thus, although Jack’s simplicity may be a nuisance when writing Jack <i>applications</i>, you’ll be grateful for this simplicity when writing the Jack <i>compiler</i>, as we’ll do in the next two chapters.</p>
<p>Most modern languages are deployed with a set of <i>standard classes</i>, and so is Jack. Taken together, these classes can be viewed as a portable, language-oriented operating system. Yet unlike the standard libraries of industrial-strength languages, which feature numerous classes, the Jack OS provides a minimal set of services, which is nonetheless sufficient for developing simple interactive applications.</p>
<p>Clearly, it would be nice to extend the Jack OS to provide concurrency for supporting multi-threading, a file system for permanent storage, sockets for communications, and so on. Although all these services can be added to the OS, readers will perhaps want to hone their programming skills elsewhere. After all, we don’t expect Jack to be part of your life beyond Nand to Tetris. Therefore, it is best to view the Jack/Hack platform as a given environment and make the best out of it. That’s precisely what programmers do when they write software for embedded devices and dedicated processors that operate in restricted environments. Instead of viewing the constraints imposed by the host platform as a problem, professionals view it as an opportunity to display their resourcefulness and ingenuity. That’s what you are expected to do in project 9.</p>
</section>
</section>
</div>
</body>
</html>