<html lang="en">
<head>
<title>Index</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ind"role="doc-index">
<header>
<h1 class="BMH" id="ind"><span aria-label="321" id="pg_321" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">Index</samp></h1>
</header>
<ul class="ind">
<li class="IXA">Ada. <i>See</i> <a href="#ind8">King-Noel, Augusta Ada</a></li>
<li class="IX">Adder</li>
<li class="IXS">abstraction, <a href="chapter_2.html#pg_35">35–36</a></li>
<li class="IXS">implementation, <a href="chapter_2.html#pg_41">41</a></li>
<li class="IX">Addressing, <a href="chapter_3.html#pg_46">46</a>, <a href="chapter_5.html#pg_85">85</a></li>
<li class="IX">Address register, <a href="chapter_4.html#pg_63">63</a>, <a href="chapter_4.html#pg_64">64</a>, <a href="chapter_5.html#pg_87">87</a>, <a href="chapter_5.html#pg_89">89</a></li>
<li class="IX">Address space, <a href="chapter_4.html#pg_82">82</a>, <a href="chapter_5.html#pg_92">92–93</a></li>
<li class="IX">ALU. <i>See</i> <a href="#ind1">Arithmetic Logic Unit (ALU)</a></li>
<li class="IX">And gate, <a href="chapter_1.html#pg_9">9</a>, <a href="chapter_1.html#pg_14">14</a></li>
<li class="IX">Arithmetic-logical commands, <a href="chapter_8.html#pg_147">147</a>, <a href="chapter_8.html#pg_164">164</a></li>
<li class="IX" id="ind1">Arithmetic Logic Unit (ALU), <a href="part_1.html#pg_3">3</a>, <a href="part_1.html#pg_4">4</a>, <a href="chapter_2.html#pg_36">36</a>, <a href="chapter_5.html#pg_86">86</a>, <a href="chapter_5.html#pg_94">94</a></li>
<li class="IX">Assembler, <a href="part_1.html#pg_7">7</a>, <a href="chapter_6.html#pg_103">103–11</a></li>
<li class="IXS">API, <a href="chapter_6.html#pg_110">110–112</a></li>
<li class="IXS">background, <a href="chapter_6.html#pg_103">103–105</a></li>
<li class="IXS">implementation, <a href="chapter_6.html#pg_109">109–110</a></li>
<li class="IXS">macro commands (<i>see</i> <a href="#ind9">Macro instruction</a>)</li>
<li class="IXS">mnemonic, <a href="chapter_6.html#pg_104">104</a></li>
<li class="IXS">pseudo-instructions, <a href="chapter_6.html#pg_105">105–106</a></li>
<li class="IXS">symbol table, <a href="chapter_6.html#pg_108">108–109</a></li>
<li class="IXS">translation, <a href="chapter_6.html#pg_108">108–109</a></li>
<li class="IXS">two-pass assembler, <a href="chapter_6.html#pg_108">108</a></li>
<li class="IX">Assembly languages, <a href="chapter_4.html#pg_63">63</a></li>
<li class="IX" id="ind2">Assembly language specification (Hack), <a href="chapter_6.html#pg_106">106–107</a></li>
</ul>
<ul class="ind">
<li class="IXA">Behavioral simulation, <a href="chapter_1.html#pg_24">24–25</a></li>
<li class="IX">Binary numbers, <a href="chapter_2.html#pg_32">32–33</a></li>
<li class="IX">Bitmap editor, <a href="chapter_9.html#pg_188">188</a></li>
<li class="IX">Boolean algebra, <a href="chapter_1.html#pg_9">9–12</a>, <a href="appendix1.html#pg_277">277–278</a></li>
<li class="IX">Boolean arithmetic, <a href="chapter_2.html#pg_31">31–43</a></li>
<li class="IXS">arithmetic operations, <a href="chapter_2.html#pg_31">31–32</a></li>
<li class="IXS">binary addition, <a href="chapter_2.html#pg_33">33–34</a></li>
<li class="IXS">binary numbers, <a href="chapter_2.html#pg_32">32–33</a></li>
<li class="IXS">Boolean operators, <a href="chapter_1.html#pg_10">10</a></li>
<li class="IXS">carry lookahead, <a href="chapter_2.html#pg_43">43</a></li>
<li class="IXS">fixed word size, <a href="chapter_2.html#pg_33">33</a></li>
<li class="IXS">implementation, <a href="chapter_2.html#pg_41">41–42</a></li>
<li class="IXS">negative numbers, <a href="chapter_2.html#pg_34">34–35</a></li>
<li class="IXS">overflow, <a href="chapter_2.html#pg_34">34</a></li>
<li class="IXS">radix complement, <a href="chapter_2.html#pg_34">34</a></li>
<li class="IXS">signed binary numbers, <a href="chapter_2.html#pg_34">34–35</a></li>
<li class="IXS">two’s complement method, <a href="chapter_2.html#pg_34">34</a></li>
<li class="IX">Boolean function simplification, <a href="appendix1.html#pg_278">278</a></li>
<li class="IX">Boolean function synthesis, <a href="appendix1.html#pg_277">277–281</a></li>
<li class="IXS">Disjunctive Normal Form (DNF), <a href="appendix1.html#pg_279">279</a></li>
<li class="IXS">Nand, expressive power of, <a href="appendix1.html#pg_279">279–281</a></li>
<li class="IXS">synthesizing Boolean functions, <a href="appendix1.html#pg_278">278–279</a></li>
<li class="IX">Bootstrapping, <a href="part_2.html#pg_118">118</a>, <a href="chapter_8.html#pg_167">167–168</a></li>
<li class="IX">Branching, <a href="chapter_4.html#pg_62">62</a>, <a href="chapter_8.html#pg_149">149–151</a></li>
<li class="IXS">conditional, <a href="chapter_4.html#pg_68">68</a></li>
<li class="IXS">machine language, <a href="chapter_4.html#pg_62">62</a>, <a href="chapter_4.html#pg_67">67</a></li>
<li class="IXS">unconditional, <a href="chapter_4.html#pg_67">67</a></li>
<li class="IXS" id="ind3a">VM program control, <a href="chapter_8.html#pg_149">149–151</a>, <a href="chapter_8.html#pg_158">158</a></li>
<li class="IX">Built-in chips</li>
<li class="IXS">overview, <a href="chapter_1.html#pg_25">25–27</a></li>
<li class="IXS">HDL, <a href="appendix2.html#pg_287">287–289</a></li>
<li class="IXS">methods of, <a href="appendix3.html#pg_306">306</a></li>
<li class="IXS">variables of, <a href="appendix3.html#pg_305">305–306</a></li>
<li class="IX">Bus, <a href="appendix2.html#pg_286">286–289</a>, <a href="appendix2.html#pg_296">296</a></li>
</ul>
<ul class="ind">
<li class="IXA">Calling chain, <a href="chapter_8.html#pg_152">152</a></li>
<li class="IX">Carry lookahead, <a href="chapter_2.html#pg_43">43</a></li>
<li class="IX">Central Processing Unit (CPU), <a href="chapter_5.html#pg_86">86–87</a></li>
<li class="IXS">abstraction, <a href="chapter_5.html#pg_89">89–90</a></li>
<li class="IXS">Boolean arithmetic, <a href="chapter_2.html#pg_31">31</a></li>
<li class="IXS">Hack computer, <a href="chapter_5.html#pg_89">89–90</a></li>
<li class="IXS">Implementation, <a href="chapter_5.html#pg_94">94–96</a></li>
<li class="IXS"><span aria-label="322" id="pg_322" role="doc-pagebreak"/>machine language, <a href="chapter_4.html#pg_62">62</a></li>
<li class="IXS">memory, <a href="chapter_3.html#pg_59">59</a></li>
<li class="IXS">von Neumann architecture and, <a href="chapter_5.html#pg_84">84</a></li>
<li class="IX">Code generation. <i>See</i> <a href="#ind1a">Compiler, code generation</a></li>
<li class="IX">CPU emulator, <a href="chapter_4.html#pg_80">80</a></li>
<li class="IXS">testing machine language programs on, <a href="appendix3.html#pg_308">308–309</a></li>
<li class="IX">Chips</li>
<li class="IXS">built-in chips, <a href="chapter_1.html#pg_25">25–27</a>, <a href="appendix2.html#pg_287">287–291</a></li>
<li class="IXS">combinational, <a href="chapter_3.html#pg_45">45</a>, <a href="chapter_3.html#pg_50">50</a>, <a href="appendix2.html#pg_289">289–290</a></li>
<li class="IXS">GUI-empowered, <a href="appendix2.html#pg_291">291–295</a></li>
<li class="IXS">implementation order, <a href="appendix2.html#pg_294">294</a></li>
<li class="IXS">sequential, <a href="chapter_3.html#pg_45">45</a>, <a href="chapter_3.html#pg_50">50</a>, <a href="appendix2.html#pg_290">290–293</a></li>
<li class="IXS">testing on hardware simulator, <a href="appendix3.html#pg_301">301–308</a></li>
<li class="IXS">time-dependent (<i>see</i> <a href="#ind11">Sequential chips</a>)</li>
<li class="IXS">time-independent (<i>see</i> <a href="#ind3">Combinational chips</a>)</li>
<li class="IXS">visualizing, <a href="appendix2.html#pg_291">291–293</a></li>
<li class="IX">Church-Turing conjecture, <a href="part_1.html#pg_3">3</a></li>
<li class="IX">Circle drawing, <a href="chapter_12.html#pg_257">257</a></li>
<li class="IX">Clock cycles, <a href="appendix3.html#pg_302">302</a></li>
<li class="IX" id="ind3">Combinational chips, <a href="chapter_3.html#pg_45">45</a>, <a href="chapter_3.html#pg_50">50</a>, <a href="appendix2.html#pg_289">289–290</a></li>
<li class="IX">Common Language Runtime (CLR), <a href="chapter_7.html#pg_146">146</a></li>
<li class="IX">Compiler</li>
<li class="IXS">code generation, <a href="chapter_11.html#pg_212">212–230</a></li>
<li class="IXS">current object handling, <a href="chapter_11.html#pg_221">221</a>, <a href="chapter_11.html#pg_223">223</a></li>
<li class="IXS">object-oriented languages, <a href="part_2.html#pg_121">121</a></li>
<li class="IXS">software architecture, <a href="chapter_11.html#pg_235">235–236</a></li>
<li class="IXS">specification, <a href="chapter_11.html#pg_230">230</a></li>
<li class="IXS">symbol tables, <a href="chapter_11.html#pg_212">212</a>, <a href="chapter_11.html#pg_214">214</a></li>
<li class="IXS">syntax analysis, <a href="chapter_10.html#pg_191">191–210</a></li>
<li class="IXS">testing, <a href="chapter_11.html#pg_240">240–241</a></li>
<li class="IXS">use of operating system, <a href="chapter_11.html#pg_219">219</a>, <a href="chapter_11.html#pg_234">234</a></li>
<li class="IX">Compiling (code generation)</li>
<li class="IXS">arrays, <a href="chapter_11.html#pg_228">228–230</a></li>
<li class="IXS">constructors, <a href="chapter_11.html#pg_222">222</a>, <a href="chapter_11.html#pg_223">223</a>, <a href="chapter_11.html#pg_234">234</a></li>
<li class="IXS">control flow logic, <a href="chapter_11.html#pg_220">220</a></li>
<li class="IXS">expressions, <a href="chapter_11.html#pg_216">216–218</a></li>
<li class="IXS">methods, <a href="chapter_11.html#pg_225">225–228</a></li>
<li class="IXS">objects, <a href="chapter_11.html#pg_221">221–228</a></li>
<li class="IXS">statements, <a href="chapter_11.html#pg_219">219–221</a></li>
<li class="IXS">strings, <a href="chapter_11.html#pg_218">218–219</a></li>
<li class="IXS">subroutines, <a href="chapter_11.html#pg_233">233</a></li>
<li class="IXS">variables, <a href="chapter_11.html#pg_213">213–216</a></li>
<li class="IX">Complex Instruction Set Computing (CISC), <a href="chapter_5.html#pg_101">101</a></li>
<li class="IX">Conditional branching, <a href="chapter_4.html#pg_68">68</a></li>
<li class="IX">Converter, <a href="chapter_1.html#pg_19">19</a></li>
</ul>
<ul class="ind">
<li class="IXA" id="ind4">Data flip-flop (DFF), <a href="chapter_3.html#pg_46">46</a>, <a href="chapter_3.html#pg_49">49</a>, <a href="chapter_3.html#pg_52">52</a></li>
<li class="IX">Data memory, <a href="chapter_4.html#pg_66">66</a>, <a href="chapter_5.html#pg_85">85</a>, <a href="chapter_5.html#pg_88">88</a>, <a href="chapter_5.html#pg_92">92</a></li>
<li class="IX">Data race, <a href="chapter_3.html#pg_55">55</a>, <a href="appendix2.html#pg_291">291</a></li>
<li class="IX">Data registers, <a href="chapter_4.html#pg_63">63</a>, <a href="chapter_5.html#pg_87">87</a></li>
<li class="IX">Declarative language, HDL as, <a href="appendix2.html#pg_284">284–285</a></li>
<li class="IX">Demultiplexer, <a href="chapter_1.html#pg_9">9</a>, <a href="chapter_1.html#pg_20">20</a>, <a href="chapter_1.html#pg_23">23</a></li>
<li class="IX">Derivation tree, <a href="chapter_10.html#pg_196">196</a></li>
<li class="IX">Disjunctive Normal Form (DNF), <a href="appendix1.html#pg_279">279</a></li>
</ul>
<ul class="ind">
<li class="IXA">Fetch-execute cycle, <a href="chapter_5.html#pg_87">87</a></li>
<li class="IX">Flip-flop. <i>See</i> <a href="#ind4">Data flip-flop</a></li>
<li class="IX">Fonts, <a href="chapter_12.html#pg_247">247</a>, <a href="chapter_12.html#pg_258">258</a></li>
</ul>
<ul class="ind">
<li class="IXA" id="ind5">Gate. <i>See also specific types</i></li>
<li class="IXS">abstraction, <a href="chapter_1.html#pg_12">12–13</a></li>
<li class="IXS">implementation, <a href="chapter_1.html#pg_14">14–17</a></li>
<li class="IXS">primitive and composite, <a href="chapter_1.html#pg_13">13–14</a></li>
<li class="IX">Global stack, <a href="chapter_8.html#pg_154">154</a></li>
<li class="IX">Goto instructions,</li>
<li class="IXS">in assembly language, <a href="chapter_4.html#pg_65">65</a></li>
<li class="IXS">in VM language, <a href="chapter_8.html#pg_149">149–151</a></li>
<li class="IX">Grammar, <a href="chapter_10.html#pg_193">193</a>, <a href="chapter_10.html#pg_194">194</a>, <a href="chapter_10.html#pg_200">200</a></li>
<li class="IX">Graphics processing unit (GPU), <a href="chapter_5.html#pg_101">101</a>, <a href="chapter_12.html#pg_255">255</a></li>
<li class="IX">GUI-empowered chips, <a href="appendix2.html#pg_289">289–295</a></li>
</ul>
<ul class="ind">
<li class="IXA">Hack computer</li>
<li class="IXS">architecture, <a href="chapter_5.html#pg_93">93-94</a>, <a href="chapter_5.html#pg_97">97</a></li>
<li class="IXS">CPU, <a href="chapter_5.html#pg_89">89-90</a>, <a href="chapter_5.html#pg_94">94-96</a></li>
<li class="IXS">data memory, <a href="chapter_5.html#pg_92">92</a>, <a href="chapter_5.html#pg_96">96-97</a></li>
<li class="IXS">input / output devices, <a href="chapter_5.html#pg_91">91</a></li>
<li class="IXS">instruction memory, <a href="chapter_5.html#pg_90">90</a></li>
<li class="IXS">overview, <a href="chapter_5.html#pg_88">88-89</a></li>
<li class="IX">Hack language specification. <i>See</i> <a href="#ind2">Assembly language specification (Hack)</a></li>
<li class="IX">Hardware Description Language (HDL),</li>
<li class="IXS">basics, <a href="appendix2.html#pg_283">283–286</a></li>
<li class="IXS">bit numbering and bus syntax, <a href="appendix2.html#pg_296">296</a></li>
<li class="IXS">built-in chips, <a href="appendix2.html#pg_287">287–289</a></li>
<li class="IXS">feedback loops, <a href="appendix2.html#pg_291">291</a></li>
<li class="IXS">files and test scripts, <a href="appendix2.html#pg_295">295</a></li>
<li class="IXS">HDL Survival Guide, <a href="appendix2.html#pg_294">294–297</a></li>
<li class="IXS">multi-bit buses, <a href="appendix2.html#pg_286">286–287</a></li>
<li class="IXS">multiple outputs, <a href="appendix2.html#pg_296">296–297</a></li>
<li class="IXS">program example, <a href="appendix2.html#pg_284">284</a></li>
<li class="IXS">program structure, <a href="appendix2.html#pg_285">285</a></li>
<li class="IXS">sequential chips, <a href="appendix2.html#pg_291">291–293</a></li>
<li class="IXS"><span aria-label="323" id="pg_323" role="doc-pagebreak"/>sub-busing (indexing) internal pins, <a href="appendix2.html#pg_296">296–297</a></li>
<li class="IXS">syntax errors, <a href="appendix2.html#pg_295">295</a></li>
<li class="IXS">time unit, <a href="appendix2.html#pg_289">289</a></li>
<li class="IXS">unconnected pins, <a href="appendix2.html#pg_295">295–296</a></li>
<li class="IXS">visualizing chips, <a href="appendix2.html#pg_291">291–293</a></li>
<li class="IX">Hardware simulator, <a href="chapter_1.html#pg_15">15–18</a>, <a href="chapter_1.html#pg_25">25–26</a></li>
<li class="IX">Harvard architecture, <a href="chapter_5.html#pg_100">100</a></li>
<li class="IX">Hash table, <a href="chapter_6.html#pg_112">112</a></li>
<li class="IX" id="ind6">High-level programming language (Jack)</li>
<li class="IXS">data types, <a href="chapter_9.html#pg_179">179–181</a></li>
<li class="IXS">expressions, <a href="chapter_9.html#pg_182">182–183</a></li>
<li class="IXS">object construction / disposal, <a href="chapter_9.html#pg_185">185</a></li>
<li class="IXS">operating system use, <a href="chapter_9.html#pg_175">175–176</a></li>
<li class="IXS">operator priority, <a href="chapter_9.html#pg_183">183</a></li>
<li class="IXS">program examples (<i>see</i> <a href="#ind7">Jack program examples</a>)</li>
<li class="IXS">program structure, <a href="chapter_9.html#pg_176">176–178</a></li>
<li class="IXS">standard class library, <a href="chapter_9.html#pg_173">173</a></li>
<li class="IXS">statements, <a href="chapter_9.html#pg_182">182–183</a></li>
<li class="IXS">strings, <a href="chapter_9.html#pg_180">180</a></li>
<li class="IXS">subroutine calls, <a href="chapter_9.html#pg_184">184</a></li>
<li class="IXS">variables, <a href="chapter_9.html#pg_181">181–182</a></li>
<li class="IXS">writing Jack applications, <a href="chapter_9.html#pg_185">185–187</a></li>
</ul>
<ul class="ind">
<li class="IXA">Input / output (I / O)</li>
<li class="IXS">devices, <a href="chapter_4.html#pg_74">74–75</a>, <a href="chapter_5.html#pg_87">87</a></li>
<li class="IXS">memory-mapped, <a href="chapter_5.html#pg_87">87</a></li>
<li class="IX">Instruction</li>
<li class="IXS">decoding, <a href="chapter_5.html#pg_95">95</a></li>
<li class="IXS">execution, <a href="chapter_5.html#pg_95">95</a></li>
<li class="IXS">fetching, <a href="chapter_5.html#pg_96">96</a></li>
<li class="IXS">memory, <a href="chapter_5.html#pg_85">85</a>, <a href="chapter_5.html#pg_86">86</a></li>
<li class="IXS">register, <a href="chapter_5.html#pg_87">87</a></li>
<li class="IX">Intermediate code, <a href="chapter_7.html#pg_125">125</a></li>
<li class="IX">Internal pins, <a href="chapter_1.html#pg_17">17</a></li>
</ul>
<ul class="ind">
<li class="IXA">Jack operating system (OS)</li>
<li class="IXS">API, <a href="appendix6.html#pg_317">317–320</a></li>
<li class="IXS">Array class, <a href="appendix6.html#pg_318">318</a></li>
<li class="IXS">implementation, <a href="chapter_12.html#pg_261">261–267</a></li>
<li class="IXS">Keyboard class, <a href="appendix6.html#pg_319">319–320</a></li>
<li class="IXS">Math class, <a href="appendix6.html#pg_317">317</a></li>
<li class="IXS">Memory class, <a href="appendix6.html#pg_320">320</a></li>
<li class="IXS">Output class, <a href="appendix6.html#pg_318">318–319</a></li>
<li class="IXS">Screen class, <a href="appendix6.html#pg_319">319</a></li>
<li class="IXS">specification, <a href="chapter_12.html#pg_261">261</a></li>
<li class="IXS">String class, <a href="appendix6.html#pg_317">317–318</a></li>
<li class="IXS">Sys class, <a href="appendix6.html#pg_320">320</a></li>
<li class="IX" id="ind7">Jack program examples, <a href="chapter_9.html#pg_172">172–175</a></li>
<li class="IXS">array processing, <a href="chapter_9.html#pg_173">173</a></li>
<li class="IXS">Hello World, <a href="chapter_9.html#pg_172">172</a></li>
<li class="IXS">iterative processing, <a href="chapter_9.html#pg_173">173</a></li>
<li class="IXS">linked list implementation</li>
<li class="IXS">object-oriented, multi-class example, <a href="chapter_9.html#pg_175">175–176</a></li>
<li class="IXS">object-oriented, single-class example, <a href="chapter_9.html#pg_173">173–175</a></li>
<li class="IXS">screenshots, <a href="chapter_9.html#pg_186">186</a></li>
<li class="IXS">simple computer game (Square), <a href="chapter_9.html#pg_186">186</a>, <a href="chapter_9.html#pg_188">188</a></li>
<li class="IX">Jack programming language. <i>See</i> <a href="#ind6">High-level programming language (Jack)</a></li>
<li class="IX">Java Runtime Environment (JRE), <a href="chapter_7.html#pg_128">128</a>, <a href="chapter_7.html#pg_145">145</a></li>
<li class="IX">Java Virtual Machine (JVM), <a href="chapter_7.html#pg_125">125</a>, <a href="chapter_7.html#pg_132">132</a>, <a href="chapter_7.html#pg_145">145</a></li>
</ul>
<ul class="ind">
<li class="IXA">Keyboard input, <a href="chapter_12.html#pg_259">259–260</a></li>
<li class="IXS">detecting a keystroke, <a href="chapter_12.html#pg_259">259</a></li>
<li class="IXS">reading a single character, <a href="chapter_12.html#pg_260">260</a></li>
<li class="IXS">reading a string, <a href="chapter_12.html#pg_260">260</a></li>
<li class="IX">Keyboard memory map, <a href="chapter_4.html#pg_74">74</a>, <a href="chapter_5.html#pg_91">91</a>, <a href="appendix2.html#pg_292">292</a></li>
<li class="IX" id="ind8">King-Noel, Augusta Ada, <a href="chapter_4.html#pg_78">78</a></li>
</ul>
<ul class="ind">
<li class="IXA">Label symbols, <a href="chapter_4.html#pg_74">74</a>, <a href="chapter_6.html#pg_106">106</a></li>
<li class="IX">Last-in-first-out (LIFO), <a href="chapter_7.html#pg_129">129</a>, <a href="chapter_8.html#pg_154">154</a></li>
<li class="IX">Least significant bits (LSB), <a href="chapter_2.html#pg_33">33</a></li>
<li class="IX">Lexicon, <a href="chapter_10.html#pg_193">193</a></li>
<li class="IX">Line drawing, <a href="chapter_12.html#pg_256">256</a></li>
<li class="IX">Local variable, <a href="chapter_7.html#pg_132">132</a>, <a href="chapter_8.html#pg_152">152</a>, <a href="chapter_11.html#pg_214">214</a></li>
<li class="IX">Logic gates. <i>See</i> <a href="#ind5">Gate</a></li>
<li class="IX">Long division, <a href="chapter_12.html#pg_250">250</a></li>
</ul>
<ul class="ind">
<li class="IXA">Machine language</li>
<li class="IXS">addressing, <a href="chapter_4.html#pg_67">67</a></li>
<li class="IXS">branching, <a href="chapter_4.html#pg_67">67–68</a></li>
<li class="IXS">input / output: <a href="chapter_4.html#pg_74">74–75</a></li>
<li class="IXS">memory, <a href="chapter_4.html#pg_66">66</a></li>
<li class="IXS">overview, <a href="chapter_4.html#pg_61">61–66</a></li>
<li class="IXS">program example, <a href="chapter_4.html#pg_69">69–70</a></li>
<li class="IXS">registers, <a href="chapter_4.html#pg_67">67</a></li>
<li class="IXS">specification, <a href="chapter_4.html#pg_71">71–73</a></li>
<li class="IXS">symbols, <a href="chapter_4.html#pg_73">73–74</a></li>
<li class="IXS">syntax and file conventions, <a href="chapter_4.html#pg_76">76</a></li>
<li class="IXS">variables, <a href="chapter_4.html#pg_68">68</a></li>
<li class="IX">Machine language program examples, <a href="chapter_4.html#pg_61">61–82</a></li>
<li class="IXS">addition, <a href="chapter_4.html#pg_77">77</a></li>
<li class="IXS">addressing (pointers), <a href="chapter_4.html#pg_78">78</a></li>
<li class="IXS">iteration, <a href="chapter_4.html#pg_77">77–78</a></li>
<li class="IX" id="ind9"><span aria-label="324" id="pg_324" role="doc-pagebreak"/>Macro instruction, <a href="chapter_4.html#pg_81">81</a>, <a href="chapter_6.html#pg_115">115</a></li>
<li class="IX">Member variables, <a href="chapter_9.html#pg_175">175</a></li>
<li class="IX">Memory</li>
<li class="IXS">clock, <a href="chapter_3.html#pg_46">46–49</a></li>
<li class="IXS">flip-flop gates, <a href="chapter_3.html#pg_49">49–50</a>, <a href="chapter_3.html#pg_52">52</a></li>
<li class="IXS">implementation, <a href="chapter_3.html#pg_54">54–57</a></li>
<li class="IXS">overview, <a href="chapter_3.html#pg_45">45–46</a></li>
<li class="IXS">Random Access Memory (RAM), <a href="chapter_3.html#pg_53">53–54</a></li>
<li class="IXS">registers, <a href="chapter_3.html#pg_52">52</a></li>
<li class="IXS">sequential logic, <a href="chapter_3.html#pg_46">46–49</a>, <a href="chapter_3.html#pg_50">50–51</a></li>
<li class="IX">Memory allocation algorithms, <a href="chapter_12.html#pg_253">253</a></li>
<li class="IX">Memory map</li>
<li class="IXS">concept, <a href="chapter_4.html#pg_74">74</a>, <a href="chapter_5.html#pg_87">87-88</a></li>
<li class="IXS">keyboard, <a href="chapter_4.html#pg_75">75</a>, <a href="chapter_5.html#pg_92">92</a></li>
<li class="IXS">screen, <a href="chapter_4.html#pg_75">75</a>, <a href="chapter_5.html#pg_91">91</a>, <a href="chapter_9.html#pg_188">188</a></li>
<li class="IX">Meta-language, <a href="chapter_10.html#pg_194">194</a></li>
<li class="IX">Mnemonic, <a href="chapter_6.html#pg_104">104</a></li>
<li class="IX">Modular design, <a href="part_1.html#pg_5">5–6</a></li>
<li class="IX">Most significant bits (MSB), <a href="chapter_2.html#pg_33">33</a></li>
<li class="IX">Multiplexer, <a href="part_1.html#pg_5">5</a>, <a href="chapter_1.html#pg_9">9</a>, <a href="chapter_1.html#pg_20">20</a></li>
</ul>
<ul class="ind">
<li class="IXA">Nand gates, <a href="part_1.html#pg_2">2</a>, <a href="part_1.html#pg_3">3</a>, <a href="appendix1.html#pg_279">279–281</a></li>
<li class="IXS">Boolean function, <a href="chapter_1.html#pg_19">19</a></li>
<li class="IXS">in DFF implementations, <a href="chapter_3.html#pg_55">55</a></li>
<li class="IXS">hardware based on, <a href="chapter_1.html#pg_25">25</a></li>
<li class="IXS">specification, <a href="chapter_1.html#pg_19">19</a></li>
<li class="IX">Nor gate, <a href="chapter_1.html#pg_28">28</a>, <a href="appendix1.html#pg_281">281</a></li>
<li class="IX">Not gate, <a href="chapter_1.html#pg_14">14</a>, <a href="chapter_1.html#pg_21">21</a></li>
</ul>
<ul class="ind">
<li class="IXA">Object construction and disposal (Jack), <a href="chapter_9.html#pg_185">185</a></li>
<li class="IX">Object-oriented languages, <a href="chapter_9.html#pg_188">188</a>, <a href="chapter_11.html#pg_221">221</a></li>
<li class="IX">Object variables, <a href="part_2.html#pg_121">121</a>, <a href="chapter_11.html#pg_221">221</a></li>
<li class="IX" id="ind10">Operating system, <a href="chapter_12.html#pg_245">245</a></li>
<li class="IXS">algebraic algorithms, <a href="chapter_12.html#pg_248">248–251</a></li>
<li class="IXS">character output, <a href="chapter_12.html#pg_258">258–259</a></li>
<li class="IXS">efficiency, <a href="chapter_12.html#pg_248">248</a></li>
<li class="IXS">geometric algorithms, <a href="chapter_12.html#pg_255">255–258</a></li>
<li class="IXS">heap management (<i>see</i> <a href="#ind10">Operating system, memory management</a>)</li>
<li class="IXS">keyboard handling, <a href="chapter_12.html#pg_259">259–260</a></li>
<li class="IXS">memory management, <a href="chapter_12.html#pg_252">252–254</a></li>
<li class="IXS">overview, <a href="chapter_12.html#pg_245">245–247</a></li>
<li class="IXS">peek / poke, <a href="chapter_12.html#pg_254">254</a></li>
<li class="IXS">strings handling, <a href="chapter_12.html#pg_251">251–252</a></li>
<li class="IX">Optimization, <a href="chapter_13.html#pg_275">275</a></li>
<li class="IX">Or gate, <a href="chapter_1.html#pg_9">9</a>, <a href="chapter_1.html#pg_14">14</a></li>
</ul>
<ul class="ind">
<li class="IXA">Parameter variables, <a href="chapter_9.html#pg_181">181</a></li>
<li class="IX">Parser, <a href="chapter_6.html#pg_110">110</a>, <a href="chapter_7.html#pg_140">140</a></li>
<li class="IX">Parse tree, <a href="chapter_10.html#pg_196">196</a></li>
<li class="IX">Parsing. <i>See</i> <a href="#ind12">Syntax analysis</a></li>
<li class="IX">Peek and poke, <a href="chapter_12.html#pg_254">254</a>, <a href="chapter_12.html#pg_272">272</a></li>
<li class="IX">Pixel drawing, <a href="chapter_12.html#pg_255">255</a></li>
<li class="IX">Pointer, <a href="chapter_4.html#pg_78">78–79</a></li>
<li class="IX">Predefined symbols, <a href="chapter_4.html#pg_73">73–74</a>, <a href="chapter_6.html#pg_106">106</a></li>
<li class="IX">Procedural languages, <a href="chapter_11.html#pg_225">225</a></li>
<li class="IX">Program control. <i>See</i> <a href="#ind2a">Projects, virtual machine, program control</a></li>
<li class="IX">Program counter, <a href="chapter_5.html#pg_87">87</a>, <a href="chapter_5.html#pg_89">89</a>, <a href="chapter_5.html#pg_96">96</a></li>
<li class="IX">Projects</li>
<li class="IXS">assembler (project 6), <a href="chapter_6.html#pg_113">113–114</a></li>
<li class="IXS">Boolean arithmetic (project 2), <a href="chapter_2.html#pg_42">42</a></li>
<li class="IXS">Boolean logic (project 1), <a href="chapter_1.html#pg_27">27–28</a></li>
<li class="IXS" id="ind1a">compiler, code generation (project 11), <a href="chapter_11.html#pg_237">237–241</a></li>
<li class="IXS">compiler, syntax analysis, (project 10), <a href="chapter_10.html#pg_206">206–209</a></li>
<li class="IXS">computer architecture (project 5), <a href="chapter_5.html#pg_98">98–99</a></li>
<li class="IXS">high-level language (project 9), <a href="chapter_9.html#pg_187">187–188</a></li>
<li class="IXS">machine language (project 4), <a href="chapter_4.html#pg_78">78–80</a></li>
<li class="IXS">memory (project 3), <a href="chapter_3.html#pg_58">58</a></li>
<li class="IXS">operating system (project 12), <a href="chapter_12.html#pg_267">267</a></li>
<li class="IXS">virtual machine, program control (project 7), <a href="chapter_8.html#pg_165">165–168</a></li>
<li class="IXS" id="ind4a">VM translator, stack processing (project 8), <a href="chapter_7.html#pg_142">142–144</a></li>
<li class="IX">Pseudo-instructions, <a href="chapter_4.html#pg_76">76</a>, <a href="chapter_6.html#pg_105">105</a></li>
<li class="IX">Push / pop commands, <a href="chapter_7.html#pg_133">133</a>, <a href="chapter_8.html#pg_164">164</a></li>
<li class="IX">Python Virtual Machine (PVM), <a href="chapter_7.html#pg_146">146</a></li>
</ul>
<ul class="ind">
<li class="IXA">Radix complement, <a href="chapter_2.html#pg_34">34</a></li>
<li class="IX">Random Access Memory (RAM), <a href="part_1.html#pg_3">3</a>, <a href="part_1.html#pg_7">7</a>, <a href="chapter_3.html#pg_53">53</a>, <a href="chapter_3.html#pg_56">56</a></li>
<li class="IXS">chips, <a href="part_1.html#pg_4">4</a></li>
<li class="IXS">derivation of term, <a href="chapter_5.html#pg_85">85</a></li>
<li class="IXS">device, description of, <a href="part_1.html#pg_5">5</a></li>
<li class="IXS">Hack computer, <a href="appendix6.html#pg_320">320</a></li>
<li class="IXS">OS, <a href="chapter_12.html#pg_263">263</a></li>
<li class="IX">Read Only Memory (ROM), <a href="chapter_5.html#pg_88">88</a>, <a href="chapter_5.html#pg_100">100</a></li>
<li class="IX">Recursive descent parsing, <a href="chapter_10.html#pg_198">198</a></li>
<li class="IX">Reduced Instruction Set Computing (RISC), <a href="chapter_5.html#pg_101">101</a></li>
<li class="IX">Reference variable, <a href="chapter_11.html#pg_221">221</a></li>
<li class="IX">Registers, <a href="part_1.html#pg_5">5</a></li>
<li class="IX">return address, <a href="chapter_8.html#pg_149">149</a>, <a href="chapter_8.html#pg_154">154–155</a>, <a href="chapter_8.html#pg_161">161–163</a></li>
<li class="IX">run-time system, <a href="chapter_8.html#pg_147">147–148</a></li>
</ul>
<ul class="ind">
<li class="IXA"><span aria-label="325" id="pg_325" role="doc-pagebreak"/>Screen memory map, <a href="chapter_4.html#pg_74">74</a>, <a href="chapter_5.html#pg_91">91</a></li>
<li class="IX" id="ind11">Sequential chips, <a href="chapter_3.html#pg_45">45</a>, <a href="chapter_3.html#pg_50">50</a>, <a href="appendix2.html#pg_289">289–291</a></li>
<li class="IX">Sequential logic, <a href="chapter_3.html#pg_46">46–51</a></li>
<li class="IX">Shannon, Claude, <a href="chapter_1.html#pg_13">13</a></li>
<li class="IX">Stack machine, <a href="chapter_7.html#pg_128">128–132</a></li>
<li class="IX">Stack overflow, <a href="chapter_8.html#pg_157">157</a></li>
<li class="IX">Stack processing. <i>See</i> <a href="#ind4a">Projects, VM translator, stack processing</a></li>
<li class="IX">Standard class library, <a href="part_2.html#pg_118">118</a>, <a href="part_2.html#pg_122">122</a>, <a href="chapter_12.html#pg_245">245</a>. <i>See also</i> <a href="#ind10">Operating system</a></li>
<li class="IX">Starvation, <a href="chapter_5.html#pg_86">86</a></li>
<li class="IX">Static variables, <a href="part_2.html#pg_121">121</a>, <a href="chapter_9.html#pg_181">181</a>, <a href="chapter_11.html#pg_214">214</a></li>
<li class="IX">Stored program computer, Hack as, <a href="chapter_13.html#pg_274">274</a></li>
<li class="IX">Stored program concept, <a href="chapter_5.html#pg_84">84</a></li>
<li class="IX">Switching devices, <a href="part_1.html#pg_2">2</a></li>
<li class="IX">Symbols (machine language), <a href="chapter_4.html#pg_73">73–74</a></li>
<li class="IX">Symbol table</li>
<li class="IXS">assembler, <a href="chapter_6.html#pg_103">103</a>, <a href="chapter_6.html#pg_108">108</a>, <a href="chapter_6.html#pg_112">112</a></li>
<li class="IXS">code generation, <a href="chapter_11.html#pg_212">212</a>, <a href="chapter_11.html#pg_214">214</a></li>
<li class="IXS">compiler, <a href="chapter_10.html#pg_202">202</a></li>
<li class="IX" id="ind12">Syntax analysis, <a href="chapter_10.html#pg_191">191–210</a></li>
<li class="IXS">derivation tree, <a href="chapter_10.html#pg_195">195</a></li>
<li class="IXS">grammar, <a href="chapter_10.html#pg_193">193</a>, <a href="chapter_10.html#pg_194">194–196</a>, <a href="chapter_10.html#pg_200">200</a></li>
<li class="IXS">implementation, <a href="chapter_10.html#pg_202">202–206</a></li>
<li class="IXS">Jack tokenizer, <a href="chapter_10.html#pg_203">203</a>, <a href="chapter_10.html#pg_207">207</a></li>
<li class="IXS">lexical analysis, <a href="chapter_10.html#pg_193">193–194</a></li>
<li class="IXS">meta-language, <a href="chapter_10.html#pg_194">194</a></li>
<li class="IXS">parser, <a href="chapter_10.html#pg_198">198–199</a>, <a href="chapter_10.html#pg_209">209</a></li>
<li class="IXS">parse tree, <a href="chapter_10.html#pg_195">195</a></li>
<li class="IXS">parsing, <a href="chapter_10.html#pg_196">196</a></li>
<li class="IXS">recursive descent parsing, <a href="chapter_10.html#pg_198">198</a></li>
<li class="IXS">symbol table, <a href="chapter_10.html#pg_202">202</a></li>
<li class="IXS">syntax analyzer, <a href="chapter_10.html#pg_200">200</a></li>
</ul>
<ul class="ind">
<li class="IXA">Test description language, <a href="appendix3.html#pg_299">299–312</a></li>
<li class="IXS">overview, <a href="appendix3.html#pg_299">299–301</a></li>
<li class="IXS">testing chips, <a href="appendix3.html#pg_301">301–308</a></li>
<li class="IXS">testing machine language programs, <a href="appendix3.html#pg_308">308–309</a></li>
<li class="IXS">testing VM programs, <a href="appendix3.html#pg_310">310–312</a></li>
<li class="IX">Test scripts, <a href="chapter_1.html#pg_17">17</a>, <a href="appendix2.html#pg_295">295</a>, <a href="appendix3.html#pg_308">308</a></li>
<li class="IX">Time-independent chips. <i>See</i> <a href="#ind3">Combinational chips</a></li>
<li class="IX">Time units, <a href="appendix2.html#pg_289">289</a>, <a href="appendix3.html#pg_302">302</a></li>
<li class="IX">Tokenizer, <a href="chapter_10.html#pg_193">193</a></li>
<li class="IX">Truth table, <a href="chapter_1.html#pg_10">10</a>, <a href="chapter_1.html#pg_11">11</a>, <a href="chapter_1.html#pg_12">12</a></li>
<li class="IX">Turing, Alan, <a href="chapter_7.html#pg_126">126</a></li>
<li class="IX">Turing machine, <a href="chapter_5.html#pg_84">84</a></li>
<li class="IX">Two’s complement method, <a href="chapter_2.html#pg_34">34</a></li>
</ul>
<ul class="ind">
<li class="IXA">Unconditional branching, <a href="chapter_4.html#pg_67">67</a></li>
</ul>
<ul class="ind">
<li class="IXA" id="ind2a">Virtual machine</li>
<li class="IXS">API, <a href="chapter_7.html#pg_139">139–142</a>, <a href="chapter_8.html#pg_164">164–165</a></li>
<li class="IXS">background, <a href="chapter_7.html#pg_125">125–128</a>, <a href="chapter_8.html#pg_147">147–149</a></li>
<li class="IXS">branching, <a href="chapter_8.html#pg_149">149–151</a></li>
<li class="IXS">function call and return, <a href="chapter_8.html#pg_151">151–157</a></li>
<li class="IXS">implementation, <a href="chapter_7.html#pg_134">134–139</a>, <a href="chapter_8.html#pg_159">159–164</a></li>
<li class="IXS">operating system support, <a href="chapter_8.html#pg_151">151</a></li>
<li class="IXS">push / pop, <a href="chapter_7.html#pg_129">129–130</a></li>
<li class="IXS">specification, <a href="chapter_8.html#pg_149">149–150</a>, <a href="chapter_8.html#pg_157">157–159</a></li>
<li class="IXS">stack, <a href="chapter_7.html#pg_128">128</a></li>
<li class="IXS">stack arithmetic, <a href="chapter_7.html#pg_130">130–132</a></li>
<li class="IXS">virtual memory segments, <a href="chapter_7.html#pg_132">132</a></li>
<li class="IXS">VM emulator, <a href="chapter_7.html#pg_138">138–139</a></li>
<li class="IX">Virtual memory segments, <a href="chapter_7.html#pg_132">132</a></li>
<li class="IX">Virtual registers, <a href="chapter_4.html#pg_68">68</a>, <a href="chapter_4.html#pg_74">74</a>, <a href="chapter_4.html#pg_77">77</a></li>
<li class="IX">Visualizing chips, <a href="appendix2.html#pg_291">291–293</a></li>
<li class="IX">von Neumann, John, <a href="chapter_4.html#pg_66">66</a></li>
<li class="IX">von Neumann architecture, <a href="chapter_4.html#pg_66">66</a>, <a href="chapter_5.html#pg_83">83</a>, <a href="chapter_5.html#pg_84">84</a></li>
</ul>
<ul class="ind">
<li class="IXA">Word size, <a href="chapter_2.html#pg_33">33</a></li>
</ul>
<ul class="ind">
<li class="IXA">XML, <a href="chapter_10.html#pg_191">191–192</a>, <a href="chapter_10.html#pg_206">206</a>, <a href="chapter_10.html#pg_210">210</a></li>
<li class="IX">Xor gate, <a href="chapter_1.html#pg_9">9</a>, <a href="chapter_1.html#pg_16">16–17</a></li>
</ul>
</section>
</div>
</body>
</html>