<html lang="en">
<head>
<title>10 Compiler I: Syntax Analysis</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch10"role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch10"><span aria-label="191" id="pg_191" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">10</samp>     <samp class="SANS_Helvetica_LT_Std_Bold_B_11">Compiler I: Syntax Analysis</samp></h1>
</header>
<blockquoterole="doc-epigraph">
<p class="EP1">Neither can embellishments of language be found without arrangement and expression of thoughts, nor can thoughts be made to shine without the light of language.</p>
<p class="EPA1">—Cicero (106–43 B.C.)</p>
</blockquote>
<p class="noindent">The previous chapter introduced Jack—a simple, object-based programming language with a Java-like syntax. In this chapter we start building a compiler for the Jack language. A <i>compiler</i> is a program that translates programs from a source language into a target language. The translation process, known as <i>compilation</i>, is conceptually based on two distinct tasks. First, we have to understand the syntax of the source program and, from it, uncover the program’s semantics. For example, the parsing of the code can reveal that the program seeks to declare an array or manipulate an object. Once we know the semantics, we can reexpress it using the syntax of the target language. The first task, typically called <i>syntax analysis</i>, is described in this chapter; the second task—<i>code generation</i>—is taken up in the next chapter.</p>
<p>How can we tell that a compiler is capable of “understanding” programs? Well, as long as the code generated by the compiler is doing what it’s supposed to be doing, we can optimistically assume that the compiler is operating properly. Yet in this chapter we build only the syntax analyzer module of the compiler, with no code generation capabilities. If we wish to unit-test the syntax analyzer in isolation, we have to contrive a way to demonstrate that it understands the source program. Our solution is to have the syntax analyzer output an XML file whose marked-up content reflects the syntactic structure of the source code. By inspecting the generated XML output, we’ll be able to ascertain that the analyzer is parsing input programs correctly.</p>
<p>Writing a compiler from the ground up is an exploit that brings to bear several fundamental topics in computer science. It requires the use of parsing and language translation techniques, application of classical data structures like trees and hash tables, and use of recursive compilation algorithms. For all these reasons, writing a compiler is also a challenging feat. However, by splitting the compiler’s construction into two separate projects (actually <i>four</i>, counting chapters 7 and 8 as well) and by allowing the modular development and unit-testing of each part in isolation, we turn the compiler’s development into a manageable and self-contained activity.</p>
<p><span aria-label="192" id="pg_192" role="doc-pagebreak"/>Why should you go through the trouble of building a compiler? Aside from the benefits of feeling competent and accomplished, a hands-on grasp of compilation internals will turn you into a better high-level programmer. Further, the same rules and grammars used for describing programming languages are also used in diverse fields like computer graphics, communications and networks, bioinformatics, machine learning, data science, and blockchain technology. And, the vibrant area of <i>natural language processing</i>—the enabling science and practice behind intelligent chatbots, robotic personal assistants, language translators, and many artificial intelligence applications—requires abilities for analyzing texts and synthesizing semantics. Thus, while most programmers don’t develop compilers in their regular jobs, many programmers have to parse and manipulate texts and data sets of complex and varying structures. These tasks can be done efficiently and elegantly using the algorithms and techniques described in this chapter.</p>
<p>We start with a Background section that surveys the minimal set of concepts necessary for building a syntax analyzer: lexical analysis, context-free grammars, parse trees, and recursive descent parsing algorithms. This sets the stage for a Specification section that presents the Jack language grammar and the output that a Jack analyzer is expected to generate. The Implementation section proposes a software architecture for constructing a Jack analyzer, along with a suggested API. As usual, the Project section gives step-by-step instructions and test programs for building a syntax analyzer. In the next chapter, this analyzer will be extended into a full-scale compiler.</p>
<section>
<h2 class="head a-head"><b>10.1    Background</b></h2>
<p class="noindent">Compilation consists of two main stages: <i>syntax analysis</i> and <i>code generation</i>. The syntax analysis stage is usually divided further into two substages: <i>tokenizing</i>, the grouping of input characters into language atoms called <i>tokens</i>, and <i>parsing,</i> the grouping of tokens into structured statements that have a meaning.</p>
<p>The tokenizing and parsing tasks are completely independent of the target language into which we seek to translate the source input. Since in this chapter we don’t deal with code generation, we have chosen to have the syntax analyzer output the parsed structure of the input program as an XML file. This decision has two benefits. First, the output file can be readily inspected, demonstrating that the syntax analyzer is parsing source programs correctly. Second, the requirement to output this file explicitly forces us to write the syntax analyzer in an architecture that can be later morphed into a full-scale compiler. Indeed, as <a href="chapter_10.xhtml#fig10-1" id="rfig10-1">figure 10.1</a> shows, in the next chapter we will extend the syntax analyzer developed in this chapter into a full-scale compilation engine capable of generating executable VM code rather than passive XML code.</p>
<figure class="IMG"><img alt="" id="fig10-1" src="../images/figure_10.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig10-1">Figure 10.1</a></b>    Staged development plan of the Jack compiler.</p></figcaption>
</figure>
<p>In this chapter we focus only on the syntax analyzer module of the compiler, whose job is <i>understanding the structure of a program</i>. This notion needs explanation. When humans read the source code of a computer program, they can immediately relate to the program’s structure. <span aria-label="193" id="pg_193" role="doc-pagebreak"/>They can do so since they have a mental image of the language’s <i>grammar</i>. In particular, they sense which program constructs are valid, and which are not. Using this grammatical insight, humans can identify where classes and methods begin and end, what are declarations, what are statements, what are expressions and how they are built, and so on. In order to recognize these language constructs, which may well be nested, humans recursively map them on the range of textual patterns accepted by the language grammar.</p>
<p>Syntax analyzers can be developed to perform similarly by building them according to a given <i>grammar</i>—the set of rules that define the syntax of a programming language. To understand—<i>parse</i>—a given program means to determine the exact correspondence between the program’s text and the grammar’s rules. To do so, we must first transform the program’s text into a list of <i>tokens</i>, as we now turn to describe.</p>
<section>
<h3 class="head b-head"><b>10.1.1    Lexical Analysis</b></h3>
<p class="noindent">Each programming language specification includes the types of <i>tokens</i>, or words, that the language recognizes. In the Jack language, tokens fall into five categories: <i>keywords</i> (like <samp class="SANS_Consolas_Regular_11">class</samp> and <samp class="SANS_Consolas_Regular_11">while</samp>), <i>symbols</i> <img alt="" class="inline" height="14" src="../images/10-1.png" width="88"/> <i>integer constants</i> (like <samp class="SANS_Consolas_Regular_11">17</samp> and <samp class="SANS_Consolas_Regular_11">314</samp>), <i>string constants</i> (like <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">FAQ</samp><samp class="SANS_Consolas_Regular_11">"</samp> and <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">Frequently</samp> <samp class="SANS_Consolas_Regular_11">Asked</samp> <samp class="SANS_Consolas_Regular_11">Questions</samp><samp class="SANS_Consolas_Regular_11">"</samp>), and <i>identifiers</i>, which are the textual labels used for naming variables, classes, and subroutines. Taken together, the tokens defined by these lexical categories can be referred to as the language <i>lexicon</i>.</p>
<p>In its plainest form, a computer program is a stream of characters stored in a text file. The first step in analyzing the program’s syntax is grouping the characters into tokens, as defined by the language lexicon, while ignoring white space and comments. This task is called <i>lexical analysis</i>, <i>scanning</i>, or <i>tokenizing</i>—all meaning exactly the same thing.</p>
<p>Once a program has been tokenized, the tokens, rather than the characters, are viewed as its basic atoms. Thus, the token stream becomes the compiler’s main input.</p>
<p><span aria-label="194" id="pg_194" role="doc-pagebreak"/><a href="chapter_10.xhtml#fig10-2" id="rfig10-2">Figure 10.2</a> presents the Jack language lexicon and illustrates the tokenization of a typical code segment. This version of the tokenizer outputs the tokens as well as their lexical classifications.</p>
<figure class="IMG"><img alt="" id="fig10-2" src="../images/figure_10.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig10-2">Figure 10.2</a></b>    Definition of the Jack lexicon, and lexical analysis of a sample input.</p></figcaption>
</figure>
<p>Tokenizing is a simple and important task. Given a language lexicon, it is not difficult to write a program that turns any given character stream into a stream of tokens. This capability provides the first stepping stone toward developing a syntax analyzer.</p>
</section>
<section>
<h3 class="head b-head"><b>10.1.2    Grammars</b></h3>
<p class="noindent">Once we develop the ability to access a given text as a stream of tokens, or words, we can proceed to attempt grouping the words into valid sentences. For example, when we hear that “Bob got the job” we nod approvingly, while inputs like “Got job the Bob” or “Job Bob the got” sound weird. We perform these parsing tasks without thinking about them, since our brains have been trained to map sequences of words on patterns that are either accepted or rejected by the English grammar. The grammars of programming languages are much simpler than those of natural languages. See <a href="chapter_10.xhtml#fig10-3" id="rfig10-3">figure 10.3</a> for an example.</p>
<figure class="IMG"><img alt="" id="fig10-3" src="../images/figure_10.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig10-3">Figure 10.3</a></b>    A subset of the Jack language grammar, and Jack code segments that are either accepted or rejected by the grammar.</p></figcaption>
</figure>
<p>A grammar is written in a <i>meta-language</i>: a language describing a language. Compilation theory is rife with formalisms for specifying, and reasoning about, grammars, languages, and meta-languages. Some of these formalisms are, well, painfully formal. Trying to keep things simple, in Nand to Tetris we view a grammar as a set of rules. Each rule consists of <span aria-label="195" id="pg_195" role="doc-pagebreak"/>a left side and a right side. The left side specifies the rule’s name, which is not part of the language. Rather, it is made up by the person who describes the grammar, and thus it is not terribly important. For example, if we replace a rule’s name with another name throughout the grammar, the grammar will be just as valid (though it may be less readable).</p>
<p>The rule’s right side describes the lingual pattern that the rule specifies. This pattern is a left-to-right sequence consisting of three building blocks: <i>terminals</i>, <i>nonterminals</i>, and <i>qualifiers</i>. Terminals are tokens, nonterminals are names of other rules, and qualifiers are represented by the five symbols |, *, ?, (, and). Terminal elements, like <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Bold_B_11">if</samp><samp class="SANS_Consolas_Regular_11">'</samp>, are specified in bold font and enclosed within single quotation marks; nonterminal elements, like <i>expression</i>, are specified using italic font; qualifiers are specified using regular font. For example, the rule <i>ifStatement</i>: <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Bold_B_11">if</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>expression</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">)</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">{</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>statements</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">}</samp><samp class="SANS_Consolas_Regular_11">'</samp> stipulates that every valid instance of an <i>ifStatement</i> must begin with the token <samp class="SANS_Consolas_Bold_B_11">if</samp>, followed by the token <samp class="SANS_Consolas_Regular_11">(</samp>, followed by a valid instance of an <i>expression</i> (defined elsewhere in the grammar), followed by the token), followed by the token <samp class="SANS_Consolas_Regular_11">{</samp>, followed by a valid instance of <i>statements</i> (defined elsewhere in the grammar), followed by the token}.</p>
<p>When there is more than one way to parse a pattern, we use the qualifier | to list the alternatives. For example, the rule <i>statement</i>: <i>letStatement</i> | <i>ifStatement</i> | <i>whileStatement</i> stipulates that a <i>statement</i> can be either a <i>letStatement</i>, an <i>ifStatement</i>, or a <i>whileStatement</i>.</p>
<p><span aria-label="196" id="pg_196" role="doc-pagebreak"/>The qualifier * is used to denote “0, 1, or more times.” For example, the rule <i>statements</i>: <i>statement</i>* stipulates that <i>statements</i> stands for 0, 1, or more instances of <i>statement</i>. In a similar vein, the qualifier ? is used to denote “0 or 1 times.” For example, the rule <i>expression</i>: <i>term</i> (<i>op term)?</i> stipulates that <i>expression</i> is a <i>term</i> that may or may not be followed by the sequence <i>op term</i>. This implies that, for example, <samp class="SANS_Consolas_Regular_11">x</samp> is an <i>expression</i>, and so are <img alt="" class="inline" height="12" src="../images/10-C2.png" width="78"/> and <img alt="" class="inline" height="11" src="../images/10-C3.png" width="33"/> The qualifiers (and) are used for grouping grammar elements. For example, (<i>op term</i>) stipulates that, in the context of this rule, <i>op</i> followed by <i>term</i> should be treated as one grammatical element.</p>
</section>
<section>
<h3 class="head b-head"><b>10.1.3    Parsing</b></h3>
<p class="noindent">Grammars are inherently recursive. Just like the sentence “Bob got the job that Alice offered” is considered valid, so is the statement <samp class="SANS_Consolas_Regular_11">if</samp> <img alt="" class="inline" height="14" src="../images/10-C4.png" width="165"/> How can we tell that this input is accepted by the grammar? After getting the first token and realizing that we have an <samp class="SANS_Consolas_Regular_11">if</samp> pattern, we focus on the rule <i>ifStatement</i>: <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Bold_B_11">if</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>expression</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">)</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">{</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>statements</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">}</samp><samp class="SANS_Consolas_Regular_11">'</samp>. The rule informs that following the token <samp class="SANS_Consolas_Bold_B_11">if</samp> there ought to be the token <samp class="SANS_Consolas_Regular_11">(</samp>, followed by an <i>expression</i>, followed by the token). And indeed, these requirements are satisfied by the input element <img alt="" class="inline" height="14" src="../images/10-C5.png" width="46"/> Back to the rule, we see that we now have to anticipate the token <samp class="SANS_Consolas_Regular_11">{</samp>, followed by <i>statements</i>, followed by the token}. Now, <i>statements</i> is defined as 0 or more instances of <i>statement</i>, and <i>statement</i>, in turn, is either a <i>letStatement</i>, an <i>ifStatement</i>, or a <i>whileStatement</i>. This expectation is met by the inner input element <samp class="SANS_Consolas_Bold_B_11">if</samp> <img alt="" class="inline" height="14" src="../images/10-C6.png" width="84"/> which is an <i>ifStatement</i>.</p>
<p>We see that the grammar of a programming language can be used to ascertain, without ambiguity, whether given inputs are accepted or rejected.<sup><a href="#footnote-000" id="footnote-000-backlink" role="doc-noteref">1</a></sup> As a side effect of this parsing act, the parser produces an exact correspondence between the given input, on the one hand, and the syntactic patterns admitted by the grammar rules, on the other. The correspondence can be represented by a data structure called a <i>parse tree</i>, also called a <i>derivation tree</i>, like the one shown in <a href="chapter_10.xhtml#fig10-4a" id="rfig10-4a">figure 10.4a</a>. If such a tree can be constructed, the parser renders the input valid; otherwise, it can report that the input contains syntax errors.</p>
<figure class="IMG"><img alt="" id="fig10-4a" src="../images/figure_10.4a.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig10-4a">Figure 10.4a</a></b>    Parse tree of a typical code segment. The parsing process is driven by the grammar rules.</p></figcaption>
</figure>
<p>How can we represent parse trees textually? In Nand to Tetris, we decided to have the parser output an XML file whose marked-up format reflects the tree structure. By inspecting this XML output file, we can ascertain that the parser is parsing the input correctly. See <a href="chapter_10.xhtml#fig10-4b" id="rfig10-4b">figure 10.4b</a> for an example.<span aria-label="197" id="pg_197" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" height="550" id="fig10-4b" src="../images/figure_10.4b.png"/>
<figcaption><p class="CAP"><b><a href="#rfig10-4b">Figure 10.4b</a></b>    Same parse tree, in XML.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><span aria-label="198" id="pg_198" role="doc-pagebreak"/><b>10.1.4    Parser</b></h3>
<p class="noindent">A parser is an agent that operates according to a given grammar. The parser accepts as input a stream of tokens and attempts to produce as output the parse tree associated with the given input. In our case, the input is expected to be structured according to the Jack grammar, and the output is written in XML. Note, though, that the parsing techniques that we now turn to describe are applicable to handling any programming language and structured file format.</p>
<p>There are several algorithms for constructing parse trees. The top-down approach, also known as <i>recursive descent parsing</i>, attempts to parse the tokenized input recursively, using the nested structures admitted by the language grammar. Such an algorithm can be implemented as follows. For every nontrivial rule in the grammar, we equip the parser program with a routine designed to parse the input according to that rule. For example, the grammar listed in <a href="chapter_10.xhtml#fig10-3">figure 10.3</a> can be implemented using a set of routines named <samp class="SANS_Consolas_Regular_11">compileStatement</samp>, <samp class="SANS_Consolas_Regular_11">compileStatements</samp>, <samp class="SANS_Consolas_Regular_11">compileLet</samp>, <samp class="SANS_Consolas_Regular_11">compileIf</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">compileExpression</samp>, and so on. We use the action verb <i>compile</i> rather than <i>parse</i>, since in the next chapter we will extend this logic into a full-scale compilation engine.</p>
<p>The parsing logic of each <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routine should follow the syntactic pattern specified by the right side of the <i>xxx</i> rule. For example, let us focus on the rule <i>whileStatement</i>: <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Bold_B_11">while</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>expression</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">)</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">{</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>statements</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">}</samp><samp class="SANS_Consolas_Regular_11">'</samp>. According to our scheme, this rule will be implemented by a parsing routine named <samp class="SANS_Consolas_Regular_11">compileWhile</samp>. This routine should realize the left-to-right derivation logic specified by the pattern <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Bold_B_11">while</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>expression</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">)</samp><samp class="SANS_Consolas_Regular_11">'</samp> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">{</samp><samp class="SANS_Consolas_Regular_11">'</samp> <i>statements</i> <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">}</samp><samp class="SANS_Consolas_Regular_11">'</samp>. Here is one way to implement this logic, using pseudocode:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.1.png"/></figure>
<p class="TNI1">This parsing process will continue until the <i>expression</i> and <i>statements</i> parts of the <samp class="SANS_Consolas_Regular_11">while</samp> statement have been fully parsed. Of course the <i>statements</i> part may well contain a lower-level <samp class="SANS_Consolas_Regular_11">while</samp> statement, in which case the parsing will continue recursively.</p>
<p>The example just shown illustrates the implementation of a relatively simple rule, whose derivation logic entails a simple case of straight-line parsing. In general, grammar rules <span aria-label="199" id="pg_199" role="doc-pagebreak"/>can be more complex. For example, consider the following rule, which specifies the definition of class-level <samp class="SANS_Consolas_Regular_11">static</samp> and instance-level <samp class="SANS_Consolas_Regular_11">field</samp> variables in the Jack language:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.2.png"/></figure>
<p class="TNI1">This rule presents two parsing challenges that go beyond straight-line parsing. First, the rule admits either <samp class="SANS_Consolas_Regular_11">static</samp> or <samp class="SANS_Consolas_Regular_11">field</samp> as its first token. Second, the rule admits multiple variable declarations. To address both issues, the implementation of the corresponding <samp class="SANS_Consolas_Regular_11">c</samp><samp class="SANS_Consolas_Regular_11">ompileClassVarDec</samp> routine can (i) handle the processing of the first token (<samp class="SANS_Consolas_Regular_11">static</samp> or <samp class="SANS_Consolas_Regular_11">field</samp>) directly, without calling a helper routine, and (ii) use a loop for handling all the variable declarations that the input contains. Generally speaking, different grammar rules entail slightly different parsing implementations. At the same time, they all follow the same contract: each <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routine should get from the input, and handle, all the tokens that make up <i>xxx</i>, advance the tokenizer exactly beyond these tokens, and output the parse tree of <i>xxx</i>.</p>
<p>Recursive parsing algorithms are simple and elegant. If the language is simple, a single token lookahead is all that it takes to know which parsing rule to invoke next. For example, if the current token is <samp class="SANS_Consolas_Regular_11">let</samp>, we know that we have a <i>letStatement</i>; if the current token is <samp class="SANS_Consolas_Regular_11">while</samp>, we know that we have a <i>whileStatement</i>, and so on. Indeed, in the simple grammar shown in <a href="chapter_10.xhtml#fig10-3">figure 10.3</a>, looking ahead one token suffices to resolve, without ambiguity, which rule to use next. Grammars that have this lingual property are called <i>LL</i> (1). These grammars can be handled simply and elegantly by recursive descent algorithms, without backtracking.</p>
<p>The term <i>LL</i> comes from the observation that the grammar parses the input from <i>left</i> to right, performing <i>leftmost</i> derivation of the input. The (1) parameter informs that looking ahead 1 token is all that it takes to know which parsing rule to invoke next. If that token does not suffice to resolve which rule to use, we can look ahead one more token. If this lookahead settles the ambiguity, the parser is said to be <i>LL</i> (2). And if not, we can look ahead yet another token, and so on. Clearly, as we need to look ahead further and further down the token stream, things become complicated, requiring a sophisticated parser.</p>
<p>The complete Jack language grammar, which we now turn to present, is <i>LL</i> (1), barring one exception that can be easily handled. Thus, Jack lends itself nicely to a recursive descent parser, which is the centerpiece of project 10.</p>
</section>
</section>
<section>
<h2 class="head a-head"><span aria-label="200" id="pg_200" role="doc-pagebreak"/><b>10.2    Specification</b></h2>
<p class="noindent">This section consists of two parts. First, we specify the Jack language’s grammar. Next, we specify a syntax analyzer designed to parse programs according to this grammar.</p>
<section>
<h3 class="head b-head"><b>10.2.1    The Jack Language Grammar</b></h3>
<p class="noindent">The functional specification of the Jack language presented in chapter 9 was aimed at Jack programmers; we now give a formal specification of the Jack language, aimed at developers of Jack compilers. The language specification, or <i>grammar</i>, uses the following notation:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.3.png"/></figure>
<p class="TNI1">With this notation in mind, the complete Jack grammar is specified in <a href="chapter_10.xhtml#fig10-5" id="rfig10-5">figure 10.5</a>.</p>
<figure class="IMG"><img alt="" height="550" id="fig10-5" src="../images/figure_10.5.png"/>
<figcaption><p class="CAP"><b><a href="#rfig10-5">Figure 10.5</a></b>    The Jack grammar.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><b>10.2.2    A Syntax Analyzer for the Jack Language</b></h3>
<p class="noindent">A syntax analyzer is a program that performs both tokenizing and parsing. In Nand to Tetris, the main purpose of the syntax analyzer is to process a Jack program and understand its syntactic structure according to the Jack grammar. By <i>understanding</i> we mean that the syntax analyzer must know, at each point in the parsing process, the structural identity of the program element that it is currently handling, that is, whether it is an expression, a statement, a variable name, and so on. The syntax analyzer must possess this syntactic knowledge in a complete recursive sense. Without it, it will be impossible to move on to code generation—the ultimate goal of the compilation process.</p>
<p class="STNI1"><b>Usage</b>: The syntax analyzer accepts a single command-line argument, as follows,</p>
<p class="COM2"><samp class="SANS_Consolas_Regular_11">prompt</samp><span class="symb">&gt;</span> <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> <i>source</i></p>
<p class="TNI1">where <i>source</i> is either a file name of the form <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> (the extension is mandatory) or the name of a folder (in which case there is no extension) containing one or more <samp class="SANS_Consolas_Regular_11">.jack</samp> files. The file/folder name may contain a file path. If no path is specified, the analyzer operates on the current folder. For each <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> file, the parser creates an output file <span aria-label="201" id="pg_201" role="doc-pagebreak"/><i>Xxx</i><samp class="SANS_Consolas_Regular_11">.xml</samp> and writes the parsed output into it. The output file is created in the same folder as that of the input. If there is a file by this name in the folder, it will be overwritten.</p>
<p class="STNI1"><span aria-label="202" id="pg_202" role="doc-pagebreak"/><b>Input</b>: An <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> file is a stream of characters. If the file represents a valid program, it can be tokenized into a stream of valid tokens, as specified by the Jack lexicon. The tokens may be separated by an arbitrary number of space characters, newline characters, and comments, which are ignored. There are three possible comment formats: <samp class="SANS_Consolas_Regular_11">/*</samp> comment until closing <samp class="SANS_Consolas_Regular_11">*/</samp>, <samp class="SANS_Consolas_Regular_11">/**</samp> API comment until closing <samp class="SANS_Consolas_Regular_11">*/</samp>, and <samp class="SANS_Consolas_Regular_11">//</samp> comment until the line’s end.</p>
<p class="STNI1"><b>Output</b>: The syntax analyzer emits an XML description of the input file, as follows. For each terminal element (<i>token</i>) of type <i>xxx</i> appearing in the input, the syntax analyzer prints the marked-up output <span class="symb-code">&lt;</span><i>xxx</i><span class="symb-code">&gt;</span> <i>token</i> <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">/</samp><i>xxx</i><span class="symb-code">&gt;</span>, where <i>xxx</i> is one of the tags <samp class="SANS_Consolas_Regular_11">keyword</samp>, <samp class="SANS_Consolas_Regular_11">symbol</samp>, <samp class="SANS_Consolas_Regular_11">integerConstant</samp>, <samp class="SANS_Consolas_Regular_11">stringConstant</samp>, or <samp class="SANS_Consolas_Regular_11">identifier</samp>, representing one of the five token types recognized by the Jack language. Whenever a nonterminal language element <i>xxx</i> is detected, the syntax analyzer handles it using the following pseudocode:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.4.png"/></figure>
<p class="TNI1">where <i>xxx</i> is one of the following (and only the following) tags: <samp class="SANS_Consolas_Regular_11">class</samp>, <samp class="SANS_Consolas_Regular_11">classVarDec</samp>, <samp class="SANS_Consolas_Regular_11">subroutineDec</samp>, <samp class="SANS_Consolas_Regular_11">parameterList</samp>, <samp class="SANS_Consolas_Regular_11">subroutineBody</samp>, <samp class="SANS_Consolas_Regular_11">varDec</samp>, <samp class="SANS_Consolas_Regular_11">statements</samp>, <samp class="SANS_Consolas_Regular_11">letStatement</samp>, <samp class="SANS_Consolas_Regular_11">ifStatement</samp>, <samp class="SANS_Consolas_Regular_11">whileStatement</samp>, <samp class="SANS_Consolas_Regular_11">doStatement</samp>, <samp class="SANS_Consolas_Regular_11">returnStatement</samp>, <samp class="SANS_Consolas_Regular_11">expression</samp>, <samp class="SANS_Consolas_Regular_11">term</samp>, <samp class="SANS_Consolas_Regular_11">expressionList</samp>.</p>
<p>To simplify things, the following Jack grammar rules are not accounted for explicitly in the XML output: <i>type</i>, <i>className</i>, <i>subroutineName</i>, <i>varName</i>, <i>statement</i>, <i>subroutineCall</i>. We will explain this further in the next section, when we discuss the architecture of our compilation engine.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>10.3    Implementation</b></h2>
<p class="noindent">The previous section specified <i>what</i> a syntax analyzer should do, with few implementation insights. This section describes <i>how</i> to build such an analyzer. Our proposed implementation is based on three modules:</p>
<ul class="List-1">
<li class="BLF"><samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp>: main program that sets up and invokes the other modules</li>
<li class="BL1"><samp class="SANS_Consolas_Regular_11">JackTokenizer</samp>: tokenizer</li>
<li class="BLL1"><samp class="SANS_Consolas_Regular_11">CompilationEngine</samp>: recursive top-down parser</li>
</ul>
<p class="TNI1">In the next chapter we will extend this software architecture with two additional modules that handle the language’s semantics: a <i>symbol table</i> and a <i>VM code writer</i>. This will <span aria-label="203" id="pg_203" role="doc-pagebreak"/>complete the construction of a full-scale compiler for the Jack language. Since the main module that drives the parsing process in this project will end up driving the overall compilation process as well, we name it <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp>.</p>
<section>
<h3 class="head b-head"><b>The JackTokenizer</b></h3>
<p class="noindent">This module ignores all comments and white space in the input stream and enables accessing the input one token at a time. Also, it parses and provides the <i>type</i> of each token, as defined by the Jack grammar.</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.7.png"/></figure>
</section>
<section>
<h3 class="head b-head"><span aria-label="204" id="pg_204" role="doc-pagebreak"/><b>The CompilationEngine</b></h3>
<p class="noindent">The <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> is the backbone module of both the syntax analyzer described in this chapter and the full-scale compiler described in the next chapter. In the syntax analyzer, the compilation engine emits a structured representation of the input source code wrapped in XML tags. In the compiler, the compilation engine will instead emit executable VM code. In both versions, the parsing logic and API presented below are exactly the same.</p>
<p>The compilation engine gets its input from a <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> and emits its output to an output file. The output is generated by a series of <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routines, each designed to handle the compilation of a specific Jack language construct <i>xxx</i>. The contract between these routines is that each <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routine should get from the input, and handle, all the tokens that make up <i>xxx</i>, advance the tokenizer exactly beyond these tokens, and output the parsing of <i>xxx</i>. As a rule, each <samp class="SANS_Consolas_Regular_11">compile</samp><i>xxx</i> routine is called only if the current token is <i>xxx</i>.</p>
<p class="STNI1"><b>Grammar rules that have no corresponding</b> <samp class="SANS_Consolas_Bold_B_11">compil</samp><samp class="SANS_Consolas_Bold_B_11">e</samp><b><i>xxx</i></b> <b>routines</b>: <i>type</i>, <i>className</i>, <i>subroutineName</i>, <i>varName</i>, <i>statement</i>, <i>subroutineCall</i>. We introduced these rules to make the Jack grammar more structured. As it turns out, the parsing logic of these rules is better handled by the routines that implement the rules that refer to them. For example, instead of writing a <samp class="SANS_Consolas_Regular_11">compileType</samp> routine, whenever <i>type</i> is mentioned in some rule <i>xxx</i>, the parsing of the possible types should be done directly by the <samp class="SANS_Consolas_Regular_11">compile</samp> <i>xxx</i> routine.</p>
<p class="STNI1"><b>Token lookahead</b>: Jack is almost an <i>LL</i>(1) language: the current token is sufficient for determining which <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> routine to call next. The only exception occurs when parsing a <i>term</i>, which occurs only when parsing an <i>expression</i>. To illustrate, consider the contrived yet valid expression <img alt="" class="inline" height="14" src="../images/10-C7.png" width="381"/>This expression is made up of six terms: the variable <samp class="SANS_Consolas_Regular_11">y</samp>, the array element <samp class="SANS_Consolas_Regular_11">arr[5]</samp>, the method call on the <samp class="SANS_Consolas_Regular_11">p</samp> object <samp class="SANS_Consolas_Regular_11">p.get</samp> <samp class="SANS_Consolas_Regular_11">(row)</samp>, the method call on the <samp class="SANS_Consolas_Regular_11">this</samp> object <samp class="SANS_Consolas_Regular_11">count</samp> <samp class="SANS_Consolas_Regular_11">()</samp>, the call to the function (static method) <samp class="SANS_Consolas_Regular_11">Math.sqrt(dist)</samp>, and the constant <samp class="SANS_Consolas_Regular_11">2</samp>.</p>
<p>Suppose that we are parsing this expression and the current token is one of the identifiers <samp class="SANS_Consolas_Regular_11">y</samp>, <samp class="SANS_Consolas_Regular_11">arr</samp>, <samp class="SANS_Consolas_Regular_11">p</samp>, <samp class="SANS_Consolas_Regular_11">count</samp>, or <samp class="SANS_Consolas_Regular_11">Math</samp>. In each one of these cases, we know that we have a <i>term</i> that begins with an <i>identifier</i>, but we don’t know which parsing possibility to follow next. That’s the bad news; the good news is that a single lookahead to the next token is all that we need to settle the dilemma.</p>
<p>The need for this irregular lookahead operation occurs in the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> twice: when parsing a <i>term</i>, which happens only when parsing an <i>expression</i>, and when parsing a <i>subroutineCall</i>. Now, an inspection of the Jack grammar shows that <i>subroutineCall</i> appears in two places only: either in a <samp class="SANS_Consolas_Regular_11">do</samp> <i>subroutineCall</i> statement or in a <i>term</i>.</p>
<p>With that in mind, we propose parsing <samp class="SANS_Consolas_Regular_11">do</samp> <i>subroutineCall</i> statements as if their syntax were <samp class="SANS_Consolas_Regular_11">do</samp> <i>expression</i>. This pragmatic recommendation obviates the need to write the irregular lookahead code twice. It also implies that the parsing of <i>subroutineCall</i> can now be handled directly by the <samp class="SANS_Consolas_Regular_11">compileTerm</samp> routine. In short, we’ve localized the need to write <span aria-label="205" id="pg_205" role="doc-pagebreak"/>the irregular token lookahead code to one routine only, <samp class="SANS_Consolas_Regular_11">compileTerm</samp>, and we’ve eliminated the need for a <samp class="SANS_Consolas_Regular_11">compileSubroutineCall</samp> routine.</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.8.png"/>
</figure>
<p class="STNI1"><span aria-label="206" id="pg_206" role="doc-pagebreak"/><b>The</b> <samp class="SANS_Consolas_Bold_B_11">compileExpressionList</samp> <b>routine:</b> returns the number of expressions in the list. The return value is necessary for generating VM code, as we’ll see when we’ll complete the compiler’s development in project 11. In this project we generate no VM code; therefore the returned value is not used and can be ignored by routines that call <samp class="SANS_Consolas_Regular_11">compileExpressionList</samp>.</p>
</section>
<section>
<h3 class="head b-head"><b>The JackAnalyzer</b></h3>
<p class="noindent">This is the main program that drives the overall syntax analysis process, using the services of a <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> and a <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp>. For each source <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> file, the analyzer</p>
<ol class="List-1">
<li class="NLF" value="1">creates a <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> from the <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> input file;</li>
<li class="NL">creates an output file named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.xml</samp>; and</li>
<li class="NLL1">uses the <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> and the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> to parse the input file and write the parsed code to the output file.</li>
</ol>
<p class="TNI1">We provide no API for this module, inviting you to implement it as you see fit. Remember that the first routine that must be called when compiling a <samp class="SANS_Consolas_Regular_11">.jack</samp> file is <samp class="SANS_Consolas_Regular_11">compileClass</samp>.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>10.4    Project</b></h2>
<p class="noindent"><b>Objective</b>: Build a syntax analyzer that parses Jack programs according to the Jack grammar. The analyzer’s output should be written in XML, as specified in section 10.2.2.</p>
<p>This version of the syntax analyzer assumes that the source Jack code is error-free. Error checking, reporting, and handling can be added to later versions of the analyzer but are not part of project 10.</p>
<p class="STNI1"><b>Resources</b>: The main tool in this project is the programming language that you will use for implementing the syntax analyzer. You will also need the supplied TextComparer utility. This program allows comparing files while ignoring white space. This will help you compare the output files generated by your analyzer with the supplied compare files. You may also want to inspect these files using an XML viewer. Any standard web browser should do the job—just use your browser’s “open file” option to open the XML file that you wish to inspect.</p>
<p class="STNI1"><b>Contract</b>: Write a syntax analyzer for the Jack language, and test it on the supplied test files. The XML files produced by your analyzer should be identical to the supplied compare files, ignoring white space.</p>
<p class="STNI1"><span aria-label="207" id="pg_207" role="doc-pagebreak"/><b>Test files</b>: We provide several <samp class="SANS_Consolas_Regular_11">.jack</samp> files for testing purposes. The <samp class="SANS_Consolas_Regular_11">projects/10/Square</samp> program is a three-class app that enables moving a black square around the screen using the keyboard’s arrow keys. The <samp class="SANS_Consolas_Regular_11">projects/10/ArrayTest</samp> program is a single-class app that computes the average of a user-supplied sequence of integers using array processing. Both programs were discussed in chapter 9, so they should be familiar. Note, though, that we made some harmless changes to the original code to make sure that the syntax analyzer will be fully tested on all aspects of the Jack language. For example, we’ve added a static variable to <samp class="SANS_Consolas_Regular_11">projects/10/Square/Main.jack</samp>, as well as a function named <samp class="SANS_Consolas_Regular_11">more</samp>, which are never used or called. These changes allow testing how the analyzer handles language elements that don’t appear in the original <samp class="SANS_Consolas_Regular_11">Square</samp> and <samp class="SANS_Consolas_Regular_11">ArrayTest</samp> files, like static variables, <samp class="SANS_Consolas_Regular_11">else</samp>, and unary operators.</p>
<p class="STNI1"><b>Development plan</b>: We suggest developing and unit-testing the analyzer in four stages:</p>
<ul class="List-1">
<li class="BLF">First, write and test a Jack tokenizer.</li>
<li class="BL1">Next, write and test a basic compilation engine that handles all the features of the Jack language, except for expressions and array-oriented statements.</li>
<li class="BL1">Next, extend your compilation engine to handle expressions.</li>
<li class="BLL1">Finally, extend your compilation engine to handle array-oriented statements.</li>
</ul>
<p class="TNI1">We provide input <samp class="SANS_Consolas_Regular_11">.jack</samp> files and compare <samp class="SANS_Consolas_Regular_11">.xml</samp> files for unit-testing each one of the four stages, as we now turn to describe.</p>
<section>
<h3 class="head b-head"><b>10.4.1    Tokenizer</b></h3>
<p class="noindent">Implement the <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> module specified in section 10.3. Test your implementation by writing a basic version of the <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp>, defined as follows. The analyzer, which is the main program, is invoked using the command <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> <i>source</i>, where <i>source</i> is either a file name of the form <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> (the extension is mandatory) or a folder name (in which case there is no extension). In the latter case, the folder contains one or more <samp class="SANS_Consolas_Regular_11">.jack</samp> files and, possibly, other files as well. The file/folder name may include a file path. If no path is specified, the analyzer operates on the current folder.</p>
<p>The analyzer handles each file separately. In particular, for each <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> file, the analyzer constructs a <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> for handling the input and an output file for writing the output. In this first version of the analyzer, the output file is named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">T.xml</samp> (where <samp class="SANS_Consolas_Regular_11">T</samp> stands for <i>tokenized output</i>). The analyzer then enters a loop to <samp class="SANS_Consolas_Regular_11">advance</samp> and handle all the tokens in the input file, one token at a time, using the <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> methods. Each token should be printed in a separate line, as <span class="symb-code">&lt;</span><i>tokenType</i><span class="symb-code">&gt;</span> <i>token</i> <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">/</samp><i>tokenType</i><span class="symb-code">&gt;</span>, where <i>tokenType</i> is one of five possible XML tags coding the token’s type. Here is an example:<span aria-label="208" id="pg_208" role="doc-pagebreak"/></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.5.png"/></figure>
<p class="TNI1">Note that in the case of <i>string constants</i>, the program ignores the double quotation marks. This requirement is by design.</p>
<p>The generated output has two trivial technicalities dictated by XML conventions. First, an XML file must be enclosed within some begin and end tags; this convention is satisfied by the <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">tokens</samp><span class="symb-code">&gt;</span> and <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">/tokens</samp><span class="symb-code">&gt;</span> tags. Second, four of the symbols used in the Jack language (<span class="symb-code">&lt;</span>, <span class="symb-code">&gt;</span>, <samp class="SANS_Consolas_Regular_11">"</samp>, <samp class="SANS_Consolas_Regular_11">&amp;</samp>) are also used for XML markup; thus they cannot appear as data in XML files. Following convention, the analyzer represents these symbols as <samp class="SANS_Consolas_Regular_11">&amp;lt;</samp>, <samp class="SANS_Consolas_Regular_11">&amp;gt;</samp>, <samp class="SANS_Consolas_Regular_11">&amp;quot;</samp>, and <samp class="SANS_Consolas_Regular_11">&amp;amp;</samp>, respectively. For example, when the parser encounters the <span class="symb-code">&lt;</span> symbol in the input file, it outputs the line <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">symbol</samp><span class="symb-code">&gt;</span> <samp class="SANS_Consolas_Regular_11">&amp;lt;</samp> <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">/symbol</samp><span class="symb-code">&gt;</span>. This so-called <i>escape sequence</i> is rendered by XML viewers as <span class="symb-code">&lt;</span><samp class="SANS_Consolas_Regular_11">symbol</samp><span class="symb-code">&gt; &lt; &lt;</span><samp class="SANS_Consolas_Regular_11">/symbol</samp><span class="symb-code">&gt;</span>, which is what we want.</p>
</section>
<section>
<h3 class="head b-head"><b>Testing Guidelines</b></h3>
<ul class="List-1">
<li class="BL1">Start by applying your <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> to one of the supplied <samp class="SANS_Consolas_Regular_11">.jack</samp> files, and verify that it operates correctly on a single input file.</li>
<li class="BL1">Next, apply your <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> to the <samp class="SANS_Consolas_Regular_11">Square</samp> folder, containing the files <samp class="SANS_Consolas_Regular_11">Main.jack</samp>, <samp class="SANS_Consolas_Regular_11">Square.jack</samp>, and <samp class="SANS_Consolas_Regular_11">SquareGame.jack</samp>, and to the <samp class="SANS_Consolas_Regular_11">TestArray</samp> folder, containing the file <samp class="SANS_Consolas_Regular_11">Main.jack</samp>.</li>
<li class="BL1">Use the supplied <samp class="SANS_Consolas_Regular_11">TextComparer</samp> utility to compare the output files generated by your <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> to the supplied <samp class="SANS_Consolas_Regular_11">.xml</samp> compare files. For example, compare the generated file <samp class="SANS_Consolas_Regular_11">SquareT.xml</samp> to the supplied compare file <samp class="SANS_Consolas_Regular_11">SquareT.xml</samp>.</li>
<li class="BLL">Since the generated and compare files have the same names, we suggest putting them in separate folders.</li>
</ul>
</section>
<section>
<h3 class="head b-head"><span aria-label="209" id="pg_209" role="doc-pagebreak"/><b>10.4.2    Compilation Engine</b></h3>
<p class="noindent">The next version of your syntax analyzer should be capable of parsing every element of the Jack language, except for expressions and array-oriented commands. To that end, implement the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> module specified in section 10.3, except for the routines that handle expressions and arrays. Test the implementation by using your Jack analyzer, as follows.</p>
<p>For each <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.jack</samp> file, the analyzer constructs a <samp class="SANS_Consolas_Regular_11">JackTokenizer</samp> for handling the input and an output file for writing the output, named <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.xml</samp>. The analyzer then calls the <samp class="SANS_Consolas_Regular_11">compileClass</samp> routine of the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp>. From this point onward, the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> routines should call each other recursively, emitting XML output similar to the one shown in <a href="chapter_10.xhtml#fig10-4b">figure 10.4b</a>.</p>
<p>Unit-test this version of your <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> by applying it to the folder <samp class="SANS_Consolas_Regular_11">ExpressionlessSquare</samp>. This folder contains versions of the files <samp class="SANS_Consolas_Regular_11">Square.jack</samp>, <samp class="SANS_Consolas_Regular_11">SquareGame.jack</samp>, and <samp class="SANS_Consolas_Regular_11">Main.jack</samp>, in which each expression in the original code has been replaced with a single identifier (a variable name in scope). For example:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_10.6.png"/></figure>
<p class="TNI1">Note that the replacement of expressions with variables results in nonsensical code. This is fine, since the program semantics is irrelevant to project 10. The nonsensical code is syntactically correct, and that’s all that matters for testing the parser. Note also that the original and expressionless files have the same names but are located in separate folders.</p>
<p>Use the supplied <samp class="SANS_Consolas_Regular_11">TextComparer</samp> utility to compare the output files generated by your <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> with the supplied <samp class="SANS_Consolas_Regular_11">.xml</samp> compare files.</p>
<p>Next, complete the <samp class="SANS_Consolas_Regular_11">CompilationEngine</samp> routines that handle expressions, and test them by applying your <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> to the <samp class="SANS_Consolas_Regular_11">Square</samp> folder. Finally, complete the routines that handle arrays, and test them by applying your <samp class="SANS_Consolas_Regular_11">JackAnalyzer</samp> to the <samp class="SANS_Consolas_Regular_11">ArrayTest</samp> folder.</p>
<p class="STNI1"><b>A web-based version of project 10</b> is available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
</section>
</section>
<section>
<h2 class="head a-head"><span aria-label="210" id="pg_210" role="doc-pagebreak"/><b>10.5    Perspective</b></h2>
<p class="noindent">Although it is convenient to describe the structure of computer programs using parse trees and XML files, it’s important to understand that compilers don’t necessarily have to maintain such data structures explicitly. For example, the parsing algorithm described in this chapter parses the input as it reads it and does not keep the entire input program in memory. There are essentially two types of strategies for doing such parsing. The simpler strategy works top-down, and that is the one presented in this chapter. The more advanced parsing algorithms, which work bottom-up, were not described here since they require elaboration of more compilation theory.</p>
<p>Indeed, in this chapter we have sidestepped the formal language theory studied in typical compilation courses. Also, we have chosen a simple syntax for the Jack language—a syntax that can be easily compiled using recursive descent techniques. For example, the Jack grammar does not mandate the usual operator precedence in algebraic expressions evaluation, like multiplication before addition. This enabled us to avoid parsing algorithms that are more powerful, but also more intricate, than the elegant top-down parsing techniques presented in this chapter.</p>
<p>Every programmer experiences the disgraceful handling of compilation errors, which is typical of many compilers. As it turns out, error diagnostics and reporting are a challenging problem. In many cases, the impact of an error is detected several or many lines of code after the error was made. Therefore, error reporting is sometimes cryptic and unfriendly. Indeed, one aspect in which compilers vary greatly is their ability to diagnose, and help debug, errors. To do so, compilers persist parts of the parse tree in memory and extend the tree with annotations that help pinpoint the source of errors and backtrack the diagnostic process, as needed. In Nand to Tetris we bypass all these extensions, assuming that the source files that the compiler handles are error-free.</p>
<p>Another topic that we hardly mentioned is how the syntax and semantics of programming languages are studied in computer and cognitive science. There is a rich theory of formal and natural languages that discusses properties of classes of languages, as well as meta-languages and formalisms for specifying them. This is also the place where computer science meets the study of human languages, leading to the vibrant areas of research and practice known as computational linguistics and natural language processing.</p>
<p>Finally, it is worth mentioning that syntax analyzers are typically not standalone programs and are rarely written from scratch. Instead, programmers usually build tokenizers and parsers using a variety of <i>compiler generator</i> tools like LEX (for <i>LEXical analysis</i>) and YACC (for <i>Yet Another Compiler Compiler</i>). These utilities receive as input a context-free grammar and produce as output syntax analysis code capable of tokenizing and parsing programs written in that grammar. The generated code can then be customized to fit the specific needs of the compiler writer. Following the “show me” spirit of Nand to Tetris, though, we have chosen not to use such black boxes in the implementation of our compiler, but rather build everything from the ground up.</p>
<hr class="HorizontalRule-1"/>
<ol class="footnotes">
<li><p class="FN" role="doc-footnote"><span class="fnnum"><a href="#footnote-000-backlink" id="footnote-000">1</a></span>.  And here lies a crucial difference between programming languages and natural languages. In natural languages, we can say things like “Whoever saves one life, saves the world entire.” In the English language, putting the adjective after the noun is grammatically incorrect. Yet, in this particular case, it sounds perfectly acceptable. Unlike programming languages, natural languages mandate a poetic license to break grammar rules, so long as the writer knows what he or she is doing. This freedom of expression makes natural languages infinitely rich.</p></li>
</ol>
</section>
</section>
</div>
</body>
</html>