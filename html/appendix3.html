<html lang="en">
<head>
<title>3 Test Description Language</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<sectionrole="doc-appendix">
<header>
<h1 class="BMH"><span aria-label="299" id="pg_299" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">Appendix 3: Test Description Language</samp></h1>
</header>
<blockquoterole="doc-epigraph">
<p class="EP1">Mistakes are the portals of discovery.</p>
<p class="EPA2">—James Joyce (1882–1941)</p>
</blockquote>
<p class="noindent">Testing is a critically important element of systems development, and one that typically gets insufficient attention in computer science education. In Nand to Tetris we take testing very seriously. We believe that before one sets out to develop a new hardware or software module <i>P</i>, one must first develop a module <i>T</i> designed to test it. Further, <i>T</i> should be part of <i>P</i>’s development’s contract. Therefore, for every chip or software system specified in this book, we supply official test programs, written by us. Although you are welcome to test your work in any way you see fit, the contract is such that, ultimately, your implementation must pass <i>our</i> tests.</p>
<p>In order to streamline the definition and execution of the numerous tests scattered all over the book projects, we designed a uniform test description language. This language works almost the same across all the relevant tools supplied in Nand to Tetris: the <i>hardware simulator</i> used for simulating and testing chips written in HDL, the <i>CPU emulator</i> used for simulating and testing machine language programs, and the <i>VM emulator</i> used for simulating and testing programs written in the VM language, which are typically compiled Jack programs.</p>
<p>Every one of these simulators features a GUI that enables testing the loaded chip or program interactively, or batch-style, using a test script. A test script is a sequence of commands that load a hardware or software module into the relevant simulator and subject the module to a series of preplanned testing scenarios. In addition, the test scripts feature commands for printing the test results and comparing them to desired results, as defined in supplied compare files. In sum, a test script enables a systematic, replicable, and documented testing of the underlying code—an invaluable requirement in any hardware or software development project.</p>
<p>In Nand to Tetris, we don’t expect learners to write test scripts. All the test scripts necessary to test all the hardware and software modules mentioned in the book are supplied with the project materials. Thus, the purpose of this appendix is not to teach you how to write test scripts but rather to help you understand the syntax and logic of the supplied <span aria-label="300" id="pg_300" role="doc-pagebreak"/>test scripts. Of course, you are welcome to customize the supplied scripts and create new ones, as you please.</p>
<section>
<h2 class="head a-head"><b>A3.1    General Guidelines</b></h2>
<p class="noindent">The following usage guidelines are applicable to all the software tools and test scripts.</p>
<p class="STNI1"><b>File format and usage</b>: The act of testing a hardware or software module involves four types of files. Although not required, we recommend that all four files have the same prefix (file name):</p>
<ul class="no-bullet">
<li class="ULF"><i>Xxx.yyy</i>: where <i>Xxx</i> is the name of the tested module and <i>yyy</i> is either <samp class="SANS_Consolas_Regular_11">hdl</samp>, <samp class="SANS_Consolas_Regular_11">hack</samp>, <samp class="SANS_Consolas_Regular_11">asm</samp>, or <samp class="SANS_Consolas_Regular_11">vm</samp>, standing, respectively, for a chip definition written in HDL, a program written in the Hack machine language, a program written in the Hack assembly language, or a program written in the VM virtual machine language</li>
<li class="UL"><i>Xxx</i><samp class="SANS_Consolas_Regular_11">.tst</samp>: a test script that walks the simulator through a series of steps designed to test the code stored in <i>Xxx</i></li>
<li class="UL"><i>Xxx</i><samp class="SANS_Consolas_Regular_11">.out</samp>: an optional output file to which the script commands can write current values of selected variables during the simulation</li>
<li class="ULL"><i>Xxx</i><samp class="SANS_Consolas_Regular_11">.cmp</samp>: an optional compare file containing the <i>desired</i> values of selected variables, that is, the values that the simulation <i>should</i> generate if the module is implemented correctly</li>
</ul>
<p class="TNI1">All these files should be kept in the same folder, which can be conveniently named <i>Xxx</i>. In the documentation and descriptions of all the simulators, the term “current folder” refers to the folder from which the last file has been opened in the simulator environment.</p>
<p class="STNI1"><b>White space</b>: Space characters, newline characters, and comments in test scripts (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.tst</samp> files) are ignored. The following comment formats can appear in test scripts:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A3.1.png"/></figure>
<p class="noindent">Test scripts are not case-sensitive, except for file and folder names.</p>
<p class="STNI1"><b>Usage</b>: For each hardware or software module <i>Xxx</i> in Nand to Tetris we supply a script file <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.tst</samp> and a compare file <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.cmp</samp>. These files are designed to test your implementation of <i>Xxx</i>. In some cases, we also supply a skeletal version of <i>Xxx</i>, for example, an HDL interface with a missing implementation. All the files in all the projects are plain text files that should be viewed and edited using plain text editors.</p>
<p><span aria-label="301" id="pg_301" role="doc-pagebreak"/>Typically, you will start a simulation session by loading the supplied <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.tst</samp> script file into the relevant simulator. The first command in the script typically loads the code stored in the tested module <i>Xxx</i>. Next, optionally, come commands that initialize an output file and specify a compare file. The remaining commands in the script run the actual tests.</p>
<p class="STNI1"><b>Simulation controls</b>: Each one of the supplied simulators features a set of menus and icons for controlling the simulation.</p>
<ul class="no-bullet">
<li class="ULF"><samp class="SANS_Consolas_Regular_11">File</samp> menu: Allows loading into the simulator either a relevant program (<samp class="SANS_Consolas_Regular_11">.hdl</samp> file, <samp class="SANS_Consolas_Regular_11">.hack</samp> file, <samp class="SANS_Consolas_Regular_11">.asm</samp> file, <samp class="SANS_Consolas_Regular_11">.vm</samp> file, or a folder name) or a test script (<samp class="SANS_Consolas_Regular_11">.tst</samp> file). If the user does not load a test script, the simulator loads a default test script (described below).</li>
<li class="UL"><samp class="SANS_Consolas_Regular_11">Play</samp> icon: Instructs the simulator to execute the next simulation step, as specified in the currently loaded test script.</li>
<li class="UL"><samp class="SANS_Consolas_Regular_11">Pause</samp> icon: Instructs the simulator to pause the execution of the currently loaded test script. Useful for inspecting various elements of the simulated environment.</li>
<li class="UL"><samp class="SANS_Consolas_Regular_11">Fast-forward</samp> icon: Instructs the simulator to execute all the commands in the currently loaded test script.</li>
<li class="UL"><samp class="SANS_Consolas_Regular_11">Stop</samp> icon: Instructs the simulator to stop the execution of the currently loaded test script.</li>
<li class="ULL"><samp class="SANS_Consolas_Regular_11">Rewind</samp> icon: Instructs the simulator to reset the execution of the currently loaded test script, that is, be ready to start executing the test script from its first command onward.</li>
</ul>
<p class="TNI1">Note that the simulator’s icons listed above don’t “run the code.” Rather, they run the test script, which runs the code.</p>
</section>
<section>
<h2 class="head a-head"><b>A3.2    Testing Chips on the Hardware Simulator</b></h2>
<p class="noindent">The supplied hardware simulator is designed for testing and simulating chip definitions written in the Hardware Description Language (HDL) described in appendix 2. Chapter 1 provides essential background on chip development and testing; thus, we recommend reading it first.</p>
<p class="STNI1"><b>Example</b>: <a href="appendix2.html#figA2-1">Figure A2.1</a> in appendix 2 presents an <samp class="SANS_Consolas_Regular_11">Eq3</samp> chip, designed to check whether three 1-bit inputs are equal. <a href="appendix3.html#figA3-1" id="rfigA3-1">Figure A3.1</a> presents <samp class="SANS_Consolas_Regular_11">Eq3.tst</samp>, a script designed to test the chip, and <samp class="SANS_Consolas_Regular_11">Eq3.cmp</samp>, a compare file containing the expected output of this test.</p>
<figure class="IMG"><img alt="" id="figA3-1" src="../images/figure_A3.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA3-1">Figure A3.1</a></b>    Test script and compare file (example).</p></figcaption>
</figure>
<p>A test script normally starts with some setup commands, followed by a series of simulation steps, each ending with a semicolon. A simulation step typically instructs the simulator to bind the chip’s input pins to test values, evaluate the chip logic, and write selected variable values into a designated output file.</p>
<p><span aria-label="302" id="pg_302" role="doc-pagebreak"/>The <samp class="SANS_Consolas_Regular_11">Eq3</samp> chip has three 1-bit inputs; thus, an exhaustive test would require eight testing scenarios. The size of an exhaustive test grows exponentially with the input size. Therefore, most test scripts test only a subset of representative input values, as shown in the figure.</p>
<p class="STNI1"><b>Data types and variables</b>: Test scripts support two data types: <i>integers</i> and <i>strings</i>. Integer constants can be expressed in decimal <samp class="SANS_Consolas_Regular_11">(%D</samp> prefix) format, which is the default, binary <samp class="SANS_Consolas_Regular_11">(%B</samp> prefix) format, or hexadecimal <samp class="SANS_Consolas_Regular_11">(%X</samp> prefix) format. These values are always translated into their equivalent two’s complement binary values. For example, consider the following commands:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A3.2.png"/></figure>
<p class="TNI1">All four variables are set to the same value: <samp class="SANS_Consolas_Regular_11">1111111111111111</samp> in binary, which happens to be the binary, two’s complement representation of <img alt="" class="inline" height="12" src="../images/A3-3.png" width="16"/> in decimal.</p>
<p>String values are specified using a <samp class="SANS_Consolas_Regular_11">%S</samp> prefix and must be enclosed by double quotation marks. Strings are used strictly for printing purposes and cannot be assigned to variables.</p>
<p>The hardware simulator’s two-phase clock (used only in testing sequential chips) emits a series of values denoted <img alt="" class="inline" height="12" src="../images/A3-C1.png" width="146"/> and so on. The progression of these <i>clock cycles</i> (also called <i>time units</i>) can be controlled by two script commands named <samp class="SANS_Consolas_Regular_11">tick</samp> and <samp class="SANS_Consolas_Regular_11">tock</samp>. A <samp class="SANS_Consolas_Regular_11">tick</samp> moves the clock value from <i>t</i> to <img alt="" class="inline" height="10" src="../images/A3-1.png" width="18"/>, and a <samp class="SANS_Consolas_Regular_11">tock</samp> from <img alt="" class="inline" height="10" src="../images/A3-1.png" width="18"/> to <img alt="" class="inline" height="14" src="../images/A3-2.png" width="32"/>bringing upon the next time unit. The current time unit is stored in a system variable named <samp class="SANS_Consolas_Regular_11">time</samp>, which is read-only.</p>
<p><span aria-label="303" id="pg_303" role="doc-pagebreak"/>Script commands can access three types of variables: pins, variables of built-in chips, and the system variable <samp class="SANS_Consolas_Regular_11">time</samp>.</p>
<ul class="no-bullet">
<li class="ULF"><i>Pins</i>: input, output, and internal pins of the simulated chip (for example, the command <samp class="SANS_Consolas_Regular_11">set</samp> <samp class="SANS_Consolas_Regular_11">in</samp> <samp class="SANS_Consolas_Regular_11">0</samp> sets the value of the pin whose name is <samp class="SANS_Consolas_Regular_11">in</samp> to <samp class="SANS_Consolas_Regular_11">0</samp>)</li>
<li class="UL"><i>Variables of built-in chips</i>: exposed by the chip’s external implementation (see <a href="appendix3.html#figA3-2" id="rfigA3-2">figure A3.2</a>.)</li>
</ul>
<figure class="IMG"><img alt="" id="figA3-2" src="../images/figure_A3.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA3-2">Figure A3.2</a></b>    Variables and methods of key built-in chips in Nand to Tetris.</p></figcaption>
</figure>
<ul class="no-bullet">
<li class="UL2"><samp class="SANS_Consolas_Regular_11">time</samp>: the number of time-units that elapsed since the simulation started (a read-only variable)</li>
</ul>
<p class="STNI1"><b>Script commands</b>: A script is a sequence of commands. Each command is terminated by a comma, a semicolon, or an exclamation mark. These terminators have the following semantics:</p>
<ul class="no-bullet">
<li class="ULF"><i>Comma</i> (<samp class="SANS_Consolas_Regular_11">,</samp>): Terminates a script command.</li>
<li class="UL"><i>Semicolon</i> (<samp class="SANS_Consolas_Regular_11">;</samp>): Terminates a script command and a simulation step. A <i>simulation step</i> consists of one or more script commands. When the user instructs the simulator to <i>single-step</i> using the simulator’s menu or <samp class="SANS_Consolas_Regular_11">play</samp> icon, the simulator executes the script from the current command until a semicolon is reached, at which point the simulation is paused.</li>
<li class="ULL"><i>Exclamation mark</i> (<samp class="SANS_Consolas_Regular_11">!</samp>): Terminates a script command and stops the script execution. The user can later resume the script execution from that point onward. Typically used for debugging purposes.</li>
</ul>
<p class="TNI1">Below we group the script commands in two conceptual sections: <i>setup commands</i>, used for loading files and initializing settings, and <i>simulation commands</i>, used for walking the simulator through the actual tests.</p>
<section>
<h3 class="head b-head"><b>Setup Commands</b></h3>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">load</samp> <b><i>Xxx</i></b><samp class="SANS_Consolas_Bold_B_11">.hdl</samp>: Loads the HDL program stored in <b><i>Xxx</i></b><samp class="SANS_Consolas_Regular_11">.hdl</samp> into the simulator. The file name must include the <samp class="SANS_Consolas_Regular_11">.hdl</samp> extension and must not include a path specification. The simulator will try to load the file from the current folder and, failing that, from the <samp class="SANS_Consolas_Regular_11">tools/builtInChips</samp> folder.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">output-file</samp> <b><i>Xxx</i></b><samp class="SANS_Consolas_Bold_B_11">.out</samp>: Instructs the simulator to write the results of the <samp class="SANS_Consolas_Regular_11">output</samp> commands in the named file, which must include an <samp class="SANS_Consolas_Regular_11">.out</samp> extension. The output file will be created in the current folder.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">output-list</samp> <b><i>v</i></b>1<samp class="SANS_Consolas_Regular_11">,</samp> <b><i>v</i></b>2<samp class="SANS_Consolas_Regular_11">,</samp> <span class="ellipsis">…</span>: Specifies what to write to the output file when the <samp class="SANS_Consolas_Regular_11">output</samp> command is encountered in the script (until the next <samp class="SANS_Consolas_Regular_11">output-list</samp> command, if any). Each value in the <span aria-label="304" id="pg_304" role="doc-pagebreak"/>list is a variable name followed by a formatting specification. The command also produces a single header line, consisting of the variable names, which is written to the output file. Each item <i>v</i> in the <samp class="SANS_Consolas_Regular_11">output-list</samp> has the syntax <i>varName format padL.len.padR</i> (without any spaces). This directive instructs the simulator to write <i>padL</i> space characters, then the current value of the variable <i>varName</i>, using the specified <i>format</i> and <i>len</i> columns, then <i>padR</i> spaces, and finally the divider symbol <samp class="SANS_Consolas_Regular_11">|</samp>. The <i>format</i> can be either <samp class="SANS_Consolas_Regular_11">%B</samp> (binary), <samp class="SANS_Consolas_Regular_11">%X</samp> (hexa), <samp class="SANS_Consolas_Regular_11">%D</samp> (decimal), or <samp class="SANS_Consolas_Regular_11">%S</samp> (string). The default format is <samp class="SANS_Consolas_Regular_11">%B1.1.1</samp>.</p>
<p>For example, the <samp class="SANS_Consolas_Regular_11">CPU.hdl</samp> chip of the Hack platform has an input pin named <samp class="SANS_Consolas_Regular_11">reset</samp>, an output pin named <samp class="SANS_Consolas_Regular_11">pc</samp> (among others), and a chip-part named <samp class="SANS_Consolas_Regular_11">DRegister</samp> (among others). If we want to track the values of these entities during the simulation, we can use something like the following command:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A3.3.png"/></figure>
<p class="TNI1">(State variables of built-in chips are explained below). This <samp class="SANS_Consolas_Regular_11">output-list</samp> command may end up producing the following output, after two subsequent <samp class="SANS_Consolas_Regular_11">output</samp> commands:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A3.4.png"/></figure>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">compare-to</samp> <b><i>Xxx</i></b><samp class="SANS_Consolas_Bold_B_11">.cmp</samp>: Specifies that the output line generated by each subsequent <samp class="SANS_Consolas_Regular_11">output</samp> command should be compared to its corresponding line in the specified compare file (which must include the <samp class="SANS_Consolas_Regular_11">.cmp</samp> extension). If any two lines are not the same, the simulator displays an error message and halts the script execution. The compare file is assumed to be present in the current folder.</p>
</section>
<section>
<h3 class="head b-head"><b>Simulation Commands</b></h3>
<p class="noindent"><samp class="SANS_Consolas_Bold_B_11">set</samp> <i>varName value</i>: Assigns the value to the variable. The variable is either a pin or an internal variable of the simulated chip or one of its chip-parts. The bit widths of the value and the variable must be compatible.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">eval</samp>: Instructs the simulator to apply the chip logic to the current values of the input pins and compute the resulting output values.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">output</samp>: Causes the simulator to go through the following logic:</p>
<ol class="List-1">
<li class="NLF" value="1">Get the current values of all the variables listed in the last <samp class="SANS_Consolas_Regular_11">output-list</samp> command.</li>
<li class="NL">Create an output line using the format specified in the last <samp class="SANS_Consolas_Regular_11">output-list</samp> command.</li>
<li class="NL"><span aria-label="305" id="pg_305" role="doc-pagebreak"/>Write the output line to the output file.</li>
<li class="NL">(If a compare file has been previously declared using a <samp class="SANS_Consolas_Regular_11">compare-to</samp> command): If the output line differs from the compare file’s current line, display an error message and stop the script’s execution.</li>
<li class="NLL">Advance the line cursors of the output file and the compare file.</li>
</ol>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">tick</samp>: Ends the first phase of the current time unit (clock cycle).</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">tock</samp>: Ends the second phase of the current time unit and embarks on the first phase of the next time unit.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">repeat</samp> <b><i>n</i></b> <samp class="SANS_Consolas_Bold_B_11">{</samp><b><i>commands</i></b><samp class="SANS_Consolas_Bold_B_11">}</samp>: Instructs the simulator to repeat the commands enclosed in the curly brackets <i>n</i> times. If <i>n</i> is omitted, the simulator repeats the commands until the simulation has been stopped for some reason (for example, when the user clicks the <samp class="SANS_Consolas_Regular_11">Stop</samp> icon).</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">while</samp> <b><i>booleanCondition</i></b> <samp class="SANS_Consolas_Bold_B_11">{</samp><b><i>commands</i></b><samp class="SANS_Consolas_Bold_B_11">}</samp>: Instructs the simulator to repeat the commands enclosed in the curly brackets as long as the <i>booleanCondition</i> is true. The condition is of the form <i>x op y</i> where <i>x</i> and <i>y</i> are either constants or variable names and <i>op</i> is <span class="code_eq-symb">=</span>, <span class="symb-code">&gt;</span>, <span class="symb-code">&lt;</span>, <span class="symb-code">&gt;</span><span class="code_eq-symb">=</span>, <span class="symb-code">&lt;</span><span class="code_eq-symb">=</span>, or <span class="symb-code">&lt; &gt;</span>. If <i>x</i> and <i>y</i> are strings, <i>op</i> can be either <span class="code_eq-symb">=</span> or <span class="symb-code">&lt; &gt;</span>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">echo</samp> <b><i>text</i></b>: Displays the <i>text</i> in the simulator status line. The text must be enclosed in double quotation marks.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">clear-echo</samp>: Clears the simulator’s status line.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">breakpoint</samp> <b><i>varName value</i></b>: Starts comparing the current value of the specified variable to the specified <i>value</i> following the execution of each subsequent script command. If the variable contains the specified <i>value</i>, the execution halts and a message is displayed. Otherwise, the execution continues normally. Useful for debugging purposes.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">clear-breakpoints</samp>: Clears all the previously defined breakpoints.</p>
<p class="STNI1"><b><i>builtInChipName method argument</i></b> (s): Executes the specified method of the specified built-in chip-part using the supplied arguments. The designer of a built-in chip can provide methods that allow the user (or a test script) to manipulate the simulated chip. See <a href="appendix3.html#figA3-2">figure A3.2</a>.</p>
<p class="STNI1"><b>Variables of built-in chips</b>: Chips can be implemented either by HDL programs or by externally supplied executable modules. In the latter case, the chip is said to be <i>built-in</i>. built-in chips can facilitate access to the chip’s state using the syntax <i>chipName</i><samp class="SANS_Consolas_Regular_11">[</samp><i>varName</i><samp class="SANS_Consolas_Regular_11">]</samp>, where <i>varName</i> is an implementation-specific variable that should be documented in the chip API. See <a href="appendix3.html#figA3-2">figure A3.2</a>.</p>
<p><span aria-label="306" id="pg_306" role="doc-pagebreak"/>For example, consider the script command <samp class="SANS_Consolas_Regular_11">set</samp> <samp class="SANS_Consolas_Regular_11-SC">RAM16K[1017]</samp> <samp class="SANS_Consolas_Regular_11">15</samp>. If <samp class="SANS_Consolas_Regular_11-SC">RAM16K</samp> is the currently simulated chip, or a chip-part of the currently simulated chip, this command sets its memory location number <samp class="SANS_Consolas_Regular_11">1017</samp> to <samp class="SANS_Consolas_Regular_11">15</samp>. And, since the built-in <samp class="SANS_Consolas_Regular_11-SC">RAM16K</samp> chip happens to have GUI side effects, the new value will also be reflected in the chip’s visual image.</p>
<p>If a built-in chip maintains a single-valued internal state, the current value of the state can be accessed through the notation <i>chipName</i><samp class="SANS_Consolas_Regular_11">[].</samp> If the internal state is a vector, the notation <i>chipName</i><samp class="SANS_Consolas_Regular_11">[</samp><i>i</i><samp class="SANS_Consolas_Regular_11">]</samp> is used. For example, when simulating the built-in <samp class="SANS_Consolas_Regular_11">Register</samp> chip, one can write script commands like <samp class="SANS_Consolas_Regular_11">set</samp> <samp class="SANS_Consolas_Regular_11">Register[]</samp> <samp class="SANS_Consolas_Regular_11">135</samp>. This command sets the internal state of the chip to <samp class="SANS_Consolas_Regular_11">135</samp>; in the next time unit, the <samp class="SANS_Consolas_Regular_11">Register</samp> chip will commit to this value, and its output pin will start emitting it.</p>
<p class="STNI1"><b>Methods of built-in chips</b>: Built-in chips can also expose <i>methods</i> that can be used by scripting commands. For example, in the Hack computer, programs reside in an instruction memory unit implemented by the built-in chip <samp class="SANS_Consolas_Regular_11">ROM32K</samp>. Before running a machine language program on the Hack computer, the program must be loaded into this chip. To facilitate this service, the built-in implementation of <samp class="SANS_Consolas_Regular_11">ROM32K</samp> features a <samp class="SANS_Consolas_Regular_11">load</samp> method that enables loading a text file containing machine language instructions. This method can be accessed using a script command like <samp class="SANS_Consolas_Regular_11">ROM32K</samp> <samp class="SANS_Consolas_Regular_11">load</samp> <i>fileName</i><samp class="SANS_Consolas_Regular_11">.hack</samp>.</p>
<p class="STNI1"><b>Ending example</b>: We end this section with a relatively complex test script designed to test the topmost <samp class="SANS_Consolas_Regular_11">Computer</samp> chip of the Hack computer.</p>
<p><span aria-label="307" id="pg_307" role="doc-pagebreak"/>One way to test the <samp class="SANS_Consolas_Regular_11">Computer</samp> chip is to load a machine language program into it and monitor selected values as the computer executes the program, one instruction at a time. For example, we wrote a machine language program that computes the maximum of <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp> and writes the result in <samp class="SANS_Consolas_Regular_11-SC">RAM[2]</samp>. The program is stored in a file named <samp class="SANS_Consolas_Regular_11">Max.hack</samp>.</p>
<p>Note that at the low level in which we are operating, if such a program does not run properly it may be either because the program is buggy or because the hardware is buggy (or, perhaps, the test script is buggy, or the hardware simulator is buggy). For simplicity, let us assume that everything is error-free, except for, possibly, the simulated <samp class="SANS_Consolas_Regular_11">Computer</samp> chip.</p>
<p>To test the <samp class="SANS_Consolas_Regular_11">Computer</samp> chip using the <samp class="SANS_Consolas_Regular_11">Max.hack</samp> program, we wrote a test script called <samp class="SANS_Consolas_Regular_11">ComputerMax.tst</samp>. This script loads <samp class="SANS_Consolas_Regular_11">Computer.hdl</samp> into the hardware simulator and then loads the <samp class="SANS_Consolas_Regular_11">Max.hack</samp> program into its <samp class="SANS_Consolas_Regular_11">ROM32K</samp> chip-part. A reasonable way to check whether the chip works properly is as follows: Put some values in <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp>, reset the computer, run the clock enough cycles, and inspect <samp class="SANS_Consolas_Regular_11-SC">RAM[2]</samp>. This, in a nutshell, is what the script in <a href="appendix3.html#figA3-3" id="rfigA3-3">figure A3.3</a> is designed to do.</p>
<figure class="IMG"><img alt="" id="figA3-3" src="../images/figure_A3.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA3-3">Figure A3.3</a></b>    Testing the topmost <samp class="SANS_Consolas_Regular_11">Computer</samp> chip.</p></figcaption>
</figure>
<p>How can we tell that fourteen clock cycles are sufficient for executing this program? This can be found by trial and error, by starting with a large value and watching the computer’s outputs stabilizing after a while, or by analyzing the run-time behavior of the loaded program.</p>
<p class="STNI1"><span aria-label="308" id="pg_308" role="doc-pagebreak"/><b>Default test script</b>: Each Nand to Tetris simulator features a default test script. If the user does not load a test script into the simulator, the default test script is used. The default test script of the hardware simulator is defined as follows:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A3.5.png"/></figure>
</section>
</section>
<section>
<h2 class="head a-head"><b>A3.3    Testing Machine Language Programs on the CPU Emulator</b></h2>
<p class="noindent">Unlike the <i>hardware simulator</i>, which is a general-purpose program designed to support the construction of any hardware platform, the supplied <i>CPU emulator</i> is a single-purpose tool, designed to simulate the execution of machine language programs on a specific platform: the Hack computer. The programs can be written either in the symbolic or in the binary Hack machine language described in chapter 4.</p>
<p>As usual, the simulation involves four files: the tested program (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.asm</samp> or <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.hack</samp>), a test script (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.tst</samp>), an optional output file (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.out</samp>), and an optional compare file (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.cmp</samp>). All these files reside in the same folder, normally named <i>Xxx</i>.</p>
<p class="STNI1"><b>Example</b>: Consider the multiplication program <samp class="SANS_Consolas_Regular_11">Mult.hack</samp>, designed to effect <img alt="" class="inline" height="14" src="../images/A3-C2.png" width="173"/>. Suppose we want to test this program in the CPU emulator. A reasonable way to do it is to put some values in <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp>, run the program, and inspect <samp class="SANS_Consolas_Regular_11-SC">RAM[2]</samp>. This logic is carried out by the test script shown in <a href="appendix3.html#figA3-4" id="rfigA3-4">figure A3.4</a>.</p>
<figure class="IMG"><img alt="" height="550" id="figA3-4" src="../images/figure_A3.4.png"/>
<figcaption><p class="CAP"><b><a href="#rfigA3-4">Figure A3.4</a></b>    Testing a machine language program on the CPU emulator.</p></figcaption>
</figure>
<p class="STNI1"><b>Variables</b>: Scripting commands running on the CPU emulator can access the following elements of the Hack computer:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/2.png"/></figure>
<p class="STNI1"><b>Commands</b>: The CPU emulator supports all the commands described in section A3.2, except for the following changes:</p>
<ul class="no-bullet">
<li class="ULF"><span aria-label="309" id="pg_309" role="doc-pagebreak"/><samp class="SANS_Consolas_Regular_11">load</samp> <i>progName</i>: Where <i>progName</i> is either <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.asm</samp> or <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.hack</samp>. This command loads a machine language program (to be tested) into the simulated instruction memory. If the program is written in assembly, the simulator translates it into binary, on the fly, as part of executing the <samp class="SANS_Consolas_Regular_11">load</samp> <i>programName</i> command.</li>
<li class="UL"><samp class="SANS_Consolas_Regular_11">eval</samp>: Not applicable in the CPU emulator.</li>
<li class="UL"><i>builtInChipName method argument</i> (<i>s</i>): Not applicable in the CPU emulator.</li>
<li class="UL"><samp class="SANS_Consolas_Regular_11">tickTock</samp>: This command is used instead of <samp class="SANS_Consolas_Regular_11">tick</samp> and <samp class="SANS_Consolas_Regular_11">tock</samp>. Each <samp class="SANS_Consolas_Regular_11">ticktock</samp> advances the clock one time unit (cycle).</li>
</ul>
<section>
<h3 class="head b-head"><b>Default Test Script</b></h3>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A3.6.png"/></figure>
</section>
</section>
<section>
<h2 class="head a-head"><span aria-label="310" id="pg_310" role="doc-pagebreak"/><b>A3.4    Testing VM Programs on the VM Emulator</b></h2>
<p class="noindent">The supplied <i>VM emulator</i> is a Java implementation of the virtual machine specified in chapters 7–8. It can be used for simulating the execution of VM programs, visualizing their operations, and displaying the states of the effected virtual memory segments.</p>
<p>A VM program consists of one or more <samp class="SANS_Consolas_Regular_11">.vm</samp> files. Thus, the simulation of a VM program involves the tested program (a single <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp> file or an <i>Xxx</i> folder containing one or more <samp class="SANS_Consolas_Regular_11">.vm</samp> files) and, optionally, a test script (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.tst</samp>), a compare file (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.cmp</samp>), and an output file (<i>Xxx</i><samp class="SANS_Consolas_Regular_11">.out</samp>). All these files reside in the same folder, normally named <i>Xxx</i>.</p>
<p class="STNI1"><b>Virtual memory segments</b>: The VM commands <samp class="SANS_Consolas_Regular_11">push</samp> and <samp class="SANS_Consolas_Regular_11">pop</samp> are designed to manipulate <i>virtual memory segments</i> (<samp class="SANS_Consolas_Regular_11">argument</samp>, <samp class="SANS_Consolas_Regular_11">local</samp>, and so on). These segments must be allocated to the host RAM—a task that the VM emulator carries out as a side effect of simulating the execution of the VM commands <samp class="SANS_Consolas_Regular_11">call</samp>, <samp class="SANS_Consolas_Regular_11">function</samp>, and <samp class="SANS_Consolas_Regular_11">return</samp>.</p>
<p class="STNI1"><b>Startup code</b>: When the VM translator translates a VM program, it generates machine language code that sets the stack pointer to 256 and then calls the <samp class="SANS_Consolas_Regular_11">Sys.init</samp> function, which then initializes the OS classes and calls <samp class="SANS_Consolas_Regular_11">Main.main</samp>. In a similar fashion, when the VM emulator is instructed to execute a VM program (a collection of one or more VM functions), it is programmed to start running the function <samp class="SANS_Consolas_Regular_11">Sys.init</samp>. If such a function is not found in the loaded VM code, the emulator is programmed to start executing the first command in the loaded VM code.</p>
<p>The latter convention was added to the VM emulator to support unit testing of the VM translator, which spans two book chapters and projects. In project 7, we build a basic VM translator that handles only <samp class="SANS_Consolas_Regular_11">push</samp>, <samp class="SANS_Consolas_Regular_11">pop</samp>, and arithmetic commands without handling function calling commands. If we want to execute such programs, we must somehow anchor the virtual memory segments in the host RAM—at least those segments mentioned in the simulated VM code. Conveniently, this initialization can be accomplished by script commands that manipulate the pointers controlling the base RAM addresses of the virtual segments. Using these script commands, we can anchor the virtual segments anywhere we want in the host RAM.</p>
<p class="STNI1"><b>Example</b>: The <samp class="SANS_Consolas_Regular_11">FibonacciSeries.vm</samp> file contains a sequence of VM commands that compute the first <i>n</i> elements of the Fibonacci series. The code is designed to operate on two arguments: <i>n</i> and the starting memory address in which the computed elements should be stored. The test script listed in <a href="appendix3.html#figA3-5" id="rfigA3-5">figure A3.5</a> tests this program using the arguments 6 and 4000.</p>
<figure class="IMG"><img alt="" id="figA3-5" src="../images/figure_A3.5.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfigA3-5">Figure A3.5</a></b>    Testing a VM program on the VM emulator.</p></figcaption>
</figure>
<p class="STNI1"><span aria-label="311" id="pg_311" role="doc-pagebreak"/><b>Variables</b>: Scripting commands running on the VM emulator can access the following elements of the virtual machine:</p>
<p class="STNI1"><u>Contents of VM segments:</u></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/3.png"/></figure>
<p class="STNI1"><u>Pointers of VM segments:</u></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/4.png"/></figure>
<p class="STNI1"><span aria-label="312" id="pg_312" role="doc-pagebreak"/><u>Implementation-specific variables:</u></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/5.png"/></figure>
<p class="STNI1"><b>Commands</b>: The VM emulator supports all the commands described in Section A3.2, except for the following changes:</p>
<p class="STNI1"><samp class="SANS_Consolas_Regular_11">load</samp> <i>source</i>: Where the optional <i>source</i> parameter is either <i>Xxx</i><samp class="SANS_Consolas_Regular_11">.vm</samp>, a file containing VM code, or <i>Xxx</i>, the name of a folder containing one or more <samp class="SANS_Consolas_Regular_11">.vm</samp> files (in which case all of them are loaded, one after the other). If the <samp class="SANS_Consolas_Regular_11">.vm</samp> files are located in the current folder, the source argument can be omitted.</p>
<p class="STNI1"><samp class="SANS_Consolas_Regular_11">tick</samp> / <samp class="SANS_Consolas_Regular_11">tock</samp>: Not applicable.</p>
<p class="STNI1"><samp class="SANS_Consolas_Regular_11">vmstep</samp>: Simulates the execution of a single VM command and advances to the next command in the code.</p>
<section>
<h3 class="head b-head"><b>Default Script</b></h3>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_A3.7.png"/></figure>
</section>
</section>
</section>
</div>
</body>
</html>