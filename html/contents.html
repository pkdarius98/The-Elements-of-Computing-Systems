<html lang="en">
<head>
<title>Table of Contents</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="cont"role="doc-toc">
<header>
<h1 class="FMH" id="cont"><span aria-label="vii" id="pg_vii" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">Contents</samp></h1>
</header>
<ol class="toc">
<li class="CFMH"><a href="preface.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">Preface</samp></a></li>
<li class="CPTF"><a href="part_1.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">I      HARDWARE</samp></a></li>
<li class="CCTF"><a href="chapter_1.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">1      Boolean Logic</samp></a></li>
<li class="CCT"><a href="chapter_2.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">2      Boolean Arithmetic</samp></a></li>
<li class="CCT"><a href="chapter_3.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">3      Memory</samp></a></li>
<li class="CCT"><a href="chapter_4.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">4      Machine Language</samp></a></li>
<li class="CCT"><a href="chapter_5.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">5      Computer Architecture</samp></a></li>
<li class="CCT"><a href="chapter_6.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">6      Assembler</samp></a></li>
<li class="CPT"><a href="part_2.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">II      SOFTWARE</samp></a></li>
<li class="CCTF"><a href="chapter_7.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">7      Virtual Machine I: Processing</samp></a></li>
<li class="CCT"><a href="chapter_8.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">8      Virtual Machine II: Control</samp></a></li>
<li class="CCT"><a href="chapter_9.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">9      High-Level Language</samp></a></li>
<li class="CCT"><a href="chapter_10.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">10    Compiler I: Syntax Analysis</samp></a></li>
<li class="CCT"><a href="chapter_11.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">11    Compiler II: Code Generation</samp></a></li>
<li class="CCT"><a href="chapter_12.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">12    Operating System</samp></a></li>
<li class="CCT"><a href="chapter_13.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">13    More Fun to Go</samp></a></li>
<li class="CBMHF"><span aria-label="viii" id="pg_viii" role="doc-pagebreak"/><a href="appendix1.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">Appendices</samp></a></li>
<li class="CBMH"><a href="appendix1.html#app"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">1      Boolean Function Synthesis</samp></a></li>
<li class="CBMH"><a href="appendix2.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">2      Hardware Description Language</samp></a></li>
<li class="CBMH"><a href="appendix3.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">3      Test Description Language</samp></a></li>
<li class="CBMH"><a href="appendix4.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">4      The Hack Chip Set</samp></a></li>
<li class="CBMH"><a href="appendix5.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">5      The Hack Character Set</samp></a></li>
<li class="CBMH"><a href="appendix6.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">6      The Jack OS API</samp></a></li>
<li class="CBMHL"><a href="index.html"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">Index</samp></a></li>
</ol>
<section>
<h2 class="FMH1"><samp class="SANS_Helvetica_LT_Std_Bold_B_11">List of Figures</samp></h2>
<p class="toc-bm"><b><a href="part_1.html#figI-1">Figure I.1</a></b><br/>Major modules of a typical computer system, consisting of a hardware platform and a software hierarchy. Each module has an <i>abstract view</i> (also called the module’s <i>interface</i>) and an <i>implementation</i>. The right-pointing arrows signify that each module is implemented using abstract building blocks from the level below. Each circle represents a Nand to Tetris project and chapter—twelve projects and chapters altogether.</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-1">Figure 1.1</a></b><br/>Three elementary Boolean functions.</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-2">Figure 1.2</a></b><br/>All the Boolean functions of two binary variables. In general, the number of Boolean functions spanned by <i>n</i> binary variables (here <i><img alt="" class="inline" height="10" src="../images/1-6.png" width="30"/></i>) is <img alt="" class="inline" height="12" src="../images/Ch01_IEQ_001.png" width="16"/> (that’s a lot of Boolean functions).</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-3">Figure 1.3</a></b><br/>Truth table and functional definitions of a Boolean function (example).</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-5">Figure 1.5</a></b><br/>Composite implementation of a three-way And gate. The rectangular dashed outline defines the boundary of the gate interface.</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-6">Figure 1.6</a></b><br/>Xor gate interface (left) and a possible implementation (right).</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-7">Figure 1.7</a></b><br/>Gate diagram and HDL implementation of the Boolean function Xor <img alt="" class="inline" height="13" src="../images/1-13.png" width="62"/> (And (<i>a</i>, Not (<i>b</i>)), And (Not (<i>a</i>), <i>b</i>)), used as an example. A test script and an output file generated by the test are also shown. Detailed descriptions of HDL and the testing language are given in appendices 2 and 3, respectively.</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-8">Figure 1.8</a></b><br/>A screenshot of simulating an <samp class="SANS_Consolas_Regular_11">Xor</samp> chip in the supplied hardware simulator (other versions of this simulator may have a slightly different GUI). The simulator state is shown just after the test script has completed running. The pin values correspond to the last simulation step <img alt="" class="inline" height="13" src="../images/1-C2.png" width="59"/> Not shown in this screenshot is a <i>compare file</i> that lists the expected output of the simulation specified by this particular test script. Like the test script, the compare file is typically supplied by the client who wants the chip built. In this particular example, the output file generated by the simulation (bottom right of the figure) is identical to the supplied compare file.</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-9">Figure 1.9</a></b><br/>Multiplexer. The table at the top right is an abbreviated version of the truth table.</p>
<p class="toc-bm"><b><a href="chapter_1.html#fig1-10">Figure 1.10</a></b><br/>Demultiplexer.</p>
<p class="toc-bm"><b><a href="chapter_2.html#fig2-1">Figure 2.1</a></b><br/>Two’s complement representation of signed numbers, in a 4-bit binary system.</p>
<p class="toc-bm"><b><a href="chapter_2.html#fig2-2">Figure 2.2</a></b><br/>Half-adder, designed to add 2 bits.</p>
<p class="toc-bm"><b><a href="chapter_2.html#fig2-3">Figure 2.3</a></b><br/>Full-adder, designed to add 3 bits.</p>
<p class="toc-bm"><b><a href="chapter_2.html#fig2-4">Figure 2.4</a></b><br/>16-bit adder, designed to add two 16-bit numbers, with an example of addition action (on the left).</p>
<p class="toc-bm"><b><a href="chapter_2.html#fig2-5a">Figure 2.5a</a></b><br/>The Hack ALU, designed to compute the eighteen arithmetic-logical functions shown on the right (the symbols <samp class="SANS_Consolas_Regular_11">!</samp>, <samp class="SANS_Consolas_Regular_11">&amp;</samp>, and <samp class="SANS_Consolas_Regular_11">|</samp> represent, respectively, the 16-bit operations <samp class="SANS_Consolas_Regular_11">Not</samp>, <samp class="SANS_Consolas_Regular_11">And</samp>, and <samp class="SANS_Consolas_Regular_11">Or</samp>). For now, ignore the <samp class="SANS_Consolas_Regular_11">zr</samp> and <samp class="SANS_Consolas_Regular_11">ng</samp> output bits.</p>
<p class="toc-bm"><b><a href="chapter_2.html#fig2-5b">Figure 2.5b</a></b><br/>Taken together, the values of the six control bits <samp class="SANS_Consolas_Regular_11">zx</samp>, <samp class="SANS_Consolas_Regular_11">nx</samp>, <samp class="SANS_Consolas_Regular_11">zy</samp>, <samp class="SANS_Consolas_Regular_11">ny</samp>, <samp class="SANS_Consolas_Regular_11">f</samp>, and <samp class="SANS_Consolas_Regular_11">no</samp> cause the ALU to compute one of the functions listed in the rightmost column.</p>
<p class="toc-bm"><b><a href="chapter_2.html#fig2-5c">Figure 2.5c</a></b><br/>The Hack ALU API.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-1">Figure 3.1</a></b><br/>The memory hierarchy built in this chapter.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-2">Figure 3.2</a></b><br/>Discrete time representation: State changes (input and output values) are observed only during cycle transitions. Within cycles, changes are ignored.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-3">Figure 3.3</a></b><br/>The data flip-flop (top) and behavioral example (bottom). In the first cycle the previous input is unknown, so the DFF’s output is undefined. In every subsequent time unit, the DFF outputs the input from the previous time unit. Following gate diagramming conventions, the clock input is marked by a small triangle, drawn at the bottom of the gate icon.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-4">Figure 3.4</a></b><br/>Sequential logic design typically involves DFF gates that feed from, and connect to, combinational chips. This gives sequential chips the ability to respond to current as well as to previous inputs and outputs.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-5">Figure 3.5</a></b><br/>1-bit register. Stores and emits a 1-bit value until instructed to load a new value.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-6">Figure 3.6</a></b><br/>16-bit Register. Stores and emits a 16-bit value until instructed to load a new value.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-7">Figure 3.7</a></b><br/>A RAM chip, consisting of <i>n</i> 16-bit <samp class="SANS_Consolas_Regular_11">Register</samp> chips that can be selected and manipulated separately. The register addresses <img alt="" class="inline" height="13" src="../images/3-11.png" width="63"/> are not part of the chip hardware. Rather, they are realized by a gate logic implementation that will be discussed in the next section.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-8">Figure 3.8</a></b><br/>Program Counter (<samp class="SANS_Consolas_Regular_11">PC</samp>): To use it properly, at most one of the <samp class="SANS_Consolas_Regular_11">load</samp>, <samp class="SANS_Consolas_Regular_11">inc</samp>, or <samp class="SANS_Consolas_Regular_11">reset</samp> bits should be asserted.</p>
<p class="toc-bm"><b><a href="chapter_3.html#fig3-9">Figure 3.9</a></b><br/>The <samp class="SANS_Consolas_Regular_11">Bit</samp> (1-bit register) implementation: invalid (left) and correct (right) solutions.</p>
<p class="toc-bm"><b><a href="chapter_4.html#fig4-2">Figure 4.2</a></b><br/>Conceptual model of the Hack memory system. Although the actual architecture is wired somewhat differently (as described in chapter 5), this model helps understand the semantics of Hack programs.</p>
<p class="toc-bm"><b><a href="chapter_4.html#fig4-3">Figure 4.3</a></b><br/>Hack assembly code examples.</p>
<p class="toc-bm"><b><a href="chapter_4.html#fig4-4">Figure 4.4</a></b><br/>A Hack assembly program (example). Note that <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp> can be referred to as <samp class="SANS_Consolas_Regular_11">R0</samp> and <samp class="SANS_Consolas_Regular_11">R1.</samp></p>
<p class="toc-bm"><b><a href="chapter_4.html#fig4-5">Figure 4.5</a></b><br/>The Hack instruction set, showing symbolic mnemonics and their corresponding binary codes.</p>
<p class="toc-bm"><b><a href="chapter_4.html#fig4-6">Figure 4.6</a></b><br/>A Hack assembly program that computes a simple arithmetic expression.</p>
<p class="toc-bm"><b><a href="chapter_4.html#fig4-7">Figure 4.7</a></b><br/>Array processing example, using pointer-based access to array elements.</p>
<p class="toc-bm"><b><a href="chapter_4.html#fig4-8">Figure 4.8</a></b><br/>The CPU emulator, with a program loaded in the instruction memory (ROM) and some data in the data memory (RAM). The figure shows a snapshot taken during the program’s execution.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-1">Figure 5.1</a></b><br/>A generic von Neumann computer architecture.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-2">Figure 5.2</a></b><br/>The Hack Central Processing Unit (CPU) interface.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-3">Figure 5.3</a></b><br/>The Hack instruction memory interface.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-4">Figure 5.4</a></b><br/>The Hack <samp class="SANS_Consolas_Regular_11">Screen</samp> chip interface.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-5">Figure 5.5</a></b><br/>The Hack <samp class="SANS_Consolas_Regular_11">Keyboard</samp> chip interface.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-6">Figure 5.6</a></b><br/>The Hack data memory interface. Note that the decimal values 16384 and 24576 are 4000 and 6000 in hexadecimal.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-7">Figure 5.7</a></b><br/>Interface of <samp class="SANS_Consolas_Regular_11">Computer</samp>, the topmost chip in the Hack hardware platform.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-8">Figure 5.8</a></b><br/>Proposed implementation of the Hack CPU, showing an incoming 16-bit instruction. We use the instruction notation <i>cccccccccccccccc</i> to emphasize that in the case of a <i>C</i>-instruction, the instruction is treated as a capsule of control bits, designed to control different CPU chip-parts. In this diagram, every <i>c</i> symbol entering a chip-part stands for some control bit extracted from the instruction (in the case of the ALU, the <i>c</i>’s input stands for the six control bits that instruct the ALU what to compute). Taken together, the distributed behavior induced by these control bits ends up executing the instruction. We don’t specify which bits go where, since we want readers to answer these questions themselves.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-9">Figure 5.9</a></b><br/>Proposed implementation of <samp class="SANS_Consolas_Regular_11">Computer</samp>, the topmost chip in the Hack platform.</p>
<p class="toc-bm"><b><a href="chapter_5.html#fig5-10">Figure 5.10</a></b><br/>Testing the <samp class="SANS_Consolas_Regular_11">Computer</samp> chip on the supplied hardware simulator. The stored program is <samp class="SANS_Consolas_Regular_11">Rect</samp>, which draws a rectangle of <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> rows of 16 pixels each, all black, at the top-left of the screen.</p>
<p class="toc-bm"><b><a href="chapter_6.html#fig6-1">Figure 6.1</a></b><br/>Assembly code, translated to binary code using a symbol table. The line numbers, which are not part of the code, are listed for reference.</p>
<p class="toc-bm"><b><a href="chapter_6.html#fig6-2">Figure 6.2</a></b><br/>The Hack instruction set, showing both symbolic mnemonics and their corresponding binary codes.</p>
<p class="toc-bm"><b><a href="chapter_6.html#fig6-3">Figure 6.3</a></b><br/>Testing the assembler’s output using the supplied assembler.</p>
<p class="toc-bm"><b><a href="part_2.html#figII-1">Figure II.1</a></b><br/>Manipulating points on a plane: example and Jack code.</p>
<p class="toc-bm"><b><a href="part_2.html#figII-2">Figure II.2</a></b><br/>Jack implementation of the <samp class="SANS_Consolas_Regular_11">Point</samp> abstraction.</p>
<p class="toc-bm"><b><a href="part_2.html#figII-3">Figure II.3</a></b><br/>Road map of part II (the assembler belongs to part I and is shown here for completeness). The road map describes a translation hierarchy, from a high-level, object-based, multi-class program to VM code, to assembly code, to executable binary code. The numbered circles stand for the projects that implement the compiler, the VM translator, the assembler, and the operating system. Project 9 focuses on writing a Jack application in order to get acquainted with the language.</p>
<p class="toc-bm"><b><a href="chapter_7.html#fig7-1">Figure 7.1</a></b><br/>The virtual machine framework, using Java as an example. High-level programs are compiled into intermediate VM code. The same VM code can be shipped to, and executed on, any hardware platform equipped with a suitable <i>JVM implementation</i>. These VM implementations are typically realized as client-side programs that translate the VM code into the machine languages of the target devices.</p>
<p class="toc-bm"><b><a href="chapter_7.html#fig7-2">Figure 7.2</a></b><br/>Stack processing example, illustrating the two elementary operations <samp class="SANS_Consolas_Regular_11">push</samp> and <samp class="SANS_Consolas_Regular_11">pop</samp>. The setting consists of two data structures: a RAM-like memory segment and a stack. Following convention, the stack is drawn as if it grows downward. The location just following the stack’s top value is referred to by a pointer called <i>sp</i>, or <i>stack pointer</i>. The <i>x</i> and <i>y</i> symbols refer to two arbitrary memory locations.</p>
<p class="toc-bm"><b><a href="chapter_7.html#fig7-3a">Figure 7.3a</a></b><br/>Stack-based evaluation of arithmetic expressions.</p>
<p class="toc-bm"><b><a href="chapter_7.html#fig7-3b">Figure 7.3b</a></b><br/>Stack-based evaluation of logical expressions.</p>
<p class="toc-bm"><b><a href="chapter_7.html#fig7-4">Figure 7.4</a></b><br/>Virtual memory segments.</p>
<p class="toc-bm"><b><a href="chapter_7.html#fig7-5">Figure 7.5</a></b><br/>The arithmetic-logical commands of the VM language.</p>
<p class="toc-bm"><b><a href="chapter_7.html#fig7-6">Figure 7.6</a></b><br/>The VM emulator supplied with the Nand to Tetris software suite.</p>
<p class="toc-bm"><b><a href="chapter_8.html#fig8-1">Figure 8.1</a></b><br/>Branching commands action. (The VM code on the right uses symbolic variable names instead of virtual memory segments, to make it more readable.)</p>
<p class="toc-bm"><b><a href="chapter_8.html#fig8-2">Figure 8.2</a></b><br/>Run-time snapshots of selected stack and segment states during the execution of a three-function program. The line numbers are not part of the code and are given for reference only.</p>
<p class="toc-bm"><b><a href="chapter_8.html#fig8-3">Figure 8.3</a></b><br/>The global stack, shown when the callee is running. Before the callee terminates, it pushes a return value onto the stack (not shown). When the VM implementation handles the <samp class="SANS_Consolas_Regular_11">return</samp> command, it copies the return value onto <samp class="SANS_Consolas_Regular_11">argument</samp> <samp class="SANS_Consolas_Regular_11">0</samp>, and sets <samp class="SANS_Consolas_Regular_11">SP</samp> to point to the address just following it. This effectively frees the global stack area below the new value of <samp class="SANS_Consolas_Regular_11">SP</samp>. Thus, when the caller resumes its execution, it sees the return value at the top of its working stack.</p>
<p class="toc-bm"><b><a href="chapter_8.html#fig8-4">Figure 8.4</a></b><br/>Several snapshots of the <i>global stack</i>, taken during the execution of the <samp class="SANS_Consolas_Regular_11">main</samp> function, which calls <samp class="SANS_Consolas_Regular_11">factorial</samp> to compute 3!. The running function sees only its working stack, which is the unshaded area at the tip of the global stack; the other unshaded areas in the global stack are the working stacks of functions up the calling chain, waiting for the currently running function to return. Note that the shaded areas are not “drawn to scale,” since each frame consists of five words, as shown in <a href="chapter_8.html#fig8-3">figure 8.3</a>.</p>
<p class="toc-bm"><b><a href="chapter_8.html#fig8-5">Figure 8.5</a></b><br/>Implementation of the function commands of the VM language. All the actions described on the right are realized by generated Hack assembly instructions.</p>
<p class="toc-bm"><b><a href="chapter_8.html#fig8-6">Figure 8.6</a></b><br/>The naming conventions described above are designed to support the translation of multiple <samp class="SANS_Consolas_Regular_11">.vm</samp> files and functions into a single <samp class="SANS_Consolas_Regular_11">.asm</samp> file, ensuring that the generated assembly symbols will be unique within the file.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-1">Figure 9.1</a></b><br/><i>Hello World</i>, written in the Jack language.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-2">Figure 9.2</a></b><br/>Typical procedural programming and simple array handling. Uses the services of the OS classes <samp class="SANS_Consolas_Regular_11">Array</samp>, <samp class="SANS_Consolas_Regular_11">Keyboard</samp>, and <samp class="SANS_Consolas_Regular_11">Output</samp>.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-3a">Figure 9.3a</a></b><br/><samp class="SANS_Consolas_Regular_11">Fraction</samp> API (top) and sample Jack class that uses it for creating and manipulating <samp class="SANS_Consolas_Regular_11">Fraction</samp> objects.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-3b">Figure 9.3b</a></b><br/>A Jack implementation of the <samp class="SANS_Consolas_Regular_11">Fraction</samp> abstraction.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-4">Figure 9.4</a></b><br/>Linked list implementation in Jack (left and top right) and sample usage (bottom right).</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-5">Figure 9.5</a></b><br/>Operating system services (summary). The complete OS API is given in appendix 6.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-6">Figure 9.6</a></b><br/>The syntax elements of the Jack language.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-7">Figure 9.7</a></b><br/>Variable kinds in the Jack language. Throughout the table, <i>subroutine</i> refers to either a <i>function</i>, a <i>method</i>, or a <i>constructor</i>.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-8">Figure 9.8</a></b><br/>Statements in the Jack language.</p>
<p class="toc-bm"><b><a href="chapter_9.html#fig9-9">Figure 9.9</a></b><br/>Screenshots of Jack applications running on the Hack computer.</p>
<p class="toc-bm"><b><a href="chapter_10.html#fig10-1">Figure 10.1</a></b><br/>Staged development plan of the Jack compiler.</p>
<p class="toc-bm"><b><a href="chapter_10.html#fig10-2">Figure 10.2</a></b><br/>Definition of the Jack lexicon, and lexical analysis of a sample input.</p>
<p class="toc-bm"><b><a href="chapter_10.html#fig10-3">Figure 10.3</a></b><br/>A subset of the Jack language grammar, and Jack code segments that are either accepted or rejected by the grammar.</p>
<p class="toc-bm"><b><a href="chapter_10.html#fig10-4a">Figure 10.4a</a></b><br/>Parse tree of a typical code segment. The parsing process is driven by the grammar rules.</p>
<p class="toc-bm"><b><a href="chapter_10.html#fig10-4b">Figure 10.4b</a></b><br/>Same parse tree, in XML.</p>
<p class="toc-bm"><b><a href="chapter_10.html#fig10-5">Figure 10.5</a></b><br/>The Jack grammar.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-1">Figure 11.1</a></b><br/>The <samp class="SANS_Consolas_Regular_11">Point</samp> class. This class features all the possible variable kinds (<samp class="SANS_Consolas_Regular_11">field</samp>, <samp class="SANS_Consolas_Regular_11">static</samp>, <samp class="SANS_Consolas_Regular_11">local</samp>, and <samp class="SANS_Consolas_Regular_11">argument</samp>) and subroutine kinds (<samp class="SANS_Consolas_Regular_11">constructor</samp>, <samp class="SANS_Consolas_Regular_11">method</samp>, and <samp class="SANS_Consolas_Regular_11">function</samp>), as well as subroutines that return primitive types, object types, and void subroutines. It also illustrates function calls, constructor calls, and method calls on the current object (<samp class="SANS_Consolas_Regular_11">this</samp>) and on other objects.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-2">Figure 11.2</a></b><br/>Symbol table examples. The <samp class="SANS_Consolas_Regular_11">this</samp> row in the subroutine-level table is discussed later in the chapter.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-3">Figure 11.3</a></b><br/>Infix and postfix renditions of the same semantics.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-4">Figure 11.4</a></b><br/>A VM code generation algorithm for expressions, and a compilation example. The algorithm assumes that the input expression is valid. The final implementation of this algorithm should replace the emitted symbolic variables with their corresponding symbol table mappings.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-5">Figure 11.5</a></b><br/>Expressions in the Jack language.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-6">Figure 11.6</a></b><br/>Compiling <samp class="SANS_Consolas_Regular_11">if</samp> and <samp class="SANS_Consolas_Regular_11">while</samp> statements. The <samp class="SANS_Consolas_Regular_11">L1</samp> and <samp class="SANS_Consolas_Regular_11">L2</samp> labels are generated by the compiler.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-7">Figure 11.7</a></b><br/>Object construction from the caller’s perspective. In this example, the caller declares two object variables and then calls a class constructor for constructing the two objects. The constructor works its magic, allocating memory blocks for representing the two objects. The calling code then makes the two object variables refer to these memory blocks.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-8">Figure 11.8</a></b><br/>Object construction: the constructor’s perspective.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-9">Figure 11.9</a></b><br/>Compiling method calls: the caller’s perspective.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-10">Figure 11.10</a></b><br/>Compiling methods: the callee’s perspective.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-11">Figure 11.11</a></b><br/>Array access using VM commands.</p>
<p class="toc-bm"><b><a href="chapter_11.html#fig11-12">Figure 11.12</a></b><br/>Basic compilation strategy for arrays, and an example of the bugs that it can generate. In this particular case, the value stored in <samp class="SANS_Consolas_Regular_11">pointer</samp> <samp class="SANS_Consolas_Regular_11">1</samp> is overridden, and the address of <samp class="SANS_Consolas_Regular_11">a[i]</samp> is lost.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-1">Figure 12.1</a></b><br/>Multiplication algorithm.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-2">Figure 12.2</a></b><br/>Division algorithm.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-3">Figure 12.3</a></b><br/>Square root algorithm.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-4">Figure 12.4</a></b><br/>String-integer conversions. (<samp class="SANS_Consolas_Regular_11">appendChar</samp>, <samp class="SANS_Consolas_Regular_11">length</samp>, and <samp class="SANS_Consolas_Regular_11">charAt</samp> are <samp class="SANS_Consolas_Regular_11">String</samp> class methods.)</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-5a">Figure 12.5a</a></b><br/>Memory allocation algorithm (basic).</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-5b">Figure 12.5b</a></b><br/>Memory allocation algorithm (improved).</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-6">Figure 12.6</a></b><br/>Drawing a pixel.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-7">Figure 12.7</a></b><br/>Line-drawing algorithm: basic version (bottom, left) and improved version (bottom, right).</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-8">Figure 12.8</a></b><br/>Circle-drawing algorithm.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-9">Figure 12.9</a></b><br/>Example of a character bitmap.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-10">Figure 12.10</a></b><br/>Handling input from the keyboard.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-11">Figure 12.11</a></b><br/>A trapdoor enabling complete control of the host RAM from Jack.</p>
<p class="toc-bm"><b><a href="chapter_12.html#fig12-12">Figure 12.12</a></b><br/>Logical view (left) and physical implementation (right) of a linked list that supports dynamic memory allocation.</p>
<p class="toc-bm"><b><a href="appendix1.html#figA1-1">Figure A1.1</a></b><br/>Synthesizing a Boolean function from a truth table (example).</p>
<p class="toc-bm"><b><a href="appendix2.html#figA2-1">Figure A2.1</a></b><br/>HDL program example.</p>
<p class="toc-bm"><b><a href="appendix2.html#figA2-2">Figure A2.2</a></b><br/>Buses in action (example).</p>
<p class="toc-bm"><b><a href="appendix2.html#figA2-3">Figure A2.3</a></b><br/>Built-in chip definition example.</p>
<p class="toc-bm"><b><a href="appendix2.html#figA2-4">Figure A2.4</a></b><br/><samp class="SANS_Consolas_Regular_11">DFF</samp> definition.</p>
<p class="toc-bm"><b><a href="appendix2.html#figA2-5">Figure A2.5</a></b><br/>A chip that activates GUI-empowered chip-parts.</p>
<p class="toc-bm"><b><a href="appendix2.html#figA2-6">Figure A2.6</a></b><br/>GUI-empowered chips demo. Since the loaded HDL program uses GUI-empowered chip-parts (step 1), the simulator renders their respective GUI images (step 2). When the user changes the values of the chip input pins (step 3), the simulator reflects these changes in the respective GUIs (step 4).</p>
<p class="toc-bm"><b><a href="appendix3.html#figA3-1">Figure A3.1</a></b><br/>Test script and compare file (example).</p>
<p class="toc-bm"><b><a href="appendix3.html#figA3-2">Figure A3.2</a></b><br/>Variables and methods of key built-in chips in Nand to Tetris.</p>
<p class="toc-bm"><b><a href="appendix3.html#figA3-3">Figure A3.3</a></b><br/>Testing the topmost <samp class="SANS_Consolas_Regular_11">Computer</samp> chip.</p>
<p class="toc-bm"><b><a href="appendix3.html#figA3-4">Figure A3.4</a></b><br/>Testing a machine language program on the CPU emulator.</p>
<p class="toc-bm"><b><a href="appendix3.html#figA3-5">Figure A3.5</a></b><br/>Testing a VM program on the VM emulator.</p>
</section>
</section>
</div>
</body>
</html>