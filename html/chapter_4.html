<html lang="en">
<head>
<title>4 Machine Language</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch4"role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch4"><span aria-label="61" id="pg_61" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">4</samp>       <samp class="SANS_Helvetica_LT_Std_Bold_B_11">Machine Language</samp></h1>
</header>
<blockquoterole="doc-epigraph">
<p class="EP1">Works of imagination should be written in very plain language; the more purely imaginative they are, the more necessary it is to be plain.</p>
<p class="EPA1">—Samuel Taylor Coleridge (1772–1834)</p>
</blockquote>
<p class="noindent">In chapters 1–3 we built processing and memory chips that can be integrated into the hardware platform of a general-purpose computer. Before we set out to complete this construction, let’s pause and ask: What exactly is the <i>purpose</i> of this computer? As the architect Louis Sullivan famously observed, “Form follows function.” If you wish to understand a system, or build one, start by studying the function that the system is supposed to serve. With that in mind, before we set out to complete the construction of our hardware platform, we’ll devote this chapter to studying the <i>machine language</i> that this platform is designed to realize. After all, executing programs written in machine language efficiently is the ultimate function of any general-purpose computer.</p>
<p>A machine language is an agreed-upon formalism designed to code machine instructions. Using these instructions, we can instruct the computer’s processor to perform arithmetic and logical operations, read and write values from and to the computer’s memory, test Boolean conditions, and decide which instruction to fetch and execute next. Unlike high-level languages, whose design goals are cross-platform compatibility and power of expression, machine languages are designed to effect direct execution in, and total control of, a specific hardware platform. Of course, generality, elegance, and power of expression are still desired, but only to the extent that they support the basic requirement of direct and efficient execution in hardware.</p>
<p>Machine language is the most profound interface in the computer enterprise—the fine line where hardware meets software. This is the point where the abstract designs of humans, as manifested in high-level programs, are finally reduced to physical operations performed in silicon. Thus, a machine language can be construed as both a programming artifact and an integral part of the hardware platform. In fact, just as we say that the machine language is designed to control a particular hardware platform, we can say that the hardware platform is designed to execute instructions written in a particular machine language.</p>
<p><span aria-label="62" id="pg_62" role="doc-pagebreak"/>The chapter begins with a general introduction to low-level programming in machine language. Next, we give a detailed specification of the <i>Hack machine language</i>, covering both its binary and symbolic versions. The project that ends the chapter focuses on writing some machine language programs. This provides a hands-on appreciation of low-level programming and sets the stage for completing the construction of the computer hardware in the next chapter.</p>
<p>Although programmers rarely write programs directly in machine language, the study of low-level programming is a prerequisite to a complete and rigorous understanding of how computers work. Further, an intimate understanding of low-level programming helps the programmer write better and more efficient high-level programs. Finally, it is rather fascinating to observe, hands-on, how the most sophisticated software systems are, at bottom, streams of simple instructions, each specifying a primitive bitwise operation on the underlying hardware.</p>
<section>
<h2 class="head a-head"><b>4.1    Machine Language: Overview</b></h2>
<p class="noindent">This chapter focuses not on the machine but rather on the <i>language</i> used to control the machine. Therefore, we will abstract away the hardware platform, focusing on the minimal subset of hardware elements that are mentioned explicitly in machine language instructions.</p>
<section>
<h3 class="head b-head"><b>4.1.1    Hardware Elements</b></h3>
<p class="noindent">A machine language can be viewed as an agreed-upon formalism designed to manipulate a <i>memory</i> using a <i>processor</i> and a set of <i>registers</i>.</p>
<p class="STNI1"><b>Memory</b>: The term <i>memory</i> refers loosely to the collection of hardware devices that store data and instructions in a computer. Functionally speaking, a memory is a continuous sequence of cells, also referred to as <i>locations</i> or <i>memory registers</i>, each having a unique <i>address</i>. An individual memory register is accessed by supplying its address.</p>
<p class="STNI1"><b>Processor</b>: The processor, normally called the <i>Central Processing Unit</i>, or <i>CPU</i>, is a device capable of performing a fixed set of primitive operations. These include arithmetic and logical operations, memory access operations, and control (also called <i>branching</i>) operations. The processor draws its inputs from selected registers and memory locations and writes its outputs to selected registers and memory locations. It consists of an ALU, a set of registers, and gate logic that enables it to parse and execute binary instructions.</p>
<p class="STNI1"><b>Registers</b>: The processor and the memory are implemented as two separate, standalone chips, and moving data from one to the other is a relatively slow affair. For this reason, processors are normally equipped with several on-board registers, each capable of holding <span aria-label="63" id="pg_63" role="doc-pagebreak"/>a single value. Located inside the processor’s chip, the registers serve as a high-speed local memory, allowing the processor to manipulate data and instructions without having to venture outside the chip.</p>
<p>The CPU-resident registers fall into two categories: <i>data registers</i>, designed to hold data values, and <i>address registers</i>, designed to hold values that can be interpreted either as data values or as memory addresses. The computer architecture is configured in such a way that placing a particular value, say <i>n</i>, in an address register, causes the memory location whose address is <i>n</i> to become <i>selected</i> instantaneously.<sup><a href="#footnote-001" id="footnote-001-backlink" role="doc-noteref">1</a></sup> This sets the stage for a subsequent operation on the selected memory location.</p>
</section>
<section>
<h3 class="head b-head"><b>4.1.2    Languages</b></h3>
<p class="noindent">Machine language programs can be written in two alternative, but equivalent, ways: <i>binary</i> and <i>symbolic</i>. For example, consider the abstract operation “set <samp class="SANS_Consolas_Regular_11">R1</samp> to the value of <img alt="" class="inline" height="10" src="../images/4-C1.png" width="43"/>”. As language designers, we can decide to represent the addition operation using the 6-bit code <samp class="SANS_Consolas_Regular_11">101011</samp>, and registers <samp class="SANS_Consolas_Regular_11">R1</samp> and <samp class="SANS_Consolas_Regular_11">R2</samp> using the codes <samp class="SANS_Consolas_Regular_11">00001</samp> and <samp class="SANS_Consolas_Regular_11">00010</samp>, respectively. Assembling these codes left to right, we can decide to use the 16-bit instruction <samp class="SANS_Consolas_Regular_11">1010110001000001</samp> as the binary version of “set <samp class="SANS_Consolas_Regular_11">R1</samp> to the value of <img alt="" class="inline" height="10" src="../images/4-C1.png" width="43"/>”.</p>
<p>In the early days of computer systems, computers were programmed manually: When proto-programmers wanted to issue the instruction “set <samp class="SANS_Consolas_Regular_11">R1</samp> to the value of <img alt="" class="inline" height="10" src="../images/4-C1.png" width="43"/>”, they pushed up and down mechanical switches that stored a binary code like <samp class="SANS_Consolas_Regular_11">1010110001000001</samp> in the computer’s instruction memory. And if the program was a hundred instructions long, they had to go through this ordeal a hundred times. Of course debugging such programs was a perfect nightmare. This led programmers to invent and use symbolic codes as a convenient way for documenting and debugging programs <i>on paper</i>, before entering them into the computer. For example, the symbolic format <samp class="SANS_Consolas_Regular_11">add</samp> <samp class="SANS_Consolas_Regular_11">R2,R1</samp> could be chosen for representing the semantics “set <samp class="SANS_Consolas_Regular_11">R1</samp> to the value of <img alt="" class="inline" height="10" src="../images/4-C1.png" width="43"/>” and the binary instruction <samp class="SANS_Consolas_Regular_11">1010110001000001</samp>.</p>
<p>It didn’t take long before several people hit on the same idea: Symbols like <samp class="SANS_Consolas_Regular_11">R</samp>, <samp class="SANS_Consolas_Regular_11">1</samp>, <samp class="SANS_Consolas_Regular_11">2</samp>, and <span class="symb-code">+</span> can also be represented using agreed-upon binary codes. Why not use symbolic instructions for writing programs, and then use another program—a <i>translator—</i>for translating the symbolic instructions into executable binary code? This innovation liberated programmers from the tedium of writing binary code, paving the way for the subsequent onslaught of high-level programming languages. For reasons that will become clear in chapter 6, symbolic machine languages are called <i>assembly languages</i>, and the programs that translate them into binary code are called <i>assemblers</i>.</p>
<p>Unlike the syntax of high-level languages, which is portable and hardware independent, the syntax of an assembly language is tightly related to the low-level details of the target hardware: the available ALU operations, number and type of registers, memory size, and <span aria-label="64" id="pg_64" role="doc-pagebreak"/>so on. Since different computers vary greatly in terms of any one of these parameters, there is a Tower of Babel of machine languages, each with its obscure syntax, each designed to control a particular family of CPUs. Irrespective of this variety, though, all machine languages are theoretically equivalent, and all of them support similar sets of generic tasks, as we now turn to describe.</p>
</section>
<section>
<h3 class="head b-head"><b>4.1.3    Instructions</b></h3>
<p class="noindent">In what follows, we assume that the computer’s processor is equipped with a set of registers denoted <samp class="SANS_Consolas_Regular_11">R0</samp>, <samp class="SANS_Consolas_Regular_11">R1</samp>, <samp class="SANS_Consolas_Regular_11">R2</samp>, <span class="ellipsis">…</span> The exact number and type of these registers are irrelevant to our present discussion.</p>
<p class="STNI1"><b>Arithmetic and logical operations</b>: Every machine language features instructions for performing basic arithmetic operations like addition and subtraction, as well as basic logical operations like And, Or, Not. For example, consider the following code segments:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_4.1.png"/></figure>
<p class="TNI1">For such symbolic instructions to execute on a computer, they must first be translated into binary code. The translation is done by a program named <i>assembler</i>, which we’ll develop in chapter 6. For now, we assume that we have access to such an assembler and that we can use it as needed.</p>
<p class="STNI1"><b>Memory access</b>: Every machine language features means for accessing, and then manipulating, selected memory locations. This is typically done using an <i>address register</i>, let’s call it <samp class="SANS_Consolas_Regular_11">A</samp>. For example, suppose we wish to set memory location 17 to the value 1. We can decide to do so using the two instructions <samp class="SANS_Consolas_Regular_11">load</samp> <samp class="SANS_Consolas_Regular_11">A,17</samp> followed by <samp class="SANS_Consolas_Regular_11">load</samp> <samp class="SANS_Consolas_Regular_11">M,1</samp>, where, by convention, <samp class="SANS_Consolas_Regular_11">M</samp> stands for the memory register selected by <samp class="SANS_Consolas_Regular_11">A</samp> (namely, the memory register whose address is the current value of <samp class="SANS_Consolas_Regular_11">A</samp>). With that in mind, suppose we wish to set the fifty memory locations 200, 201, 202, <span class="ellipsis">…</span>, 249 to 1. This can be done by executing the instruction <samp class="SANS_Consolas_Regular_11">load</samp> <samp class="SANS_Consolas_Regular_11">A,200</samp> and then entering a loop that executes the instructions <samp class="SANS_Consolas_Regular_11">load</samp> <samp class="SANS_Consolas_Regular_11">M,1</samp> and <samp class="SANS_Consolas_Regular_11">add</samp> <samp class="SANS_Consolas_Regular_11">A,A,1</samp> fifty times.</p>
<p class="STNI1"><b>Flow control</b>: While computer programs execute by default sequentially, one instruction after another, they also include occasional <i>jumps</i> to locations other than the next instruc<span aria-label="65" id="pg_65" role="doc-pagebreak"/>tion. To facilitate such branching actions, machine languages feature several variants of conditional and unconditional <i>goto</i> instructions, as well as label declaration statements that mark the goto destinations. <a href="chapter_4.html#fig4-1" id="rfig4-1">Figure 4.1</a> illustrates a simple branching action using machine language.</p>
<figure class="IMG"><img alt="" id="fig4-1" src="../images/figure_4.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig4-1">Figure 4.1</a></b>    Two versions of the same low-level code (it is assumed that the code includes some loop termination logic, not shown here).</p></figcaption>
</figure>
<p class="STNI1"><b>Symbols</b>: Both code versions in <a href="chapter_4.html#fig4-1">figure 4.1</a> are written in assembly language; thus, both must be translated into binary code before they can be executed. Also, both versions perform exactly the same logic. However, the code version that uses symbolic references is much easier to write, debug, and maintain.</p>
<p>Further, unlike the code that uses physical addresses, the translated binary version of the code that uses symbolic references can be loaded into, and executed from, any memory segment that happens to be available in the computer’s memory. Therefore, low-level code that mentions no physical addresses is said to be <i>relocatable</i>. Clearly, relocatable code is essential in computer systems like PCs and cell phones, which routinely load and execute multiple apps dynamically and simultaneously. Thus, we see that symbolic references are not just a matter of cosmetics—they are used to liberate the code from unnecessary physical attachments to the host memory.</p>
<p>This ends our brief introduction to some machine language essentials. The next section gives a formal description of one specific machine language—the native code of the Hack computer.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>4.2    The Hack Machine Language</b></h2>
<p class="noindent">Programmers who write low-level code (or programmers who write compilers and interpreters that generate low-level code) interact with the computer abstractly, through its <i>interface</i>, which is the computer’s machine language. Although programmers don’t have to be aware of all the details of the underlying computer architecture, they should be familiar with the hardware elements that come to play in their low-level programs.</p>
<p>With that in mind, we begin the discussion of the Hack machine language with a conceptual description of the Hack computer. Next, we give an example of a complete program <span aria-label="66" id="pg_66" role="doc-pagebreak"/>written in the Hack assembly language. This sets the stage for the remainder of this section, in which we give a formal specification of the Hack language instructions.</p>
<section>
<h3 class="head b-head"><b>4.2.1    Background</b></h3>
<p class="noindent">The design of the Hack computer, which will be presented in the next chapter, follows a widely used hardware paradigm known as the <i>von Neumann architecture</i>, named after the computing pioneer John von Neumann. Hack is a 16-bit computer, meaning that the CPU and the memory units are designed to process, move, and store, chunks of 16-bit values.</p>
<p class="STNI1"><b>Memory</b>: As seen in <a href="chapter_4.html#fig4-2" id="rfig4-2">figure 4.2</a>, the Hack platform uses two distinct memory units: a <i>data memory</i> and an <i>instruction memory</i>. The data memory stores the binary values that programs manipulate. The instruction memory stores the program’s instructions, also represented as binary values. Both memories are 16-bit wide, and each has a 15-bit address space. Thus the maximum addressable size of each memory unit is 2<small>15</small> or 32K 16-bit words (the symbol <i>K</i>, abbreviated from <i>kilo</i>—the Greek word for <i>thousand</i>—is commonly used to stand for the number <img alt="" class="inline" height="13" src="../images/4-1.png" width="68"/>). It is convenient to think about each memory unit as a linear sequence of addressable memory registers, with addresses ranging from 0 to 32K–1.</p>
<figure class="IMG"><img alt="" id="fig4-2" src="../images/figure_4.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig4-2">Figure 4.2</a></b>    Conceptual model of the Hack memory system. Although the actual architecture is wired somewhat differently (as described in chapter 5), this model helps understand the semantics of Hack programs.</p></figcaption>
</figure>
<p>The <i>data memory</i> (which we also call RAM) is a read/write device. Hack instructions can read data from, and write data to, selected RAM registers. An individual register is selected by supplying its address. Since the memory’s <samp class="SANS_Consolas_Regular_11">address</samp> input always contains some value, there is always one selected register, and this register is referred to in Hack instructions as <samp class="SANS_Consolas_Regular_11">M</samp>. For example, the Hack instruction <samp class="SANS_Consolas_Regular_11"><img alt="" class="inline" height="10" src="../images/4-C2.png" width="26"/></samp> sets the selected RAM register to <samp class="SANS_Consolas_Regular_11">0</samp>.</p>
<p>The <i>instruction memory</i> (which we also call ROM) is a read-only device, and programs are loaded into it using some exogenous means (more about this in chapter 5). Just like <span aria-label="67" id="pg_67" role="doc-pagebreak"/>with the RAM, the instruction memory’s <samp class="SANS_Consolas_Regular_11">address</samp> input always contains some value; thus, there is always one selected instruction memory register. The value of this register is referred to as the <i>current instruction</i>.</p>
<p class="STNI1"><b>Registers</b>: Hack instructions are designed to manipulate three 16-bit registers: a <i>data register</i>, denoted <samp class="SANS_Consolas_Regular_11">D</samp>, an <i>address register</i>, denoted <samp class="SANS_Consolas_Regular_11">A</samp>, and a selected data memory register, denoted <samp class="SANS_Consolas_Regular_11">M</samp>. Hack instructions have a self-explanatory syntax. For example: <img alt="" class="inline" height="12" src="../images/4-C3.png" width="83"/> <img alt="" class="inline" height="12" src="../images/4-C4.png" width="81"/> and so on.</p>
<p>The role of the data register <samp class="SANS_Consolas_Regular_11">D</samp> is straightforward: it serves to store a 16-bit value. The second register, <samp class="SANS_Consolas_Regular_11">A</samp>, serves as both an address register and a data register. If we wish to store the value 17 in the <samp class="SANS_Consolas_Regular_11">A</samp> register, we use the Hack instruction <samp class="SANS_Consolas_Regular_11">@17</samp> (the reason for this syntax will become clear soon). In fact, this is the only way to get a constant into the Hack computer. For example, if we wish to set the <samp class="SANS_Consolas_Regular_11">D</samp> register to 17, we use the two instructions <samp class="SANS_Consolas_Regular_11">@17</samp>, followed by <img alt="" class="inline" height="10" src="../images/4-C5.png" width="26"/>. In addition to serving as a second data register, the hard-working <samp class="SANS_Consolas_Regular_11">A</samp> register is also used for addressing the data memory and the instruction memory, as we now turn to discuss.</p>
<p class="STNI1"><b>Addressing</b>: The Hack instruction <samp class="SANS_Consolas_Regular_11">@</samp> <i>xxx</i> sets the <samp class="SANS_Consolas_Regular_11">A</samp> register to the value <i>xxx</i>. In addition, the <samp class="SANS_Consolas_Regular_11">@</samp> <i>xxx</i> instruction has two side effects. First, it makes the RAM register whose address is <i>xxx</i> the selected memory register, denoted <samp class="SANS_Consolas_Regular_11">M</samp>. Second, it makes the value of the ROM register whose address is <i>xxx</i> the selected instruction. Therefore, setting <samp class="SANS_Consolas_Regular_11">A</samp> to some value has the simultaneous effect of preparing the stage, potentially, for one of two very different subsequent actions: manipulating the selected data memory register or doing something with the selected instruction. Which action to pursue (and which to ignore) is determined by the subsequent Hack instruction.</p>
<p>To illustrate, suppose we wish to set the value of <samp class="SANS_Consolas_Regular_11-SC">RAM[100]</samp> to 17. This can be done using the Hack instructions <samp class="SANS_Consolas_Regular_11">@17</samp>, <img alt="" class="inline" height="10" src="../images/4-C6.png" width="26"/>, <samp class="SANS_Consolas_Regular_11">@100</samp>, <img alt="" class="inline" height="10" src="../images/4-C7.png" width="25"/>. Note that in the first pair of instructions, <samp class="SANS_Consolas_Regular_11">A</samp> serves as a data register; in the second pair of instructions, it serves as an address register. Here is another example: To set <samp class="SANS_Consolas_Regular_11-SC">RAM[100]</samp> to the value of <samp class="SANS_Consolas_Regular_11-SC">RAM[200]</samp>, we can use the Hack instructions <samp class="SANS_Consolas_Regular_11">@200</samp>, <img alt="" class="inline" height="10" src="../images/4-C8.png" width="26"/>, <samp class="SANS_Consolas_Regular_11">@100</samp>, <img alt="" class="inline" height="10" src="../images/4-C9.png" width="25"/>.</p>
<p>In both of these scenarios, the <samp class="SANS_Consolas_Regular_11">A</samp> register also selected registers in the instruction memory—an action which the two scenarios ignored. The next section discusses the opposite scenario: using <samp class="SANS_Consolas_Regular_11">A</samp> for selecting instructions while ignoring its effect on the data memory.</p>
<p class="STNI1"><b>Branching</b>: The code examples thus far imply that a Hack program is a sequence of instructions, to be executed one after the other. This indeed is the default flow of control, but what happens if we wish to branch to executing not the next instruction but, say, instruction number <samp class="SANS_Consolas_Regular_11">29</samp> in the program? In the Hack language, this can be done using the Hack instruction <samp class="SANS_Consolas_Regular_11">@29</samp>, followed by the Hack instruction <samp class="SANS_Consolas_Regular_11">0;JMP</samp>. The first instruction selects the <samp class="SANS_Consolas_Regular_11">ROM[29]</samp> register (it also selects <samp class="SANS_Consolas_Regular_11-SC">RAM[29]</samp>, but we don’t care about it). The subsequent <samp class="SANS_Consolas_Regular_11">0;JMP</samp> instruction realizes the Hack version of <i>unconditional branching</i>: go to execute the instruction addressed by the <samp class="SANS_Consolas_Regular_11">A</samp> register (we’ll explain the <samp class="SANS_Consolas_Regular_11">;0</samp> prefix later). Since the <samp class="SANS_Consolas_Regular_11">ROM</samp> is <span aria-label="68" id="pg_68" role="doc-pagebreak"/>assumed to contain the program that we are presently executing, starting at address 0, the two instructions <samp class="SANS_Consolas_Regular_11">@29</samp> and <samp class="SANS_Consolas_Regular_11">0;JMP</samp> end up making the value of <samp class="SANS_Consolas_Regular_11">ROM[29]</samp> the next instruction to be executed.</p>
<p>The Hack language also features <i>conditional branching</i>. For example, the logic <samp class="SANS_Consolas_Regular_11">if</samp> <samp class="SANS_Consolas_Regular_11">D</samp><span class="code_eq-symb">==</span><samp class="SANS_Consolas_Regular_11">0</samp> <samp class="SANS_Consolas_Regular_11">goto</samp> <samp class="SANS_Consolas_Regular_11">52</samp> can be implemented using the instruction <samp class="SANS_Consolas_Regular_11">@52</samp>, followed by the instruction <samp class="SANS_Consolas_Regular_11">D;JEQ</samp>. The semantics of the second instruction is “evaluate <samp class="SANS_Consolas_Regular_11">D</samp>; if the value equals zero, jump to execute the instruction stored in the address selected by <samp class="SANS_Consolas_Regular_11">A</samp>”. The Hack language features several such <i>conditional branching</i> commands, as we’ll explain later in the chapter.</p>
<p>To recap: The <samp class="SANS_Consolas_Regular_11">A</samp> register serves two simultaneous, yet very different, addressing functions. Following an <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx</i> instruction, we either focus on the selected data memory register (<samp class="SANS_Consolas_Regular_11">M</samp>) and ignore the selected instruction, or we focus on the selected instruction and ignore the selected data memory register. This duality is a bit confusing, but note that we got away with using one address register to control two separate memory devices (see <a href="chapter_4.html#fig4-2">figure 4.2</a>). The result is a simpler computer architecture and a compact machine language. As usual in our business, simplicity and thrift reign supreme.</p>
<p class="STNI1"><b>Variables</b>: The <i>xxx</i> in the Hack instruction <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx</i> can be either a constant or a symbol. If the instruction is <samp class="SANS_Consolas_Regular_11">@23</samp>, the <samp class="SANS_Consolas_Regular_11">A</samp> register is set to the value 23. If the instruction is <samp class="SANS_Consolas_Regular_11">@x</samp>, where <samp class="SANS_Consolas_Regular_11">x</samp> is a symbol that is bound to some value, say 513, the instruction sets the <samp class="SANS_Consolas_Regular_11">A</samp> register to 513. The use of symbols endows Hack assembly programs with the ability to use <i>variables</i> rather than physical memory addresses. For example, the typical high-level assignment statement <samp class="SANS_Consolas_Regular_11">let</samp> <img alt="" class="inline" height="10" src="../images/4-C10.png" width="33"/> can be implemented in the Hack language as <samp class="SANS_Consolas_Regular_11">@17</samp>, <img alt="" class="inline" height="10" src="../images/4-C11.png" width="26"/>, <samp class="SANS_Consolas_Regular_11">@x</samp>, <img alt="" class="inline" height="10" src="../images/4-C12.png" width="25"/>. The semantics of this code is “select the RAM register whose address is the value that is bound to the symbol <samp class="SANS_Consolas_Regular_11">x</samp>, and set this register to 17”. Here we assume that there is an agent who knows how to bind the symbols found in high-level languages, like <samp class="SANS_Consolas_Regular_11">x</samp>, to sensible and consistent addresses in the data memory. This agent is the assembler.</p>
<p>Thanks to the assembler, variables like <samp class="SANS_Consolas_Regular_11">x</samp> can be named and used in Hack programs at will, and as needed. For example, suppose we wish to write code that increments some counter. One option is to keep this counter in, say, <samp class="SANS_Consolas_Regular_11-SC">RAM[30]</samp>, and increment it using the instructions <img alt="" class="inline" height="14" src="../images/4-C13.png" width="82"/> A more sensible approach is to use <samp class="SANS_Consolas_Regular_11">@count</samp>, <img alt="" class="inline" height="12" src="../images/4-C14.png" width="48"/> and let the assembler worry about where to put this variable in memory. We don’t care about the specific address so long as the assembler will always resolve the symbol to that address. In chapter 6 we’ll learn how to develop an assembler that implements this useful mapping operation.</p>
<p>In addition to the symbols that can be introduced into Hack assembly programs as needed, the Hack language features sixteen built-in symbols named <samp class="SANS_Consolas_Regular_11">R0</samp>, <samp class="SANS_Consolas_Regular_11">R1</samp>, <samp class="SANS_Consolas_Regular_11">R2</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">R15</samp>. These symbols are always bound by the assembler to the values 0, 1, 2, <span class="ellipsis">…</span>, 15. Thus, for example, the two Hack instructions <samp class="SANS_Consolas_Regular_11">@R3</samp>, <img alt="" class="inline" height="10" src="../images/4-C15.png" width="26"/> will end up setting <samp class="SANS_Consolas_Regular_11-SC">RAM[3]</samp> to <samp class="SANS_Consolas_Regular_11">0</samp>. In what follows, we sometimes refer to <samp class="SANS_Consolas_Regular_11">R0</samp>, <samp class="SANS_Consolas_Regular_11">R1</samp>, <samp class="SANS_Consolas_Regular_11">R2</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">R15</samp> as <i>virtual registers</i>.</p>
<p>Before going on, we suggest you review, and make sure you fully understand, the code examples shown in <a href="chapter_4.html#fig4-3" id="rfig4-3">figure 4.3</a> (some of which were already discussed).</p>
<figure class="IMG"><img alt="" id="fig4-3" src="../images/figure_4.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig4-3">Figure 4.3</a></b>    Hack assembly code examples.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><span aria-label="69" id="pg_69" role="doc-pagebreak"/><b>4.2.2    Program Example</b></h3>
<p class="noindent">Jumping into the cold water, let’s review a complete Hack assembly program, deferring a formal description of the Hack language to the next section. Before we do so, a word of caution: Most readers will probably be mystified by the obscure style of this program. To which we say: Welcome to machine language programming. Unlike high-level languages, machine languages are not designed to please programmers. Rather, they are designed to control a hardware platform, efficiently and plainly.</p>
<p>Suppose we wish to compute the sum <img alt="" class="inline" height="14" src="../images/4-2.png" width="113"/> for a given value <i>n</i>. To operationalize things, we’ll put the input <i>n</i> in <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and the output sum in <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp>. The program that computes this sum is listed in <a href="chapter_4.html#fig4-4" id="rfig4-4">figure 4.4</a>. Beginning with the pseudocode, note that instead of utilizing the well-known formula for computing the sum of an arithmetic series, we use brute-force addition. This is done for illustrating conditional and iterative processing in the Hack machine language.</p>
<figure class="IMG"><img alt="" height="550" id="fig4-4" src="../images/figure_4.4.png"/>
<figcaption><p class="CAP"><b><a href="#rfig4-4">Figure 4.4</a></b>    A Hack assembly program (example). Note that <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp> can be referred to as <samp class="SANS_Consolas_Regular_11">R0</samp> and <samp class="SANS_Consolas_Regular_11">R1.</samp></p></figcaption>
</figure>
<p>Later in the chapter you will understand this program completely. For now, we suggest ignoring the details, and observing instead the following pattern: In the Hack language, every operation involving a memory location entails two instructions. The first instruction, <samp class="SANS_Consolas_Regular_11">@</samp><i>addr</i>, is used to select a target memory address; the subsequent instruction specifies what to do at this address. To support this logic, the Hack language features two generic instructions, several examples of which we have already seen: an <i>address instruction</i>, also called <i>A</i>-instruction (the instructions that start with <samp class="SANS_Consolas_Regular_11">@</samp>), and a <i>compute instruction</i>, also called <i>C</i>-instruction (all the other instructions). Each instruction has a symbolic representation, a binary representation, and an effect on the computer, as we now turn to describe.<span aria-label="70" id="pg_70" role="doc-pagebreak"/></p>
</section>
<section>
<h3 class="head b-head"><span aria-label="71" id="pg_71" role="doc-pagebreak"/><b>4.2.3    The Hack Language Specification</b></h3>
<p class="noindent">The Hack machine language consists of two instructions, specified in <a href="chapter_4.html#fig4-5" id="rfig4-5">figure 4.5</a>.</p>
<figure class="IMG"><img alt="" id="fig4-5" src="../images/figure_4.5.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig4-5">Figure 4.5</a></b>    The Hack instruction set, showing symbolic mnemonics and their corresponding binary codes.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><b>The <i>A</i>-instruction</b></h3>
<p class="noindent">The <i>A</i>-instruction sets the <samp class="SANS_Consolas_Regular_11">A</samp> register to some 15-bit value. The binary version consists of two fields: an operation code, also known as <i>op-code</i>, which is <samp class="SANS_Consolas_Regular_11">0</samp> (the leftmost bit), followed by fifteen bits that code a nonnegative binary number. For example, the symbolic instruction <samp class="SANS_Consolas_Regular_11">@5</samp>, whose binary version is <samp class="SANS_Consolas_Regular_11">0000000000000101</samp>, stores the binary representation of 5 in the <samp class="SANS_Consolas_Regular_11">A</samp> register.</p>
<p>The <i>A</i>-instruction is used for three different purposes. First, it provides the only way to enter a constant into the computer under program control. Second, it sets the stage for a subsequent <i>C</i>-instruction that manipulates a selected RAM register, referred to as <samp class="SANS_Consolas_Regular_11">M</samp>, by first setting <samp class="SANS_Consolas_Regular_11">A</samp> to the address of that register. Third, it sets the stage for a subsequent <i>C</i>-instruction that specifies a jump by first setting <samp class="SANS_Consolas_Regular_11">A</samp> to the address of the jump destination.</p>
</section>
<section>
<h3 class="head b-head"><span aria-label="72" id="pg_72" role="doc-pagebreak"/><b>The</b> <b><i>C</i></b><b>-instruction</b></h3>
<p class="noindent">The <i>C</i>-instruction answers three questions: what to compute (an ALU operation, denoted <i>comp</i>), where to store the computed value (<i>dest</i>), and what to do next (<i>jump</i>). Along with the <i>A</i>-instruction, the <i>C</i>-instruction specifies all the possible operations of the computer.</p>
<p>In the binary version, the leftmost bit is the <i>C</i>-instruction’s op-code, which is <samp class="SANS_Consolas_Regular_11">1</samp>. The next two bits are not used, and are set by convention to <samp class="SANS_Consolas_Regular_11">1</samp>. The next seven bits are the binary representation of the <i>comp</i> field. The next three bits are the binary representation of the <i>dest</i> field. The rightmost three bits are the binary representation of the <i>jump</i> field. We now describe the syntax and semantics of these three fields.</p>
<p class="STNI1"><b>Computation specification (</b><b><i>comp</i></b><b>)</b>: The Hack ALU is designed to compute one out of a fixed set of functions on two given 16-bit inputs. In the Hack computer, the two ALU data inputs are wired as follows. The first ALU input feeds from the <samp class="SANS_Consolas_Regular_11">D</samp> register. The second ALU input feeds either from the <samp class="SANS_Consolas_Regular_11">A</samp> register (when the <samp class="SANS_Consolas_Regular_11">a</samp>-bit is 0) or from <samp class="SANS_Consolas_Regular_11">M</samp>, the selected data memory register (when the <samp class="SANS_Consolas_Regular_11">a</samp>-bit is 1). Taken together, the computed function is specified by the <samp class="SANS_Consolas_Regular_11">a</samp>-bit and the six <samp class="SANS_Consolas_Regular_11">c</samp>-bits comprising the instruction’s <i>comp</i> field. This 7-bit pattern can potentially code 128 different calculations, of which only the twenty-eight listed in <a href="chapter_4.html#fig4-5">figure 4.5</a> are documented in the language specification.</p>
<p>Recall that the format of the <i>C</i>-instruction is <samp class="SANS_Consolas_Regular_11">111accccccdddjjj</samp>. Suppose we want to compute the value of the <samp class="SANS_Consolas_Regular_11">D</samp> register, minus 1. According to <a href="chapter_4.html#fig4-5">figure 4.5</a>, this can be done using the symbolic instruction <samp class="SANS_Consolas_Regular_11">D</samp><span class="symb-code">−</span><samp class="SANS_Consolas_Regular_11">1</samp>, which is <samp class="SANS_Consolas_Regular_11">111</samp><samp class="SANS_Consolas_Regular_U_11">0001110</samp><samp class="SANS_Consolas_Regular_11">000000</samp> in binary (the relevant 7-bit <i>comp</i> field is underlined for emphasis). To compute a bitwise Or between the values of the <samp class="SANS_Consolas_Regular_11">D</samp> and <samp class="SANS_Consolas_Regular_11">M</samp> registers, we use the instruction <samp class="SANS_Consolas_Regular_11">D|M</samp> (in binary: <samp class="SANS_Consolas_Regular_11">111</samp><samp class="SANS_Consolas_Regular_U_11">1010101</samp><samp class="SANS_Consolas_Regular_11">000000)</samp>. To compute the constant <img alt="" class="inline" height="12" src="../images/4-3.png" width="16"/>, we use the instruction <span class="symb">−</span><samp class="SANS_Consolas_Regular_11">1</samp> (in binary: <samp class="SANS_Consolas_Regular_11">111</samp><samp class="SANS_Consolas_Regular_U_11">0111010</samp><samp class="SANS_Consolas_Regular_11">000000)</samp>, and so on.</p>
<p class="STNI1"><b>Destination specification (</b><b><i>dest</i></b><b>)</b>: The ALU output can be stored in zero, one, two, or three possible destinations, simultaneously. The first and second <samp class="SANS_Consolas_Regular_11">d</samp>-bits code whether to store the computed value in the <samp class="SANS_Consolas_Regular_11">A</samp> register and in the <samp class="SANS_Consolas_Regular_11">D</samp> register, respectively. The third <samp class="SANS_Consolas_Regular_11">d</samp>-bit codes whether to store the computed value in <samp class="SANS_Consolas_Regular_11">M</samp>, the currently selected memory register. One, more than one, or none of these three bits may be asserted.</p>
<p>Recall that the format of the <i>C</i>-instruction is <samp class="SANS_Consolas_Regular_11">111accccccdddjjj</samp>. Suppose we wish to increment the value of the memory register whose address is 7 and also to store the new value in the <samp class="SANS_Consolas_Regular_11">D</samp> register. According to <a href="chapter_4.html#fig4-5">figure 4.5</a>, this can be accomplished using the two instructions:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_4.2.png"/></figure>
<p class="TNI1"><b>Jump directive (</b><b><i>jump</i></b><b>)</b>: The <i>jump</i> field of the <i>C</i>-instruction specifies what to do next. There are two possibilities: fetch and execute the next instruction in the program, which <span aria-label="73" id="pg_73" role="doc-pagebreak"/>is the default, or fetch and execute some other, designated instruction. In the latter case, we assume that the <samp class="SANS_Consolas_Regular_11">A</samp> register was already set to the address of the target instruction.</p>
<p>During run-time, whether or not to jump is determined jointly by the three <samp class="SANS_Consolas_Regular_11">j</samp>-bits of the instruction’s <i>jump</i> field and by the ALU output. The first, second, and third <samp class="SANS_Consolas_Regular_11">j</samp>-bits specify whether to jump in case the ALU output is negative, zero, or positive, respectively. This gives eight possible jump conditions, listed at the bottom right of <a href="chapter_4.html#fig4-5">figure 4.5</a>. The convention for specifying an unconditional goto instruction is <samp class="SANS_Consolas_Regular_11">0;JMP</samp> (since the <i>comp</i> field is mandatory, the convention is to compute <samp class="SANS_Consolas_Regular_11">0</samp>—an arbitrarily chosen ALU operation—which is ignored).</p>
<p class="STNI1"><b>Preventing conflicting uses of the</b> <b><i>A</i></b> <b>register</b>: The Hack computer uses one address register for addressing both the RAM and the ROM. Thus, when we execute the instruction <samp class="SANS_Consolas_Regular_11">@</samp><i>n</i>, we select both <samp class="SANS_Consolas_Regular_11-SC">RAM[</samp><i>n</i><samp class="SANS_Consolas_Regular_11">]</samp> and <samp class="SANS_Consolas_Regular_11">ROM[</samp><i>n</i><samp class="SANS_Consolas_Regular_11">]</samp>. This is done in order to set the stage for either a subsequent <i>C</i>-instruction that operates on the selected data memory register, <samp class="SANS_Consolas_Regular_11">M</samp>, or a subsequent <i>C</i>-instruction that specifies a jump. To make sure that we perform exactly one of these two operations, we issue the following best-practice advice: A <i>C</i>-instruction that contains a reference to <samp class="SANS_Consolas_Regular_11">M</samp> should specify no jump, and vice versa: a <i>C</i>-instruction that specifies a jump should make no reference to <samp class="SANS_Consolas_Regular_11">M</samp>.</p>
</section>
<section>
<h3 class="head b-head"><b>4.2.4    Symbols</b></h3>
<p class="noindent">Assembly instructions can specify memory locations (addresses) using either constants or symbols. The symbols fall into three functional categories: <i>predefined symbols</i>, representing special memory addresses; <i>label symbols</i>, representing destinations of goto instructions; and <i>variable symbols</i>, representing variables.</p>
<p class="STNI1"><b>Predefined symbols</b>: There are several kinds of predefined symbols, designed to promote consistency and readability of low-level Hack programs.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">R0</samp>, <samp class="SANS_Consolas_Bold_B_11">R1</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Bold_B_11">R15</samp>: These symbols are bound to the values 0 to 15. This predefined binding helps make Hack programs more readable. To illustrate, consider the following code segment:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_4.3.png"/></figure>
<p>The instruction <samp class="SANS_Consolas_Regular_11">@7</samp> sets the <samp class="SANS_Consolas_Regular_11">A</samp> register to 7, and <samp class="SANS_Consolas_Regular_11">@R3</samp> sets the <samp class="SANS_Consolas_Regular_11">A</samp> register to 3. Why do we use <samp class="SANS_Consolas_Regular_11">R</samp> in the latter and not in the former? Because it makes the code more self-explanatory. In the instruction <samp class="SANS_Consolas_Regular_11">@7</samp>, the syntax hints that <samp class="SANS_Consolas_Regular_11">A</samp> is used as a <i>data register</i>, ignoring the side effect of also selecting <samp class="SANS_Consolas_Regular_11-SC">RAM[7]</samp>. In the instruction <samp class="SANS_Consolas_Regular_11">@R3</samp>, the syntax hints that <samp class="SANS_Consolas_Regular_11">A</samp> is used <i>to</i> <span aria-label="74" id="pg_74" role="doc-pagebreak"/><i>select a data memory address</i>. In general, the predefined symbols <samp class="SANS_Consolas_Regular_11">R0</samp>, <samp class="SANS_Consolas_Regular_11">R1</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">R15</samp> can be viewed as ready-made working variables, sometimes referred to as <i>virtual registers</i>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">SP</samp>, <samp class="SANS_Consolas_Bold_B_11">LCL</samp>, <samp class="SANS_Consolas_Bold_B_11">ARG</samp>, <samp class="SANS_Consolas_Bold_B_11">THIS</samp>, <samp class="SANS_Consolas_Bold_B_11">THAT</samp>: These symbols are bound to the values 0, 1, 2, 3, and 4, respectively. For example, address 2 can be selected using either <samp class="SANS_Consolas_Regular_11">@2</samp>, <samp class="SANS_Consolas_Regular_11">@R2</samp>, or <samp class="SANS_Consolas_Regular_11">@ARG</samp>. The symbols <samp class="SANS_Consolas_Regular_11">SP</samp>, <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, and <samp class="SANS_Consolas_Regular_11">THAT</samp> will be used in part II of the book, when we implement the compiler and the virtual machine that run on top of the Hack platform. These symbols can be completely ignored for now; we specify them for completeness.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">SCREEN</samp>, <samp class="SANS_Consolas_Bold_B_11">KBD</samp>: Hack programs can read data from a keyboard and display data on a screen. The screen and the keyboard interface with the computer via two designated memory blocks known as <i>memory maps</i>. The symbols <samp class="SANS_Consolas_Regular_11">SCREEN</samp> and <samp class="SANS_Consolas_Regular_11">KBD</samp> are bound, respectively, to the values 16384 and 24576 (in hexadecimal: 4000 and 6000), which are the agreed-upon base addresses of the <i>screen memory map</i> and the <i>keyboard memory map</i>, respectively. These symbols are used by Hack programs that manipulate the screen and the keyboard, as we’ll see in the next section.</p>
<p class="STNI1"><b>Label symbols</b>: Labels can appear anywhere in a Hack assembly program and are declared using the syntax <samp class="SANS_Consolas_Regular_11">(</samp><i>xxx</i><samp class="SANS_Consolas_Regular_11">)</samp>. This directive binds the symbol <i>xxx</i> to the address of the next instruction in the program. Goto instructions that make use of label symbols can appear anywhere in the program, even before the label has been declared. By convention, label symbols are written using uppercase letters. The program listed in <a href="chapter_4.html#fig4-4">figure 4.4</a> uses three label symbols: <samp class="SANS_Consolas_Regular_11">LOOP</samp>, <samp class="SANS_Consolas_Regular_11">STOP</samp> and <samp class="SANS_Consolas_Regular_11">END</samp>.</p>
<p class="STNI1"><b>Variable symbols</b>: Any symbol <i>xxx</i> appearing in a Hack assembly program that is not predefined and is not declared elsewhere using <samp class="SANS_Consolas_Regular_11">(</samp><i>xxx</i><samp class="SANS_Consolas_Regular_11">)</samp> is treated as a variable and is bound to a unique running number starting at 16. By convention, variable symbols are written using lowercase letters. For example, the program listed in <a href="chapter_4.html#fig4-4">figure 4.4</a> uses two variables: <samp class="SANS_Consolas_Regular_11">i</samp> and <samp class="SANS_Consolas_Regular_11">sum</samp>. These symbols are bound by the assembler to 16 and 17, respectively. Therefore, following translation, instructions like <samp class="SANS_Consolas_Regular_11">@i</samp> and <samp class="SANS_Consolas_Regular_11">@sum</samp> end up selecting memory addresses 16 and 17, respectively. The beauty of this contract is that the assembly program is completely oblivious of the physical addresses. The assembly program uses symbols only, trusting that the assembler will know how to resolve them into actual addresses.</p>
</section>
<section>
<h3 class="head b-head"><b>4.2.5    Input/Output Handling</b></h3>
<p class="noindent">The Hack hardware platform can be connected to two peripheral I/O devices: a screen and a keyboard. Both devices interact with the computer platform through <i>memory maps</i>.</p>
<p>Drawing pixels on the screen is done by writing binary values into a designated memory segment associated with the screen, and listening to the keyboard is done by reading a designated memory location associated with the keyboard. The physical I/O devices and <span aria-label="75" id="pg_75" role="doc-pagebreak"/>their memory maps are synchronized via continuous refresh loops that are external to the main hardware platform.</p>
<p class="STNI1"><b>Screen</b>: The Hack computer interacts with a black-and-white screen organized as 256 rows of 512 pixels per row. The screen’s contents are represented by a memory map, stored in an 8K memory block of 16-bit words, starting at RAM address 16384 (in hexadecimal: 4000), also referred to by the predefined symbol <samp class="SANS_Consolas_Regular_11">SCREEN</samp>. Each row in the physical screen, starting at the screen’s top-left corner, is represented in the RAM by thirty-two consecutive 16-bit words. Following convention, the screen origin is the top-left corner, which is considered row 0 and column 0. With that in mind, the pixel at row <i>row</i> and column <i>col</i> is mapped onto the <i>col</i> % 16 bit (counting from LSB to MSB) of the word located at <samp class="SANS_Consolas_Regular_11-SC">RAM[SCREEN</samp> <img alt="" class="inline" height="12" src="../images/75.png" width="129"/><samp class="SANS_Consolas_Regular_11">]</samp>. This pixel can be either read (probing whether it is black or white), made black by setting it to 1, or made white by setting it to 0. For example, consider the following code segment, which blackens the first 16 pixels at the top left of the screen:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_4.4.png"/></figure>
<p class="TNI1">Note that Hack instructions cannot access individual pixels/bits directly. Instead, we must fetch a complete 16-bit word from the memory map, figure out which bit or bits we wish to manipulate, carry out the manipulation using arithmetic/logical operations (without touching the other bits), and then write the modified 16-bit word to the memory. In the example given above, we got away with not doing bit-specific manipulations since the task could be implemented using one bulk manipulation.</p>
<p class="STNI1"><b>Keyboard</b>: The Hack computer can interact with a standard physical keyboard via a single-word memory map located at RAM address 24576 (in hexadecimal: 6000), also referred to by the predefined symbol <samp class="SANS_Consolas_Regular_11">KBD</samp>. The contract is as follows: When a key is pressed on the physical keyboard, its 16-bit character code appears at <samp class="SANS_Consolas_Regular_11-SC">RAM[KBD]</samp>. When no key is pressed, the code <samp class="SANS_Consolas_Regular_11">0</samp> appears. The Hack character set is listed in appendix 5.</p>
<p>By now, readers with programming experience have probably noticed that manipulating input/output devices using assembly language is a tedious affair. That’s because they are accustomed to using high-level statements like <samp class="SANS_Consolas_Regular_11">write</samp> <samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">hello</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp> or <samp class="SANS_Consolas_Regular_11">draw</samp> <samp class="SANS_Consolas_Regular_11">Circle</samp> <samp class="SANS_Consolas_Regular_11">(x,y, radius)</samp>. As you can now appreciate, there is a considerable gap between these abstract, high-level I/O statements and the bit-by-bit machine instructions that end up realizing them in silicon. One of the agents that closes this gap is the <i>operating system</i>—a program that knows, among many other things, how to render text and draw graphics using pixel manipulations. We will discuss and write one such OS in part II of the book.</p>
</section>
<section>
<h3 class="head b-head"><span aria-label="76" id="pg_76" role="doc-pagebreak"/><b>4.2.7    Syntax Conventions and File Formats</b></h3>
<p class="noindent"><b>Binary code files</b>: By convention, programs written in the binary Hack language are stored in text files with a <samp class="SANS_Consolas_Regular_11">hack</samp> extension, for example, <samp class="SANS_Consolas_Regular_11">Prog.hack</samp>. Each line in the file codes a single binary instruction, using a sequence of sixteen <samp class="SANS_Consolas_Regular_11">0</samp> and <samp class="SANS_Consolas_Regular_11">1</samp> characters. Taken together, all the lines in the file represent a machine language program. The contract is as follows: When a machine language program is loaded into the computer’s instruction memory, the binary code appearing in the file’s <i>n</i>th line is stored at address <i>n</i> of the instruction memory. The counts of program lines, instructions, and memory addresses start at 0.</p>
<p class="STNI1"><b>Assembly language files</b>: By convention, programs written in the symbolic Hack assembly language are stored in text files with an <samp class="SANS_Consolas_Regular_11">asm</samp> extension, for example, <samp class="SANS_Consolas_Regular_11">Prog.asm</samp>. An assembly language file is composed of text lines, each being an <i>A</i>-instruction, a <i>C</i>-instruction, a label declaration, or a comment.</p>
<p>A label declaration is a text line of the form <samp class="SANS_Consolas_Regular_11">(</samp><i>symbol</i><samp class="SANS_Consolas_Regular_11">)</samp>. The assembler handles such a declaration by binding <i>symbol</i> to the address of the next instruction in the program. This is the only action that the assembler takes when handling a label declaration; no binary code is generated. That’s why label declarations are sometimes referred to as <i>pseudo-instructions</i>: they exist only at the symbolic level, generating no code.</p>
<p class="STNI1"><b>Constants and symbols</b>: These are the <i>xxx</i>’s in <i>A</i>-instructions of the form <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx</i>. <i>Constants</i> are nonnegative values from 0 to <img alt="" class="inline" height="15" src="../images/4-4.png" width="43"/> and are written in decimal notation. A <i>symbol</i> is any sequence of letters, digits, underscore (<samp class="SANS_Consolas_Regular_11">_</samp>), dot (<samp class="SANS_Consolas_Regular_11">.</samp>), dollar sign (<samp class="SANS_Consolas_Regular_11">$</samp>), and colon (<samp class="SANS_Consolas_Regular_11">:</samp>) that does not begin with a digit.</p>
<p class="STNI1"><b>Comments</b>: A text line beginning with two slashes (<samp class="SANS_Consolas_Regular_11">//</samp>) and ending at the end of the line is considered a comment and is ignored.</p>
<p class="STNI1"><b>White space</b>: Leading space characters and empty lines are ignored.</p>
<p class="STNI1"><b>Case conventions</b>: All the assembly mnemonics (<a href="chapter_4.html#fig4-5">figure 4.5</a>) must be written in uppercase. By convention, label symbols are written in uppercase, and variable symbols in lowercase. See <a href="chapter_4.html#fig4-4">figure 4.4</a> for examples.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>4.3    Hack Programming</b></h2>
<p class="noindent">We now turn to present three examples of low-level programming, using the Hack assembly language. Since project 4 focuses on writing Hack assembly programs, it will serve you well to carefully read and understand these examples.</p>
<p class="STNI1"><span aria-label="77" id="pg_77" role="doc-pagebreak"/><b>Example 1</b>: <a href="chapter_4.html#fig4-6" id="rfig4-6">Figure 4.6</a> shows a program that adds up the values of the first two RAM registers, adds 17 to the sum, and stores the result in the third RAM register. Before running the program, the user (or a test script) is expected to put some values in <samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp>.</p>
<figure class="IMG"><img alt="" id="fig4-6" src="../images/figure_4.6.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig4-6">Figure 4.6</a></b>    A Hack assembly program that computes a simple arithmetic expression.</p></figcaption>
</figure>
<p>Among other things, the program illustrates how the so-called virtual registers <samp class="SANS_Consolas_Regular_11">R0</samp>, <samp class="SANS_Consolas_Regular_11">R1</samp>, <samp class="SANS_Consolas_Regular_11">R2</samp>, <span class="ellipsis">…</span> can be used as working variables. The program also illustrates the recommended way of terminating Hack programs, which is staging and entering an infinite loop. In the absence of this infinite loop, the CPU’s fetch-execute logic (explained in the next chapter) will merrily glide forward, trying to execute whatever instructions are stored in the computer’s memory following the last instruction in the current program. This may lead to unpredictable and potentially hazardous consequences. The deliberate infinite loop serves to control and contain the CPU’s operation after completing the program’s execution.</p>
<p class="STNI1"><b>Example 2</b>: The second example computes the sum <img alt="" class="inline" height="14" src="../images/4-5.png" width="113"/> where <i>n</i> is the value of the first RAM register, and puts the sum in the second RAM register. This program is shown in <a href="chapter_4.html#fig4-4">figure 4.4</a>, and now we have what it takes to understand it fully.</p>
<p>Among other things, this program illustrates the use of symbolic variables—in this case <samp class="SANS_Consolas_Regular_11">i</samp> and <samp class="SANS_Consolas_Regular_11">sum</samp>. The example also illustrates our recommended practice for low-level program development: instead of writing assembly code directly, start by writing goto-oriented pseudocode. Next, test your pseudocode on paper, tracing the values of key variables. When convinced that the program’s logic is correct, and that it does what it’s supposed to do, proceed to express each pseudo-instruction as one or more assembly instructions.</p>
<p><span aria-label="78" id="pg_78" role="doc-pagebreak"/>The virtues of writing and debugging symbolic (rather than physical) instructions were observed by the gifted mathematician and writer Augusta Ada King-Noel, Countess of Lovelace, back in 1843. This important insight has contributed to her lasting fame as history’s first programmer. Before Ada Lovelace, proto-programmers who worked with early mechanical computers were reduced to tinkering with machine operations directly, and coding was hard and error prone. What was true in 1843 about symbolic and physical programming is equally true today about pseudo and assembly programming: When it comes to nontrivial programs, writing and testing pseudocode and then translating it into assembly instructions is easier and safer than writing assembly code directly.</p>
<p class="STNI1"><b>Example 3</b>: Consider the high-level array processing idiom <samp class="SANS_Consolas_Regular_11">for</samp> <img alt="" class="inline" height="11" src="../images/4-C16.png" width="58"/> <samp class="SANS_Consolas_Regular_11">{</samp>do something with <samp class="SANS_Consolas_Regular_11">arr[i]}</samp>. If we wish to express this logic in assembly, then our first challenge is that the array abstraction does not exist in machine language. However, if we know the base address of the array in the RAM, we can readily implement this logic in assembly, using pointer-based access to the array elements.</p>
<p>To illustrate the notion of a pointer, suppose that variable <samp class="SANS_Consolas_Regular_11">x</samp> contains the value 523, and consider the two possible pseudo-instructions <img alt="" class="inline" height="10" src="../images/4-C17.png" width="33"/> and <samp class="SANS_Consolas_Regular_11">*<img alt="" class="inline" height="10" src="../images/4-C18.png" width="33"/></samp> (of which we execute only one). The first instruction sets the value of <samp class="SANS_Consolas_Regular_11">x</samp> to 17. The second instruction informs that <samp class="SANS_Consolas_Regular_11">x</samp> is to be treated as a <i>pointer</i>, that is, a variable whose value is interpreted as a memory address. Hence, the instruction ends up setting <samp class="SANS_Consolas_Regular_11-SC">RAM[523]</samp> to 17, leaving the value of <samp class="SANS_Consolas_Regular_11">x</samp> intact.</p>
<p>The program in <a href="chapter_4.html#fig4-7" id="rfig4-7">figure 4.7</a> illustrates pointer-based array processing in the Hack machine language. The key instructions of interest are <img alt="" class="inline" height="12" src="../images/4-C19.png" width="50"/> followed by <img alt="" class="inline" height="10" src="../images/4-C20.png" width="38"/> In the Hack language, the basic pointer-processing idiom is implemented by an instruction of the form <samp class="SANS_Consolas_Regular_11">A</samp><span class="code_eq-symb">=</span><span class="ellipsis">…</span>, followed by a <i>C</i>-instruction that operates on <samp class="SANS_Consolas_Regular_11">M</samp> (which stands for <samp class="SANS_Consolas_Regular_11-SC">RAM[A]</samp>, the memory location selected by A). As we will see when we write the compiler in the second part of the book, this humble low-level programming idiom enables implementing, in Hack assembly, any array access or object-based get/set operation expressed in any high-level language.</p>
<figure class="IMG"><img alt="" id="fig4-7" src="../images/figure_4.7.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig4-7">Figure 4.7</a></b>    Array processing example, using pointer-based access to array elements.</p></figcaption>
</figure>
</section>
<section>
<h2 class="head a-head"><b>4.4    Project</b></h2>
<p class="noindent"><b>Objective</b>: Acquire a taste of low-level programming, and get acquainted with the Hack computer system. This will be done by writing and executing two low-level programs, written in the Hack assembly language.</p>
<p class="STNI1"><b>Resources</b>: The only resources required to complete the project are the Hack <i>CPU emulator</i>, available in <samp class="SANS_Consolas_Regular_11">nand2tetris/tools</samp>, and the test scripts described below, available in the <samp class="SANS_Consolas_Regular_11">projects/04</samp> folder.</p>
<p class="STNI1"><b>Contract</b>: Write and test the two programs described below. When executed on the supplied CPU emulator, your programs should realize the described behaviors.</p>
<p class="STNI1"><span aria-label="79" id="pg_79" role="doc-pagebreak"/><b>Multiplication (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">Mult.asm</samp>)</b>: The inputs of this program are the values stored in <samp class="SANS_Consolas_Regular_11">R0</samp> and <samp class="SANS_Consolas_Regular_11">R1</samp> (<samp class="SANS_Consolas_Regular_11-SC">RAM[0]</samp> and <samp class="SANS_Consolas_Regular_11-SC">RAM[1]</samp>). The program computes the product <img alt="" class="inline" height="10" src="../images/4-C20b.png" width="45"/> and stores the result in <samp class="SANS_Consolas_Regular_11">R2</samp>. Assume that <img alt="" class="inline" height="14" src="../images/4-C20a.png" width="223"/> (your program need not test these assertions). The supplied <samp class="SANS_Consolas_Regular_11">Mult.tst</samp> and <samp class="SANS_Consolas_Regular_11">Mult.cmp</samp> scripts are designed to test your program on representative data values.</p>
<p class="STNI1"><b>I/O handling (<samp class="SANS_Helvetica_LT_Std_Bold_B_11-sm">Fill.asm</samp>)</b>: This program runs an infinite loop that listens to the keyboard. When a key is pressed (any key), the program blackens the screen by writing <i>black</i> in every pixel. When no key is pressed, the program clears the screen by writing <i>white</i> in every pixel. You may choose to blacken and clear the screen in any spatial pattern, as long as pressing a key continuously for long enough will result in a fully blackened screen, and not pressing any key for long enough will result in a cleared screen. This program has a test script (<samp class="SANS_Consolas_Regular_11">Fill.tst</samp>) but no compare file—it should be checked by visibly inspecting the simulated screen in the CPU emulator.</p>
<p class="STNI1"><span aria-label="80" id="pg_80" role="doc-pagebreak"/><b>CPU emulator</b>: This program, available in <samp class="SANS_Consolas_Regular_11">nand2tetris/tools</samp>, provides a visual simulation of the Hack computer (see <a href="chapter_4.html#fig4-8" id="rfig4-8">figure 4.8</a>). The program’s GUI shows the current states of the computer’s instruction memory (ROM), data memory (RAM), the two registers <samp class="SANS_Consolas_Regular_11">A</samp> and <samp class="SANS_Consolas_Regular_11">D</samp>, the program counter <samp class="SANS_Consolas_Regular_11">PC</samp>, and the <samp class="SANS_Consolas_Regular_11">ALU</samp>. It also displays the current state of the computer’s screen and allows entering inputs through the keyboard.</p>
<figure class="IMG"><img alt="" id="fig4-8" src="../images/figure_4.8.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig4-8">Figure 4.8</a></b>    The CPU emulator, with a program loaded in the instruction memory (ROM) and some data in the data memory (RAM). The figure shows a snapshot taken during the program’s execution.</p></figcaption>
</figure>
<p>The typical way to use the CPU emulator is to load a machine language program into the ROM, execute the code, and observe its impact on the simulated hardware elements. Importantly, the CPU emulator enables loading binary<samp class="SANS_Consolas_Regular_11">.hack</samp> files as well as symbolic <samp class="SANS_Consolas_Regular_11">.asm</samp> files, written in the Hack assembly language. In the latter case, the emulator translates the assembly program into binary code on the fly. Conveniently, the loaded code can be viewed in both its binary and symbolic representations.</p>
<p>Since the supplied CPU emulator features a built-in assembler, there is no need to use a standalone Hack assembler in this project.</p>
<p class="STNI1"><b>Steps</b>: We recommend proceeding as follows:</p>
<p class="NLF"><span class="nl">0.</span>  The supplied CPU emulator is available in the <samp class="SANS_Consolas_Regular_11">nand2tetris/tools</samp> folder. If you need help, consult the tutorial available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
<p class="NL"><span class="nl">1.  </span>Write/edit the <samp class="SANS_Consolas_Regular_11">Mult.asm</samp> program using a plain text editor. Start with the skeletal program stored in <samp class="SANS_Consolas_Regular_11">projects/04/mult/Mult.asm</samp>.</p>
<p class="NL"><span class="nl">2.  </span>Load <samp class="SANS_Consolas_Regular_11">Mult.asm</samp> into the CPU emulator. This can be done either interactively or by loading and executing the supplied <samp class="SANS_Consolas_Regular_11">Mult.tst</samp> script.</p>
<p class="NL"><span class="nl">3.  </span>Run the script. If you get any translation or run-time errors, go to step 1.</p>
<p class="NL">Follow steps 1–3 for writing the second program, using the <samp class="SANS_Consolas_Regular_11">projects/04/fill</samp> folder.</p>
<p class="STNI1"><b>Debugging tip</b>: The Hack language is case-sensitive. A common assembly programming error occurs when one writes, say, <samp class="SANS_Consolas_Regular_11">@foo</samp> and <samp class="SANS_Consolas_Regular_11">@Foo</samp> in different parts of the program, thinking that both instructions refer to the same symbol. In fact, the assembler will generate and manage two variables that have nothing in common.</p>
<p class="STNI1"><b>A web-based version of project 4</b> is available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
</section>
<section>
<h2 class="head a-head"><b>4.5    Perspective</b></h2>
<p class="noindent">The Hack machine language is basic. Typical machine languages feature more operations, more data types, more registers, and more instruction formats. In terms of syntax, we have chosen to give Hack a lighter look and feel than that of conventional assembly languages. In particular, we have chosen a friendly syntax for the <i>C</i>-instruction, for example, <img alt="" class="inline" height="12" src="../images/4-C21.png" width="48"/> instead of the more common prefix syntax <samp class="SANS_Consolas_Regular_11">add</samp> <samp class="SANS_Consolas_Regular_11">M,D</samp> used in many machine languages. The <span aria-label="81" id="pg_81" role="doc-pagebreak"/>reader should note, however, that this is just a syntax effect. For example, the <span class="symb-code">+</span> character in the operation code <img alt="" class="inline" height="10" src="../images/4-C21a.png" width="26"/> plays no algebraic role whatsoever. Rather, the three-character string <img alt="" class="inline" height="10" src="../images/4-C21a.png" width="26"/>, taken as a whole, is treated as a single assembly mnemonic, designed to code a single ALU operation.</p>
<p>One of the main characteristics that gives machine languages their particular flavor is the number of memory addresses that can be squeezed into a single instruction. In this respect, the austere Hack language may be described as a 1/2 <i>address</i> machine language: Since there is no room to pack both an instruction code and a 15-bit address in a single 16-bit instruction, operations involving memory access require two Hack instructions: one for specifying the address on which we wish to operate, and one for specifying the operation. In comparison, many machine languages can specify an operation and at least one address in every machine instruction.</p>
<p>Indeed, Hack assembly code typically ends up being mostly an alternating sequence of <i>A</i>- and <i>C</i>-instructions: <samp class="SANS_Consolas_Regular_11">@sum</samp> followed by <img alt="" class="inline" height="12" src="../images/4-C22.png" width="29"/> <samp class="SANS_Consolas_Regular_11">@LOOP</samp> followed by <samp class="SANS_Consolas_Regular_11">0;JMP</samp>, and so on. If you find this coding style tedious or peculiar, you should note that friendlier <i>macro-instructions</i> like <img alt="" class="inline" height="10" src="../images/4-C23.png" width="40"/> and <samp class="SANS_Consolas_Regular_11">goto</samp> <samp class="SANS_Consolas_Regular_11">LOOP</samp> can be easily introduced into the language, making Hack assembly code shorter and more readable. The trick is to extend the assembler to translate each macro-instruction into the two Hack instructions that it entails—a relatively simple tweak.</p>
<p><span aria-label="82" id="pg_82" role="doc-pagebreak"/>The <i>assembler</i>, mentioned many times in this chapter, is the program responsible for translating symbolic assembly programs into executable programs written in binary code. In addition, the assembler is responsible for managing all the system- and user-defined symbols found in the assembly program and for resolving them into physical memory addresses that are injected into the generated binary code. We will return to this translation task in chapter 6, which is dedicated to understanding and building assemblers.</p>
<hr class="HorizontalRule-1"/>
<ol class="footnotes">
<li><p class="FN" role="doc-footnote"><span class="fnnum"><a href="#footnote-001-backlink" id="footnote-001">1</a></span>.  By <i>instantaneously</i> we mean within the same clock cycle, or time unit.</p></li>
</ol>
</section>
</section>
</div>
</body>
</html>