<html lang="en">
<head>
<title>6 Assembler</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:28e15094-8b6c-42d2-9184-6ba334c47321" name="Adept.expected.resource"/>
</head>
<body>
<div class="body">
<p class="sp"> </p>
<section aria-labelledby="ch6"role="doc-chapter">
<header>
<p class="bor-top"/>
<h1 class="chapter-number" id="ch6"><span aria-label="103" id="pg_103" role="doc-pagebreak"/><samp class="SANS_Helvetica_LT_Std_Bold_B_11">6</samp>       <samp class="SANS_Helvetica_LT_Std_Bold_B_11">Assembler</samp></h1>
</header>
<blockquoterole="doc-epigraph">
<p class="EP1">What’s in a name? That which we call a rose by any other name would smell as sweet.</p>
<p class="EPA1">—Shakespeare, <i>Romeo and Juliet</i></p>
</blockquote>
<p class="noindent">In the previous chapters, we completed the development of a hardware platform designed to run programs in the Hack machine language. We presented two versions of this language—symbolic and binary—and explained that symbolic programs can be translated into binary code using a program called an <i>assembler</i>. In this chapter we describe how assemblers work, and how they are built. This will lead to the construction of a <i>Hack assembler</i>—a program that translates programs written in the Hack symbolic language into binary code that can execute on the barebone Hack hardware.</p>
<p>Since the relationship between symbolic instructions and their corresponding binary codes is straightforward, implementing an assembler using a high-level programming language is not a difficult task. One complication arises from allowing assembly programs to use symbolic references to memory addresses. The assembler is expected to manage these symbols and resolve them to physical memory addresses. This task is normally done using a <i>symbol table</i>—a commonly used data structure.</p>
<p>Implementing the assembler is the first in a series of seven software development projects that accompany part II of the book. Developing the assembler will equip you with a basic set of general skills that will serve you well throughout all these projects and beyond: handling command-line arguments, handling input and output text files, parsing instructions, handling white space, handling symbols, generating code, and many other techniques that come into play in many software development projects.</p>
<p>If you have no programming experience, you can develop a paper-based assembler. This option is described in the web-based version of project 6, available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
<section>
<h2 class="head a-head"><b>6.1    Background</b></h2>
<p class="noindent">Machine languages are typically specified in two flavors: <i>binary</i> and <i>symbolic</i>. A binary instruction, for example, <samp class="SANS_Consolas_Regular_11">11000010000000110000000000000111</samp>, is an agreed-upon <span aria-label="104" id="pg_104" role="doc-pagebreak"/>package of micro-codes designed to be decoded and executed by some target hardware platform. For example, the instruction’s leftmost 8 bits, <samp class="SANS_Consolas_Regular_11">11000010</samp>, can represent an operation like “load.” The next 8 bits, <samp class="SANS_Consolas_Regular_11">00000011</samp>, can represent a register, say <samp class="SANS_Consolas_Regular_11">R3</samp>. The remaining 16 bits, <samp class="SANS_Consolas_Regular_11">0000000000000111</samp>, can represent a value, say 7. When we set out to build a hardware architecture and a machine language, we can decide that this particular 32-bit instruction will cause the hardware to effect the operation “load the constant 7 into register <samp class="SANS_Consolas_Regular_11">R3</samp>.” Modern computer platforms support hundreds of such possible operations. Thus, machine languages can be complex, involving many operation codes, memory addressing modes, and instruction formats.</p>
<p>Clearly, specifying these operations in binary code is a pain. A natural solution is using an agreed-upon equivalent symbolic syntax, say, “<samp class="SANS_Consolas_Regular_11">load</samp> <samp class="SANS_Consolas_Regular_11">R3,7</samp>”. The <samp class="SANS_Consolas_Regular_11">load</samp> operation code is sometimes called a <i>mnemonic</i>, which in Latin means a pattern of letters designed to help with remembering something. Since the translation from mnemonics and symbols to binary code is straightforward, it makes sense to write low-level programs directly in symbolic notation and have a computer program translate them into binary code. The symbolic language is called <i>assembly</i>, and the translator program <i>assembler</i>. The assembler parses each assembly instruction into its underlying fields, for example, <samp class="SANS_Consolas_Regular_11">load</samp>, <samp class="SANS_Consolas_Regular_11">R3</samp>, and <samp class="SANS_Consolas_Regular_11">7</samp>, translates each field into its equivalent binary code, and finally assembles the generated bits into a binary instruction that can be executed by the hardware. Hence the name <i>assembler</i>.</p>
<p class="STNI1"><b>Symbols</b>: Consider the symbolic instruction <samp class="SANS_Consolas_Regular_11">goto</samp> <samp class="SANS_Consolas_Regular_11">312</samp>. Following translation, this instruction causes the computer to fetch and execute the instruction stored in address <samp class="SANS_Consolas_Regular_11">312</samp>, which may be the beginning of some loop. Well, if it’s the beginning of a loop, why not mark this point in the assembly program with a descriptive label, say <samp class="SANS_Consolas_Regular_11">LOOP</samp>, and use the command <samp class="SANS_Consolas_Regular_11">goto</samp> <samp class="SANS_Consolas_Regular_11">LOOP</samp> instead of <samp class="SANS_Consolas_Regular_11">goto</samp> <samp class="SANS_Consolas_Regular_11">312</samp>? All we have to do is record somewhere that <samp class="SANS_Consolas_Regular_11">LOOP</samp> stands for <samp class="SANS_Consolas_Regular_11">312</samp>. When we translate the program into binary code, we replace each occurrence of <samp class="SANS_Consolas_Regular_11">LOOP</samp> with <samp class="SANS_Consolas_Regular_11">312</samp>. That’s a small price to pay for the gain in program readability and portability.</p>
<p class="STNI1">In general, assembly languages use symbols for three purposes:</p>
<ul class="List-1">
<li class="BLF"><i>Labels</i>: Assembly programs can declare and use symbols that mark various locations in the code, for example, <samp class="SANS_Consolas_Regular_11">LOOP</samp> and <samp class="SANS_Consolas_Regular_11">END</samp>.</li>
<li class="BL1"><i>Variables</i>: Assembly programs can declare and use symbolic variables, for example, <samp class="SANS_Consolas_Regular_11">i</samp> and <samp class="SANS_Consolas_Regular_11">sum</samp>.</li>
<li class="BLL1"><i>Predefined symbols</i>: Assembly programs can refer to special addresses in the computer’s memory using agreed-upon symbols, for example, <samp class="SANS_Consolas_Regular_11">SCREEN</samp> and <samp class="SANS_Consolas_Regular_11">KBD</samp>.</li>
</ul>
<p class="TNI1">Of course, there is no free lunch. Someone must be responsible for managing all these symbols. In particular, someone must remember that <samp class="SANS_Consolas_Regular_11">SCREEN</samp> stands for <samp class="SANS_Consolas_Regular_11">16384</samp>, that <samp class="SANS_Consolas_Regular_11">LOOP</samp> stands for <samp class="SANS_Consolas_Regular_11">312</samp>, that <samp class="SANS_Consolas_Regular_11">sum</samp> stands for some other address, and so on. This symbol-handling task is one of the most important functions of the assembler.</p>
<p class="STNI1"><span aria-label="105" id="pg_105" role="doc-pagebreak"/><b>Example</b>: <a href="chapter_6.html#fig6-1" id="rfig6-1">Figure 6.1</a> lists two versions of the same program written in the Hack machine language. The symbolic version includes all sorts of things that humans are fond of seeing in computer programs: comments, white space, indentation, symbolic instructions, and symbolic references. None of these embellishments concern computers, which understand one thing only: bits. The agent that bridges the gap between the symbolic code convenient for humans and the binary code understood by the computer is the assembler.</p>
<figure class="IMG"><img alt="" id="fig6-1" src="../images/figure_6.1.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig6-1">Figure 6.1</a></b>    Assembly code, translated to binary code using a symbol table. The line numbers, which are not part of the code, are listed for reference.</p></figcaption>
</figure>
<p>Let us ignore for now all the details in <a href="chapter_6.html#fig6-1">figure 6.1</a>, as well as the symbol table, and make some general observations. First, note that although the line numbers are not part of the code, they play an important, albeit implicit, role in the translation process. If the binary code will be loaded into the instruction memory starting at address 0, then the line number of each instruction will coincide with its memory address. Clearly, this observation should be of interest to the assembler. Second, note that comments and label declarations generate no code, and that’s why the latter are sometimes called <i>pseudo-instructions</i>. Finally, and stating the obvious, note that in order to write an assembler for some machine language, the assembler’s developer must get a complete specification of the language’s symbolic and binary syntax.</p>
<p>With that in mind, we now turn to specify the Hack machine language.</p>
</section>
<section>
<h2 class="head a-head"><span aria-label="106" id="pg_106" role="doc-pagebreak"/><b>6.2    The Hack Machine Language Specification</b></h2>
<p class="noindent">The Hack assembly language and its equivalent binary representation were described in chapter 4. The language specification is repeated here for ease of reference. This specification is the contract that Hack assemblers must implement, one way or another.</p>
<section>
<h3 class="head b-head"><b>6.2.1    Programs</b></h3>
<p class="noindent"><b>Binary Hack program</b>: A binary Hack program is a sequence of text lines, each consisting of sixteen <samp class="SANS_Consolas_Regular_11">0</samp> and <samp class="SANS_Consolas_Regular_11">1</samp> characters. If the line starts with a <samp class="SANS_Consolas_Regular_11">0</samp>, it represents a binary <i>A</i>-instruction. Otherwise, it represents a binary <i>C</i>-instruction.</p>
<p class="STNI1"><b>Assembly Hack program</b>: An assembly Hack program is a sequence of text lines, each being an <i>assembly instruction</i>, a <i>label declaration</i>, or a <i>comment</i>:</p>
<ul class="List-1">
<li class="BLF"><i>Assembly instruction</i>: A symbolic <i>A</i>-instruction or a symbolic <i>C</i>-instruction (see <a href="chapter_6.html#fig6-2" id="rfig6-2">figure 6.2</a>).</li>
<li class="BL1"><i>Label declaration</i>: A line of the form <samp class="SANS_Consolas_Regular_11">(</samp><i>xxx</i><samp class="SANS_Consolas_Regular_11">)</samp>, where <i>xxx</i> is a symbol.</li>
<li class="BL1"><i>Comment</i>: A line beginning with two slashes (<samp class="SANS_Consolas_Regular_11">//</samp>) is considered a comment and is ignored.</li>
</ul>
<figure class="IMG"><img alt="" id="fig6-2" src="../images/figure_6.2.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig6-2">Figure 6.2</a></b>    The Hack instruction set, showing both symbolic mnemonics and their corresponding binary codes.</p></figcaption>
</figure>
</section>
<section>
<h3 class="head b-head"><b>6.2.2    Symbols</b></h3>
<p class="noindent">Symbols in Hack assembly programs fall into three categories: predefined symbols, label symbols, and variable symbols.</p>
<p class="STNI1"><b>Predefined symbols</b>: Any Hack assembly program is allowed to use predefined symbols, as follows. <samp class="SANS_Consolas_Regular_11">R0</samp>, <samp class="SANS_Consolas_Regular_11">R1</samp>, <span class="ellipsis">…</span>, <samp class="SANS_Consolas_Regular_11">R15</samp> stand for 0, 1, <span class="ellipsis">…</span> 15, respectively. <samp class="SANS_Consolas_Regular_11">SP</samp>, <samp class="SANS_Consolas_Regular_11">LCL</samp>, <samp class="SANS_Consolas_Regular_11">ARG</samp>, <samp class="SANS_Consolas_Regular_11">THIS</samp>, <samp class="SANS_Consolas_Regular_11">THAT</samp> stand for 0, 1, 2, 3, 4, respectively. <samp class="SANS_Consolas_Regular_11">SCREEN</samp> and <samp class="SANS_Consolas_Regular_11">KBD</samp> stand for 16384 and 24576, respectively. The values of these symbols are interpreted as addresses in the Hack RAM.</p>
<p class="STNI1"><b>Label symbols</b>: The pseudo-instruction <samp class="SANS_Consolas_Regular_11">(</samp><i>xxx</i><samp class="SANS_Consolas_Regular_11">)</samp> defines the symbol <i>xxx</i> to refer to the location in the Hack ROM holding the next instruction in the program. A label symbol can be defined once and can be used anywhere in the assembly program, even before the line in which it is defined.</p>
<p class="STNI1"><b>Variable symbols</b>: Any symbol <i>xxx</i> appearing in an assembly program that is not predefined and is not defined elsewhere by a label declaration <samp class="SANS_Consolas_Regular_11">(</samp><i>xxx</i><samp class="SANS_Consolas_Regular_11">)</samp> is treated as a variable. Variables are mapped to consecutive RAM locations as they are first encountered, starting at RAM address 16. Thus, the first variable encountered in a program is mapped to <samp class="SANS_Consolas_Regular_11-SC">RAM[16]</samp>, the second to <samp class="SANS_Consolas_Regular_11-SC">RAM[17]</samp>, and so on.</p>
</section>
<section>
<h3 class="head b-head"><span aria-label="107" id="pg_107" role="doc-pagebreak"/><b>6.2.3    Syntax Conventions</b></h3>
<p class="noindent"><b>Symbols</b>: A <i>symbol</i> can be any sequence of letters, digits, underscore (<samp class="SANS_Consolas_Regular_11">_</samp>), dot (<samp class="SANS_Consolas_Regular_11">.</samp>), dollar sign (<samp class="SANS_Consolas_Regular_11">$</samp>), and colon (<samp class="SANS_Consolas_Regular_11">:</samp>) that does not begin with a digit.</p>
<p class="STNI1"><b>Constants</b>: May appear only in <i>A</i>-instructions of the form <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx.</i> The constant <i>xxx</i> is a value in the range 0–32767 and is written in decimal notation.</p>
<p class="STNI1"><b>White space</b>: Leading space characters and empty lines are ignored.</p>
<p class="STNI1"><b>Case conventions</b>: All the assembly mnemonics (like <img alt="" class="inline" height="12" src="../images/6-C1.png" width="30"/> <samp class="SANS_Consolas_Regular_11">JEQ</samp>, and so on) must be written in uppercase. The remaining symbols—labels and variable names—are case-sensitive. The recommended convention is to use uppercase for labels and lowercase for variables.</p>
<p class="STNI1">This completes the Hack machine language specification.</p>
</section>
</section>
<section>
<h2 class="head a-head"><span aria-label="108" id="pg_108" role="doc-pagebreak"/><b>6.3    Assembly-to-Binary Translation</b></h2>
<p class="noindent">This section describes how to translate Hack assembly programs into binary code. Although we focus on developing an assembler for the Hack language, the techniques that we present are applicable to any assembler.</p>
<p>The assembler takes as input a stream of assembly instructions and generates as output a stream of translated binary instructions. The resulting code can be loaded as is into the computer memory and executed. In order to carry out the translation process, the assembler must handle instructions and symbols.</p>
<section>
<h3 class="head b-head"><b>6.3.1    Handling Instructions</b></h3>
<p class="noindent">For each assembly instruction, the assembler</p>
<ul class="List-1">
<li class="BLF">parses the instruction into its underlying fields;</li>
<li class="BL1">for each field, generates the corresponding bit-code, as specified in <a href="chapter_6.html#fig6-2">figure 6.2</a>;</li>
<li class="BL1">if the instruction contains a symbolic reference, resolves the symbol into its numeric value;</li>
<li class="BL1">assembles the resulting binary codes into a string of sixteen <samp class="SANS_Consolas_Regular_11">0</samp> and <samp class="SANS_Consolas_Regular_11">1</samp> characters; and</li>
<li class="BL1">writes the assembled string to the output file.</li>
</ul>
</section>
<section>
<h3 class="head b-head"><b>6.3.2    Handling Symbols</b></h3>
<p class="noindent">Assembly programs are allowed to use symbolic labels (destinations of goto instructions) before the symbols are defined. This convention makes the life of assembly code writers easier and that of assembler developers harder. A common solution is to develop a <i>two-pass assembler</i> that reads the code twice, from start to end. In the first pass, the assembler builds a <i>symbol table</i>, adds all the label symbols to the table, and generates no code. In the second pass, the assembler handles the variable symbols and generates binary code, using the symbol table. Here are the details.</p>
<p class="STNI1"><b>Initialization</b>: The assembler creates a symbol table and initializes it with all the predefined symbols and their pre-allocated values. In <a href="chapter_6.html#fig6-1">figure 6.1</a>, the result of the initialization stage is the symbol table with all the symbols up to, and including, <samp class="SANS_Consolas_Regular_11">KBD</samp>.</p>
<p class="STNI1"><b>First pass</b>: The assembler goes through the entire assembly program, line by line, keeping track of the line number. This number starts at 0 and is incremented by 1 whenever an <i>A</i>-instruction or a <i>C</i>-instruction is encountered, but does not change when a comment or a label declaration is encountered. Each time a label declaration <samp class="SANS_Consolas_Regular_11">(</samp><i>xxx</i><samp class="SANS_Consolas_Regular_11">)</samp> is encountered, the <span aria-label="109" id="pg_109" role="doc-pagebreak"/>assembler adds a new entry to the symbol table, associating the symbol <i>xxx</i> with the current line number plus 1 (this will be the ROM address of the next instruction in the program).</p>
<p>This pass results in adding to the symbol table all the program’s label symbols, along with their corresponding values. In <a href="chapter_6.html#fig6-1">figure 6.1</a>, the first pass results in adding the symbols <samp class="SANS_Consolas_Regular_11">LOOP</samp> and <samp class="SANS_Consolas_Regular_11">STOP</samp> to the symbol table. No code is generated during the first pass.</p>
<p class="STNI1"><b>Second pass</b>: The assembler goes again through the entire program and parses each line as follows. Each time an <i>A</i>-instruction with a symbolic reference is encountered, namely, <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx</i>, where <i>xxx</i> is a symbol and not a number, the assembler looks up <i>xxx</i> in the symbol table. If the symbol is found, the assembler replaces it with its numeric value and completes the instruction’s translation. If the symbol is not found, then it must represent a new variable. To handle it, the assembler (i) adds the entry <span class="symb">&lt;</span><i>xxx</i>, <i>value</i><span class="symb">&gt;</span> to the symbol table, where <i>value</i> is the next available address in the RAM space designated for variables, and (ii) completes the instruction’s translation, using this address. In the Hack platform, the RAM space designated for storing variables starts at 16 and is incremented by 1 after each time a new variable is found in the code. In <a href="chapter_6.html#fig6-1">figure 6.1</a>, the second pass results in adding the symbols <samp class="SANS_Consolas_Regular_11">i</samp> and <samp class="SANS_Consolas_Regular_11">sum</samp> to the symbol table.</p>
</section>
</section>
<section>
<h2 class="head a-head"><b>6.4    Implementation</b></h2>
<p class="noindent"><b>Usage</b>: The Hack assembler accepts a single command-line argument, as follows,</p>
<p class="COM2"><samp class="SANS_Consolas_Regular_11">prompt</samp><span class="symb">&gt;</span> <samp class="SANS_Consolas_Regular_11">HackAssembler</samp> <i>Prog.</i><samp class="SANS_Consolas_Regular_11">asm</samp></p>
<p class="noindent">where the input file <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> contains assembly instructions (the <samp class="SANS_Consolas_Regular_11">.asm</samp> extension is mandatory). The file name may contain a file path. If no path is specified, the assembler operates on the current folder. The assembler creates an output file named <i>Prog</i><samp class="SANS_Consolas_Regular_11">.hack</samp> and writes the translated binary instructions into it. The output file is created in the same folder as the input file. If there is a file by this name in the folder, it will be overwritten.</p>
<p>We propose dividing the assembler implementation into two stages. In the first stage, develop a basic assembler for Hack programs that contain no symbolic references. In the second stage, extend the basic assembler to handle symbolic references.</p>
<section>
<h3 class="head b-head"><b>6.4.1    Developing a Basic Assembler</b></h3>
<p class="noindent">The basic assembler assumes that the source code contains no symbolic references. Therefore, except for handling comments and white space, the assembler has to translate either <i>C</i>-instructions or <i>A</i>-instructions of the form <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx</i>, where <i>xxx</i> is a decimal value (and not a symbol). This translation task is straightforward: each mnemonic component (field) of <span aria-label="110" id="pg_110" role="doc-pagebreak"/>a symbolic <i>C</i>-instruction is translated into its corresponding bit code, according to <a href="chapter_6.html#fig6-2">figure 6.2</a>, and each decimal constant <i>xxx</i> in a symbolic <i>A</i>-instruction is translated into its equivalent binary code.</p>
<p>We propose basing the assembler on a software architecture consisting of a <i>Parser</i> module for parsing the input into instructions and instructions into fields, a <i>Code</i> module for translating the fields (symbolic mnemonics) into binary codes, and a <i>Hack assembler</i> program that drives the entire translation process. Before proceeding to specify the three modules, we wish to make a note about the style that we use to describe these specifications.</p>
<p class="STNI1"><b>API documentation</b>: The development of the Hack assembler is the first in a series of seven software construction projects that follow in part II of the book. Each one of these projects can be developed independently, using any high-level programming language. Therefore, our API documentation style makes no assumptions on the implementation language.</p>
<p>In each project, starting with this one, we propose an API consisting of several <i>modules</i>. Each module documents one or more <i>routines</i>. In a typical object-oriented language, a module corresponds to a <i>class</i>, and a routine corresponds to a <i>method</i>. In other languages, a module may correspond to a <i>file</i>, and a routine to a <i>function</i>. Whichever language you use for implementing the software projects, starting with the assembler, there should be no problem mapping the <i>modules</i> and <i>routines</i> of our proposed APIs on the programming elements of your implementation language.</p>
</section>
<section>
<h3 class="head b-head"><b>The Parser</b></h3>
<p class="noindent">The Parser encapsulates access to the input assembly code. In particular, it provides a convenient means for advancing through the source code, skipping comments and white space, and breaking each symbolic instruction into its underlying components.</p>
<p>Although the basic version of the assembler is not required to handle symbolic references, the Parser that we specify below does. In other words, the Parser specified here serves both the basic assembler and the complete assembler.</p>
<p>The Parser ignores comments and white space in the input stream, enables accessing the input one line at a time, and parses symbolic instructions into their underlying components.</p>
<p>The Parser API is listed on the next page. Here are some examples of how the Parser services can be used. If the current instruction is <samp class="SANS_Consolas_Regular_11">@17</samp> or <samp class="SANS_Consolas_Regular_11">@sum</samp>, a call to <samp class="SANS_Consolas_Regular_11">symbol()</samp> would return the string <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">17</samp><samp class="SANS_Consolas_Regular_11">"</samp> or <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">sum</samp><samp class="SANS_Consolas_Regular_11">"</samp>, respectively. If the current instruction is <samp class="SANS_Consolas_Regular_11">(LOOP)</samp>, a call to <samp class="SANS_Consolas_Regular_11">symbol()</samp> would return the string <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">LOOP</samp><samp class="SANS_Consolas_Regular_11">"</samp>. If the current instruction is <img alt="" class="inline" height="12" src="../images/6-C2.png" width="80"/> a call to <samp class="SANS_Consolas_Regular_11">dest</samp> <samp class="SANS_Consolas_Regular_11">()</samp>, <samp class="SANS_Consolas_Regular_11">comp</samp> <samp class="SANS_Consolas_Regular_11">()</samp>, and <samp class="SANS_Consolas_Regular_11">jump</samp> <samp class="SANS_Consolas_Regular_11">()</samp> would return the strings <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">D</samp><samp class="SANS_Consolas_Regular_11">"</samp>, <samp class="SANS_Consolas_Regular_11">"</samp><img alt="" class="inline" height="13" src="../images/6-C3.png" width="36"/> and <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">JLE</samp><samp class="SANS_Consolas_Regular_11">"</samp>, respectively.</p>
<p>In project 6 you have to implement this API using some high-level programming language. In order to do so, you must be familiar with how this language handles text files, and strings.</p>
<span aria-label="111" id="pg_111" role="doc-pagebreak"/>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_6.1.png"/></figure>
</section>
<section>
<h3 class="head b-head"><b>The Code Module</b></h3>
<p class="noindent">This module provides services for translating symbolic Hack mnemonics into their binary codes. Specifically, it translates symbolic Hack mnemonics into their binary codes according to the language specifications (see <a href="chapter_6.html#fig6-2">figure 6.2</a>). Here is the API:</p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_6.2.png"/></figure>
<p><span aria-label="112" id="pg_112" role="doc-pagebreak"/>All the <i>n</i>-bit codes are returned as strings of <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">0</samp><samp class="SANS_Consolas_Regular_11">'</samp> and <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">1</samp><samp class="SANS_Consolas_Regular_11">'</samp> characters. For example, a call to <samp class="SANS_Consolas_Regular_11">dest</samp> <samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">DM</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp> returns the string <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">011</samp><samp class="SANS_Consolas_Regular_11">"</samp>, a call to <samp class="SANS_Consolas_Regular_11">comp</samp> <img alt="" class="inline" height="14" src="../images/6-C4.png" width="54"/> returns the string <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">0110111</samp><samp class="SANS_Consolas_Regular_11">"</samp>, a call to <samp class="SANS_Consolas_Regular_11">comp</samp> <img alt="" class="inline" height="14" src="../images/6-C5.png" width="51"/> returns the string <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">1110111</samp><samp class="SANS_Consolas_Regular_11">"</samp>, a call to <samp class="SANS_Consolas_Regular_11">jump</samp> <samp class="SANS_Consolas_Regular_11">(</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">JNE</samp><samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">)</samp> returns the string <samp class="SANS_Consolas_Regular_11">"</samp><samp class="SANS_Consolas_Regular_11">101</samp><samp class="SANS_Consolas_Regular_11">"</samp>, and so on. All these mnemonic-binary mappings are specified in <a href="chapter_6.html#fig6-2">figure 6.2</a>.</p>
</section>
<section>
<h3 class="head b-head"><b>The Hack Assembler</b></h3>
<p class="noindent">This is the main program that drives the entire assembly process, using the services of the Parser and Code modules. The basic version of the assembler (which we describe now) assumes that the source assembly code contains no symbolic references. This means that (i) in all instructions of type <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx</i>, the <i>xxx</i> constants are decimal numbers and not symbols and (ii) the input file contains no label instructions, that is, no instructions of the form <samp class="SANS_Consolas_Regular_11">(</samp><i>xxx</i><samp class="SANS_Consolas_Regular_11">)</samp>.</p>
<p>The basic assembler program can now be described as follows. The program gets the name of the input source file, say, <i>Prog</i>, from the command-line argument. It constructs a Parser for parsing the input file <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> and creates an output file, <i>Prog</i><samp class="SANS_Consolas_Regular_11">.hack</samp>, into which it will write the translated binary instructions. The program then enters a loop that iterates through the lines (assembly instructions) in the input file and processes them as follows.</p>
<p>For each <i>C</i>-instruction, the program uses the Parser and Code services for parsing the instruction into its fields and translating each field into its corresponding binary code. The program then assembles (concatenates) the translated binary codes into a string consisting of sixteen <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">0</samp><samp class="SANS_Consolas_Regular_11">'</samp> and <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">1</samp><samp class="SANS_Consolas_Regular_11">'</samp> characters and writes this string as the next line in the output <samp class="SANS_Consolas_Regular_11">.hack</samp> file.</p>
<p>For each <i>A</i>-instruction of type <samp class="SANS_Consolas_Regular_11">@</samp><i>xxx</i>, the program translates <i>xxx</i> into its binary representation, creates a string of sixteen <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">0</samp><samp class="SANS_Consolas_Regular_11">'</samp> and <samp class="SANS_Consolas_Regular_11">'</samp><samp class="SANS_Consolas_Regular_11">1</samp><samp class="SANS_Consolas_Regular_11">'</samp> characters, and writes it as the next line in the output <samp class="SANS_Consolas_Regular_11">.hack</samp> file.</p>
<p>We provide no API for this module, inviting you to implement it as you see fit.</p>
</section>
<section>
<h3 class="head b-head"><b>6.4.2    Completing the Assembler</b></h3>
</section>
<section>
<h3 class="head b-head"><b>The Symbol Table</b></h3>
<p class="TNI2">Since Hack instructions can contain symbolic references, the assembly process must resolve them into actual addresses. The assembler deals with this task using a <i>symbol table</i>, designed to create and maintain the correspondence between symbols and their meaning (in Hack’s case, RAM and ROM addresses).</p>
<p>A natural means for representing this <span class="symb">&lt;</span><i>symbol, address</i><span class="symb">&gt;</span> mapping is any data structure designed to handle <span class="symb">&lt;</span><i>key, value</i><span class="symb">&gt;</span> pairs. Every modern high-level programming language features such a ready-made abstraction, typically called a <i>hash table</i>, <i>map</i>, <i>dictionary</i>, among other names. You can either implement the symbol table from scratch or customize one of these data structures. Here is the SymbolTable API:<span aria-label="113" id="pg_113" role="doc-pagebreak"/></p>
<figure class="IMG-L"><img alt="" class="img100" src="../images/figure_wo_caption_6.3.png"/></figure>
</section>
</section>
<section>
<h2 class="head a-head"><b>6.5    Project</b></h2>
<p class="noindent"><b>Objective</b>: Develop an assembler that translates programs written in Hack assembly language into Hack binary code.</p>
<p>This version of the assembler assumes that the source assembly code is error-free. Error checking, reporting, and handling can be added to later versions of the assembler but are not part of project 6.</p>
<p class="STNI1"><b>Resources</b>: The main tool you need for completing this project is the programming language in which you will implement your assembler. The assembler and CPU emulator supplied in <samp class="SANS_Consolas_Regular_11">nand2tetris/tools</samp> may also come in handy. These tools allow experimenting with a working assembler before setting out to build one yourself. Importantly, the supplied assembler allows comparing its output to the outputs generated by <i>your</i> assembler. For more information about these capabilities, refer to the assembler tutorial at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
<p class="STNI1"><b>Contract</b>: When given to your assembler as a command line argument, a <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> file containing a valid Hack assembly language program should be translated into the correct Hack binary code and stored in a file named <i>Prog</i><samp class="SANS_Consolas_Regular_11">.hack</samp>, located in the same folder as the source file (if a file by this name exists, it is overwritten). The output produced by your assembler must be identical to the output produced by the supplied assembler.</p>
<p class="STNI1"><b>Development plan</b>: We suggest building and testing the assembler in two stages. First, write a basic assembler designed to translate programs that contain no symbolic references. Then extend your assembler with symbol-handling capabilities.</p>
<p class="STNI1"><b>Test programs</b>: The first test program has no symbolic references. The remaining test programs come in two versions: <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> and <i>ProgL</i><samp class="SANS_Consolas_Regular_11">.asm</samp>, which are with and without symbolic references, respectively.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Add.asm</samp>: Adds the constants 2 and 3 and puts the result in <samp class="SANS_Consolas_Regular_11">R0</samp>.</p>
<p class="STNI1"><span aria-label="114" id="pg_114" role="doc-pagebreak"/><samp class="SANS_Consolas_Bold_B_11">Max.asm</samp>: Computes max<samp class="SANS_Consolas_Regular_11">(R0</samp>, <samp class="SANS_Consolas_Regular_11">R1)</samp> and puts the result in <samp class="SANS_Consolas_Regular_11">R2</samp>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Rect.asm</samp>: Draws a rectangle at the top-left corner of the screen. The rectangle is 16 pixels wide and <samp class="SANS_Consolas_Regular_11">R0</samp> pixels high. Before running this program, put a nonnegative value in <samp class="SANS_Consolas_Regular_11">R0</samp>.</p>
<p class="STNI1"><samp class="SANS_Consolas_Bold_B_11">Pong.asm</samp>: A classical single-player arcade game. A ball bounces repeatedly off the screen’s edges. The player attempts to hit the ball with a paddle, moving the paddle by pressing the left and right arrow keys. For every successful hit, the player gains a point and the paddle shrinks a little to make the game harder. If the player misses the ball, the game is over. To quit the game, press <samp class="SANS_Consolas_Regular_11">ESC</samp>.</p>
<p>The supplied Pong program was developed using tools that will be presented in part II of the book. In particular, the game software was written in the high-level Jack programming language and translated into the given <samp class="SANS_Consolas_Regular_11">Pong.asm</samp> file by the <i>Jack compiler</i>. Although the high-level <samp class="SANS_Consolas_Regular_11">Pong.jack</samp> program is only about three hundred lines of code, the executable Pong application is about twenty thousand lines of binary code, most of which is the Jack operating system. Running this interactive program in the supplied CPU emulator is a slow affair, so don’t expect a high-powered Pong game. This slowness is actually a virtue, since it enables tracking the graphical behavior of the program. As you develop the software hierarchy in part II, this game will run much faster.</p>
<p class="STNI1"><b>Testing</b>: Let <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> be an assembly Hack program, for example, one of the given test programs. There are essentially two ways to test whether your assembler translates <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> correctly. First, you can load the <i>Prog</i><samp class="SANS_Consolas_Regular_11">.hack</samp> file generated by your assembler into the supplied CPU emulator, execute it, and check that it’s doing what it’s supposed to be doing.</p>
<p>The second testing technique is to compare the code generated by your assembler to the code generated by the supplied assembler. To begin with, rename the file generated by your assembler to <i>Prog</i>1<samp class="SANS_Consolas_Regular_11">.hack</samp>. Next, load <i>Prog</i><samp class="SANS_Consolas_Regular_11">.asm</samp> into the supplied assembler, and translate it. If your assembler is working correctly, it follows that <i>Prog</i>1<samp class="SANS_Consolas_Regular_11">.hack</samp> must be identical to the <i>Prog</i><samp class="SANS_Consolas_Regular_11">.hack</samp> file produced by the supplied assembler. This comparison can be done by loading <i>Prog</i>1<samp class="SANS_Consolas_Regular_11">.asm</samp> as a compare file—see <a href="chapter_6.html#fig6-3" id="rfig6-3">figure 6.3</a> for the details.</p>
<figure class="IMG"><img alt="" id="fig6-3" src="../images/figure_6.3.png" width="450"/>
<figcaption><p class="CAP"><b><a href="#rfig6-3">Figure 6.3</a></b>    Testing the assembler’s output using the supplied assembler.</p></figcaption>
</figure>
<p class="STNI1"><b>A web-based version of project 6</b> is available at <a href="http://www.nand2tetris.org">www<wbr/>.nand2tetris<wbr/>.org</a>.</p>
</section>
<section>
<h2 class="head a-head"><b>6.6    Perspective</b></h2>
<p class="noindent">Like most assemblers, the Hack assembler is a relatively simple translator, dealing mainly with text processing. Naturally, assemblers for richer machine languages are more elaborate. Also, some assemblers feature more sophisticated symbol-handling capabilities not found in Hack. For example, some assemblers support <i>constant arithmetic</i> on symbols, like using<samp class="SANS_Consolas_Regular_11"><img alt="" class="inline" height="11" src="../images/6-C6.png" width="48"/></samp> to refer to the fifth memory location after the address referred to by <samp class="SANS_Consolas_Regular_11">base</samp>.</p>
<p><span aria-label="115" id="pg_115" role="doc-pagebreak"/>Many assemblers are extended to handle <i>macro-instructions</i>. A macro-instruction is a sequence of machine instructions that has a name. For example, our assembler can be extended to translate agreed-upon macro-instructions, for example, <img alt="" class="inline" height="10" src="../images/6-C7.png" width="26"/><samp class="SANS_Consolas_Regular_11">[</samp><i>addr</i><samp class="SANS_Consolas_Regular_11">]</samp>, into the two primitive Hack instructions <samp class="SANS_Consolas_Regular_11">@</samp><i>addr</i>, followed by <img alt="" class="inline" height="10" src="../images/6-C7.png" width="26"/>. Likewise, the macro-instruction <samp class="SANS_Consolas_Regular_11">goto</samp> <i>addr</i> can be translated into <samp class="SANS_Consolas_Regular_11">@</samp><i>addr</i>, followed by <samp class="SANS_Consolas_Regular_11">0;JMP</samp>, and so on. Such macro-instructions can considerably simplify the writing of assembly programs, at a low translation cost.</p>
<p>It should be noted that machine language programs are rarely written by humans. Rather, they are typically written by compilers. And a compiler—being an automaton—can optionally bypass the symbolic instructions and generate binary machine code directly. That said, an assembler is still a useful program, especially for developers of C/C<span class="symb">++</span> programs who are concerned about efficiency and optimization. By inspecting the symbolic code generated by the compiler, the programmer can improve the high-level code to achieve better performance on the host hardware. When the generated assembly code is considered efficient, it can be translated further by the assembler into the final binary, executable code.</p>
<hr class="transition_sb"/>
<p class="STNI1"><span aria-label="116" id="pg_116" role="doc-pagebreak"/>Congratulations! You’ve reached the end of part I of the Nand to Tetris journey. If you completed projects 1–6, you have built a general-purpose computer system from first principles. This is a fantastic achievement, and you should feel proud and accomplished.</p>
<p>Alas, the computer is capable of executing only programs written in machine language. In part II of the book we will use this barebone hardware platform as a point of departure and build on top of it a modern software hierarchy. The software will consist of a virtual machine, a compiler for a high-level, object-based programming language, and a basic operating system.</p>
<p>So, whenever you’re ready for more adventures, let’s move on to part II of our grand journey from Nand to Tetris.</p>
</section>
</section>
</div>
</body>
</html>